<!DOCTYPE HTML>
<html lang="de" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Die Programmiersprache Rust</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Eine deutsche Gemeinschafts-Übersetzung des offiziellen Rust-Buchs.">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="theme/ferris.css">
        
        <link rel="stylesheet" href="theme/2018-edition.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Die Programmiersprache Rust</a></li><li class="chapter-item expanded affix "><a href="foreword.html">Vorwort</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">Einführung</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> Erste Schritte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hallo Welt</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hallo Cargo</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> Ein Ratespiel programmieren</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> Allgemeine Programmierkonzepte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> Variablen und Veränderlichkeit</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> Datentypen</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> Funktionen</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> Kommentare</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> Kontrollfluss</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> Eigentümerschaft (ownership) verstehen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> Was ist Eigentümerschaft (ownership)?</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> Referenzen und Ausleihen (borrowing)</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Der Anteilstyp (slice)</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> Strukturen (structs) für zusammenhängende Daten verwenden</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> Strukturen (structs) definieren und instanziieren</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> Beispielprogramm mit Strukturen (structs)</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> Methodensyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> Aufzählungen (enums) und Musterabgleich (pattern matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> Eine Aufzählung (enum) definieren</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> Der Kontrollflussoperator match</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> Prägnanter Kontrollfluss mit if let</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> Pakete (packages) und Kisten (crates)</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> Mit Modulen den Kontrollumfang und Datenschutz steuern</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> Mit Pfaden auf ein Element im Modulbaum verweisen</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort use</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> Module in verschiedene Dateien aufteilen</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> Allgemeine Kollektionen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> Wertlisten in Vektoren ablegen</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> Fehlerbehandlung</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> Nicht behebbare Fehler mit panic!</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Behebbare Fehler mit Result</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> Wann panic! aufrufen und wann nicht?</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> Generische Typen, Merkmale (traits) und Lebensdauer</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> Generische Datentypen</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> Merkmale (traits): Gemeinsames Verhalten definieren</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> Referenzen validieren mit Lebensdauern</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> Automatisierte Tests schreiben</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> Tests schreiben</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> Steuern wie Tests ausgeführt werden</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> Testverwaltung</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> Ein E/A-Projekt: Ein Kommandozeilenprogramm erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> Kommandozeilenargumente entgegennehmen</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> Eine Datei einlesen</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> Refaktorierung um die Modularität und Fehlerbehandlung zu verbessern</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> Bibliotheksfunktionalität mit testgetriebener Entwicklung erstellen</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> Mit Umgebungsvariablen arbeiten</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> Fehlermeldungen in die Standardfehlerausgabe anstatt der Standardausgabe schreiben</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Funktionale Sprachelemente: Iteratoren und Funktionsabschlüsse (closures)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> Funktionsabschlüsse (closures): Anonyme Funktionen die ihre Umgebung erfassen können</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> Eine Reihe von Elementen verarbeiten mit Iteratoren</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> Unser E/A-Projekt verbessern</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> Performanzvergleich: Schleifen vs. Iteratoren</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> Mehr über Cargo und Crates.io</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> Bauvorgang anpassen mit Freigabeprofilen (release profiles)</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> Kisten (crate) auf crates.io veröffentlichen</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo-Arbeitsbereiche</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> Kommandozeilenwerkzeuge von crates.io installieren mit cargo install</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo um benutzerdefinierte Befehle erweitern</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> Intelligente Zeiger</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Mit Box<T> auf Daten im dynamischen Speicher zeigen</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> Intelligente Zeiger wie normale Referenzen behandeln mit dem Merkmal (trait) Deref</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Programmcode beim Aufräumen ausführen mit dem Merkmal (trait) Drop</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Der referenzzählende intelligente Zeiger Rc<T></a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> und das innere Veränderlichkeitsmuster</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> Referenzzyklen können zu einem Speicherleck führen</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> Furchtlose Nebenläufigkeit</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> Mit Prozessen (threads) Programmcode gleichzeitig ausführen</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> Nachrichtenaustausch zwischen Prozessen (threads)</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> Nebenläufigkeit mit gemeinsamem Zustand</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> Erweiterbare Nebenläufigkeit mit den Merkmalen (traits) Sync und Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Objektorientierte Sprachelemente von Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> Charakteristika objektorientierter Sprachen</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> Merkmalsobjekte (trait objects) die Werte unterschiedlicher Typen erlauben</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> Ein objektorientiertes Entwurfsmuster implementieren</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> Muster (patterns) und Abgleich (matching)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> Alle Stellen an denen Muster (patterns) verwendet werden können</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Widerlegbarkeit: Falls ein Muster (pattern) mal nicht passt</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> Mustersyntax</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> Fortgeschrittene Sprachelemente</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html"><strong aria-hidden="true">19.1.</strong> Unsicheres (unsafe) Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> Fortgeschrittene Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> Fortgeschrittene Typen</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> Erweiterte Funktionen und Funktionsabschlüsse (closures)</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> Makros</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> Abschlussprojekt: Einen mehrsträngigen (multi-threaded) Webserver erstellen</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> Einen einsträngigen (single-threaded) Webserver erstellen</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> Unseren einsträngigen (single-threaded) Webserver in einen mehrsträngigen (multi-threaded) Webserver verwandeln</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> Kontrolliertes Beenden und Aufräumen</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> Anhang</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - Schlüsselwörter</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - Operatoren und Symbole</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - Ableitbare Merkmale (traits)</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - Nützliche Entwicklungswerkzeuge</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - Ausgaben</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - Übersetzungen des Buchs</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Wie Rust erstellt wird und „nächtliches Rust“</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                    </div>

                    <h1 class="menu-title">Die Programmiersprache Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/rust-lang-de/rustbook-de" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#die-programmiersprache-rust" id="die-programmiersprache-rust">Die Programmiersprache Rust</a></h1>
<p><em>von Steve Klabnik und Carol Nichols, unter Mitarbeit der Rust-Gemeinschaft</em></p>
<p>Diese Version des Textes geht davon aus, dass du Rust 1.41.0 oder später mit
<code>edition=&quot;2018&quot;</code> in <em>Cargo.toml</em> in allen Projekten verwendest, um Rust 2018
Idiome zu verwenden. Siehe <a href="ch01-01-installation.html">Abschnitt „Installation“</a> zum Installieren
und Aktualisieren von Rust sowie <a href="appendix-05-editions.html">Anhang E</a> zu Informationen zu den
Ausgaben.</p>
<p>Ausgabe 2018 von Rust enthält einige Verbesserungen, die Rust ergonomischer und
einfacher zu lernen machen. Diese Fassung des Buchs enthält eine Reihe von
Änderungen, die diese Verbesserungen widerspiegeln:</p>
<ul>
<li>Kapitel 7 „Wachsende Projekte verwalten mit Paketen (packages), Kisten
(crates) und Modulen“ wurde größtenteils umgeschrieben. Das Modulsystem und
die Funktionsweise der Pfade in Ausgabe 2018 wurden konsistenter gestaltet.</li>
<li>Kapitel 10 hat die neuen Abschnitte „Merkmale als Parameter“ und
„Rückgabetypen die Merkmale implementieren“, die die neue Syntax von
<code>impl Trait</code> erklären.</li>
<li>Kapitel 11 hat einen neuen Abschnitt „Verwenden von <code>Result&lt;T, E&gt;</code> in Tests“,
der zeigt, wie man Tests schreibt, die den Operator <code>?</code> verwenden.</li>
<li>Der Abschnitt „Fortgeschrittene Lebensdauern“ in Kapitel 19 wurde entfernt,
weil die verwendeten Konstrukte durch Kompilierer-Verbesserungen noch
seltener geworden sind.</li>
<li>Der frühere Anhang D „Makros“ wurde um prozedurale Makros erweitert und in
den Abschnitt „Makros“ in Kapitel 19 verschoben.</li>
<li>Anhang A „Schlüsselwörter“ erläutert auch die neue Funktionalität der rohen
Bezeichner, die es ermöglicht, dass in Ausgabe 2015 und in Ausgabe 2018
geschriebener Programmcode zusammen verwendet werden kann.</li>
<li>Anhang D trägt jetzt den Titel „Nützliche Entwicklungswerkzeuge“ und umfasst
kürzlich veröffentlichte Werkzeuge, die dir beim Schreiben von Rust-Code
helfen.</li>
<li>Wir haben im gesamten Buch etliche kleine Fehler und unpräzise Formulierungen
korrigiert. Vielen Dank an die Leser, die sie gemeldet haben!</li>
</ul>
<p>Beachte, dass jeder kompilierbare Programmcode aus früheren Fassungen des Buchs
weiterhin kompiliert, wenn <code>edition=&quot;2018&quot;</code> nicht in <em>Cargo.toml</em> des Projekts
nicht angegeben wird, selbst wenn du die verwendete Rust-Kompilierer-Version
aktualisierst. Das ist die Rückwärtskompatibilitätsgarantie von Rust!</p>
<p>Die HTML-Version ist online verfügbar unter
https://doc.rust-lang.org/stable/book/ (englisches Original) und
https://rust-lang-de.github.io/rustbook-de/ (deutsche Übersetzung).
Wenn die Rust-Installation mit <code>rustup</code> erfolgt ist, kann das Buch offline mit
<code>rustup docs --book</code> geöffnet werden (nur in Englisch).</p>
<p>Der englische Text ist auch als <a href="https://nostarch.com/rust">Taschenbuch und E-Book bei No Starch
Press</a> erhältlich.</p>
<h1><a class="header" href="#vorwort" id="vorwort">Vorwort</a></h1>
<p>Es war nicht immer so klar, aber bei der Programmiersprache Rust geht es im
Grunde um <em>Befähigung</em>: Egal, welche Art von Kode du jetzt schreibst, Rust
befähigt dich dazu, weiter zu gehen, mit Vertrauen in einer größeren Vielfalt
von Bereichen zu programmieren, als du es zuvor getan hast.</p>
<p>Denken wir zum Beispiel an systemnahe Arbeiten, bei denen Details wie
Speicherverwaltung, Datenrepräsentation und Nebenläufigkeit wichtig sind.
Traditionellerweise gilt dieser Bereich der Programmierung als geheimnisvoll
und nur wenigen Auserwählten zugänglich, die die erforderliche Erfahrung
gesammelt haben, um berüchtigte Fallstricke vermeiden zu können. Und selbst
diejenigen, die damit arbeiten, tun dies mit Sorgfalt, damit ihr Kode nicht
angreifbar ist, abstürzt oder fehlerhaft ist.</p>
<p>Rust baut diese Barrieren ab, indem es die alten Fallstricke beseitigt und ein
freundliches, ausgefeiltes Instrumentarium zur Verfügung stellt, das dich auf
deinem Weg unterstützt. Programmierer, die in die systemnahen Kontrollebenen
„eintauchen“ müssen, können dies mit Rust tun, ohne das übliche Risiko von
Abstürzen oder Sicherheitslücken einzugehen und ohne die Finessen einer
wankelmütigen Werkzeugkette erlernen zu müssen. Besser noch, die Sprache ist so
konzipiert, dass sie dich auf natürliche Weise zu zuverlässigem Code führt, der
effizient in Bezug auf Geschwindigkeit und Speichernutzung ist.</p>
<p>Programmierer, die bereits mit systemnahem Code arbeiten, können Rust nutzen,
um ihre Ambitionen zu steigern. Beispielsweise ist die Einführung von
Parallelität in Rust ein relativ risikoarmes Unterfangen: Der Compiler fängt
die klassischen Fehler für dich ab. Und du kannst aggressivere Optimierungen in
deinem Kode wagen mit der Gewissheit, keine versehentlichen Abstürze oder
Verwundbarkeiten einführen.</p>
<p>Aber Rust ist nicht auf systemnahe Programmierung beschränkt. Es ist
ausdrucksstark und ergonomisch genug, um das Schreiben von
Kommandozeilen-Anwendungen, Webservern und vielen anderen Arten an Kode recht
angenehm zu machen – du wirst später in diesem Buch einfache Beispiele
dazu finden. Die Arbeit mit Rust ermöglicht es dir, Fähigkeiten zu entwickeln,
die von einer Domäne auf eine andere übertragen werden können; du kannst Rust
durch Schreiben einer Webanwendung erlernen und dann diese Fähigkeiten auf
deinen Raspberry Pi anwenden.</p>
<p>In diesem Buch wird das Potenzial von Rust zur Befähigung seiner Nutzer voll
ausgeschöpft. Es ist ein freundlicher und zugänglicher Text, der dir helfen
soll, nicht nur dein Wissen über Rust zu erweitern, sondern auch deine
Reichweite und dein Selbstvertrauen als Programmierer im Allgemeinen. Also
tauche ein, mach dich bereit zum Lernen – und willkommen in der
Rust-Gemeinschaft!</p>
<p>– Nicholas Matsakis und Aaron Turon</p>
<h1><a class="header" href="#einführung" id="einführung">Einführung</a></h1>
<p>Willkommen bei <em>Die Programmiersprache Rust</em>, einem einführenden Buch über
Rust. Die Programmiersprache Rust hilft dir, schnellere und zuverlässigere
Software zu schreiben. Ergonomie und systemnahe Kontrolle stehen beim Entwurf
von Programmiersprachen oft im Widerspruch – Rust stellt sich diesem
Konflikt. Durch den Ausgleich zwischen leistungsstarken, technischen
Möglichkeiten und einer großartigen Entwicklererfahrung bietet dir Rust die
Möglichkeit, Details systemnah (z.B. Speichernutzung) zu kontrollieren, ohne
den ganzen Ärger, der damit typischerweise einhergeht.</p>
<h2><a class="header" href="#für-wen-rust-ist" id="für-wen-rust-ist">Für wen Rust ist</a></h2>
<p>Rust ist für viele Menschen aus einer Vielzahl von Gründen ideal. Schauen wir
uns einige der wichtigsten Nutzergruppen an.</p>
<h3><a class="header" href="#entwicklerteams" id="entwicklerteams">Entwicklerteams</a></h3>
<p>Rust erweist sich als produktives Werkzeug in der Zusammenarbeit großer
Entwicklerteams mit unterschiedlichem Kenntnisstand in der
Systemprogrammierung. Systemnaher Code ist anfällig für eine Vielzahl subtiler
Fehler, die in den meisten anderen Sprachen nur durch ausgiebige Tests und
sorgfältige Überprüfung des Codes durch erfahrene Entwickler erkannt werden
können. In Rust spielt der Kompilierer eine Art Pförtnerrolle, indem er Code
mit diesen schwer fassbaren Fehlern verweigert zu kompilieren, darunter auch
Nebenläufigkeitsfehler. Mit der Arbeit an der Seite des Kompilierers kann sich
das Team auf die Programmlogik konzentrieren anstatt Fehler zu suchen.</p>
<p>Rust bringt auch zeitgemäße Entwicklerwerkzeuge in die Welt der
Systemprogrammierung:</p>
<ul>
<li>Cargo, das mitgelieferte Abhängigkeitsmanagement- und Bau-Werkzeug, macht das
Hinzufügen, Kompilieren und Verwalten von Abhängigkeiten im gesamten
Rust-Ökosystem schmerzlos und konsistent.</li>
<li>Rustfmt gewährleistet einen einheitlichen Codierstil aller Entwickler.</li>
<li>Der Rust Sprachdienst (Language Server) ermöglicht Code-Vervollständigung und
im Code angezeigte Fehlermeldungen innerhalb der Entwicklungsumgebung (IDE).</li>
</ul>
<p>Durch den Einsatz dieser und anderer Werkzeuge des Rust-Ökosystems können
Entwickler produktiv arbeiten, während sie Code auf Systemebene schreiben.</p>
<h3><a class="header" href="#studenten" id="studenten">Studenten</a></h3>
<p>Rust ist für Studenten und alle, die sich für Systemkonzepte interessieren. Mit
Rust haben viele Menschen etwas über Themen wie die Entwicklung von
Betriebssystemen gelernt. Die Gemeinschaft ist sehr einladend und beantwortet
gerne Fragen der Studenten. Durch Bemühungen wie dieses Buch will das Rust-Team
Systemkonzepte mehr Menschen zugänglich machen, insbesondere denen, die neu in
der Programmierung sind.</p>
<h3><a class="header" href="#unternehmen" id="unternehmen">Unternehmen</a></h3>
<p>Hunderte von Unternehmen, große und kleine, setzen Rust für eine Vielzahl von
Aufgaben in der Produktion ein. Zu diesen Aufgaben gehören
Kommandozeilenwerkzeuge, Webdienste, DevOps-Werkzeuge, eingebettete Geräte,
Audio- und Videoanalyse und -transkodierung, Kryptowährungen, Bioinformatik,
Suchmaschinen, Anwendungen für das Internet der Dinge, maschinelles Lernen und
sogar wesentliche Teile des Webbrowsers Firefox.</p>
<h3><a class="header" href="#open-source-entwickler" id="open-source-entwickler">Open-Source-Entwickler</a></h3>
<p>Rust ist für Menschen, die die Programmiersprache Rust, die Gemeinschaft,
Entwickler-Werkzeuge und Bibliotheken aufbauen möchten. Wir würden uns freuen,
wenn du zur Programmiersprache Rust beiträgst.</p>
<h3><a class="header" href="#menschen-die-geschwindigkeit-und-stabilität-schätzen" id="menschen-die-geschwindigkeit-und-stabilität-schätzen">Menschen, die Geschwindigkeit und Stabilität schätzen</a></h3>
<p>Rust ist für Menschen, die sich nach Schnelligkeit und Stabilität einer Sprache
sehnen. Unter Geschwindigkeit verstehen wir die Geschwindigkeit der Programme,
die du mit Rust schreiben kannst, und die Geschwindigkeit, mit der dich Rust
diese Programme schreiben lässt. Die Prüfungen des Rust-Kompilierers
gewährleisten Stabilität während du neue Funktionen hinzufügst und deinen Code
änderst. Dies steht im Gegensatz zu brüchigen Code-Altlasten in Sprachen ohne
diese Prüfungen, die Entwickler oft scheuen modifizieren zu müssen. Durch das
Streben nach kostenneutralen Abstraktionen, also Funktionalität auf höherer
Ebene, die zu genauso schnellem Code wie manuell geschriebener Code auf
niedrigerer Ebene kompiliert, bemüht sich Rust, sicheren Code auch zu schnellem
Code zu machen.</p>
<p>Die Sprache Rust hofft, auch viele andere Nutzer zu unterstützen; die hier
genannten sind nur einige der größten Interessensgruppen. Insgesamt ist es
Rusts größtes Bestreben, den Zielkonflikt zu beseitigen, den Programmierer
jahrzehntelang hingenommen haben, wenn sie Sicherheit <em>und</em> Produktivität bzw.
Geschwindigkeit <em>und</em> Ergonomie erreichen wollten. Versuche es mit Rust und
finde heraus, ob dessen Möglichkeiten für dich geeignet sind.</p>
<h2><a class="header" href="#für-wen-dieses-buch-gedacht-ist" id="für-wen-dieses-buch-gedacht-ist">Für wen dieses Buch gedacht ist</a></h2>
<p>In diesem Buch wird davon ausgegangen, dass du bereits Code in einer anderen
Programmiersprache geschrieben hast, es spielt aber keine Rolle in welcher. Wir
haben versucht, das Material einem breiten Publikum mit unterschiedlichem
Programmierhintergrund zugänglich zu machen. Wir verbringen nicht viel Zeit
damit, darüber zu sprechen, was Programmieren <em>ist</em> oder wie man darüber denkt.
Wenn Programmieren für dich ganz neu ist, wäre es besser, wenn du ein Buch
speziell zur Einführung in die Programmierung liest.</p>
<h2><a class="header" href="#wie-man-dieses-buch-verwendet" id="wie-man-dieses-buch-verwendet">Wie man dieses Buch verwendet</a></h2>
<p>Im Allgemeinen geht dieses Buch davon aus, dass du es der Reihe nach von vorne
nach hinten lesen. Spätere Kapitel bauen auf den Konzepten früherer Kapitel
auf. Frühere Kapitel gehen möglicherweise nicht in die Einzelheiten eines
Themas ein, denn in der Regel werden wir es in einem späteren Kapitel erneut
aufgreifen.</p>
<p>Du findest in diesem Buch zwei Kapitelarten: Konzeptkapitel und
Projektkapitel. In Konzeptkapiteln erfährst du etwas über einen Aspekt von
Rust. In Projektkapiteln schreiben wir gemeinsam kleine Programme und wenden
das bisher Gelernte an. Die Kapitel 2, 12 und 20 sind Projektkapitel; die
übrigen sind Konzeptkapitel.</p>
<p>Kapitel 1 erklärt, wie man Rust installiert, wie man ein „Hallo Welt“-Programm
schreibt und wie man Cargo, den Paketmanager und das Bauwerkzeug von Rust,
benutzt. Kapitel 2 ist eine praktische Einführung in die Sprache Rust. Hier
werden Konzepte auf hohem Niveau behandelt, spätere Kapitel werden zusätzliche
Einzelheiten liefern. Wenn du dir schon jetzt die Hände schmutzig machen
willst, dann ist Kapitel 2 der richtige Ort dafür. Zunächst willst du
vielleicht sogar Kapitel 3 überspringen, in dem es um Rust-Funktionen geht, die
denen anderer Programmiersprachen ähneln, und direkt zu Kapitel 4 übergehen, um
mehr über den Eigentümerschaftsansatz von Rust zu erfahren. Wenn du jedoch ein
besonders akribischer Lerner bist, der lieber erst jedes Detail lernen will,
bevor er zum nächsten übergeht, willst du vielleicht Kapitel 2 überspringen und
direkt zu Kapitel 3 gehen und danach zu Kapitel 2 zurückkehren, um dann an
einem Projekt zu arbeiten und die gelernten Details anzuwenden.</p>
<p>Kapitel 5 bespricht Strukturen und Methoden, und Kapitel 6 behandelt
Aufzählungen, <code>match</code>-Ausdrücke und das <code>if let</code>-Kontrollflusskonstrukt. Du
wirst Strukturen und Aufzählungen verwenden, um benutzerdefinierte Typen in
Rust zu erstellen.</p>
<p>In Kapitel 7 erfährst du mehr über das Modulsystem von Rust und über die
Datenschutzregeln zum Organisieren deines Codes und dessen öffentlich
zugängliche Programmierschnittstelle (API). In Kapitel 8 werden einige gängige
Kollektionsdatenstrukturen, die die Standardbibliothek zur Verfügung stellt,
behandelt, z.B. Vektoren, Zeichenketten und Hashtabellen. Kapitel 9 befasst
sich mit Rusts Philosophie und Techniken der Fehlerbehandlung.</p>
<p>Kapitel 10 vertieft generische Datentypen, Merkmale und Lebensdauern, die dir
die Möglichkeit geben, Code zu schreiben, der für mehrere Typen passt. In
Kapitel 11 dreht sich alles um das Testen, das selbst mit den
Sicherheitsgarantien von Rust erforderlich ist, um eine korrekte Logik deines
Programms sicherzustellen. In Kapitel 12 werden wir unsere eigene
Implementierung für eine Teilfunktionalität des Kommandozeilenwerkzeugs <code>grep</code>
schreiben, das nach Text in Dateien sucht. Dazu werden wir viele Konzepte
anwenden, die wir in den vorangegangenen Kapiteln kennengelernt haben.</p>
<p>Kapitel 13 befasst sich mit Funktionsabschlüssen und Iteratoren, also
Sprachmerkmalen, die von funktionalen Programmiersprachen stammen. In Kapitel
14 werden wir einen genaueren Blick auf Cargo werfen und über bewährte
Vorgehensweisen beim Bereitstellen deiner Bibliotheken für andere sprechen. In
Kapitel 15 werden intelligente Zeiger, die die Standardbibliothek bereitstellt,
und Merkmale, die ihre Funktionalität ermöglichen, erörtert.</p>
<p>In Kapitel 16 gehen wir durch verschiedene Modelle der nebenläufigen
Programmierung und sprechen darüber, wie Rust dir hilft, furchtlos mit mehreren
Strängen zu programmieren. Kapitel 17 befasst sich mit dem Vergleich zwischen
Rust-Idiomen und den Prinzipien der objektorientierten Programmierung, mit
denen du vielleicht vertraut bist.</p>
<p>Kapitel 18 ist ein Nachschlagewerk zu Muster und Musterabgleich, einem
mächtigen Mittel zum Ausdrücken von Ideen in Rust-Programmen. Kapitel 19
enthält ein Sammelsurium an interessanten fortgeschrittenen Themen, darunter
unsicheres Rust, Makros und mehr zu Lebensdauer, Merkmalen, Typen, Funktionen
und Funktionsabschlüssen.</p>
<p>In Kapitel 20 werden wir ein Projekt abschließen, bei dem wir einen
systemnahen, nebenläufigen Webdienst implementieren!</p>
<p>Schließlich enthalten einige Anhänge nützliche Informationen über die Sprache
in einem eher referenzartigen Format. Anhang A enthält die Schlüsselwörter von
Rust, Anhang B die Operatoren und Symbole von Rust, Anhang C ableitbare
Merkmalen, die von der Standardbibliothek mitgebracht werden, Anhang D
nützliche Entwicklungswerkzeuge und Anhang E erläutert die Rust-Ausgaben.</p>
<p>Es gibt keinen falschen Weg, dieses Buch zu lesen: Wenn du was überspringen
willst, nur zu! Möglicherweise musst du zu früheren Kapiteln zurückkehren, wenn
du irritiert bist. Aber tue was immer für dich passt.</p>
<p><span id="ferris"></span></p>
<p>Ein wichtiger Teil beim Lernen von Rust ist das Verstehen der Fehlermeldungen,
die der Kompilierer anzeigt: Diese leiten dich zum funktionierenden Code. Daher
werden wir viele Beispiele bringen, die nicht kompilieren, zusammen mit der
jeweiligen Fehlermeldung des Kompilierers. Wenn du also ein zufälliges Beispiel
eingibst und ausführen willst, lässt es sich möglicherweise nicht kompilieren!
Stelle sicher, dass du den umgebenden Text liest, um zu wissen, ob das
Beispiel, das du ausführen willst, für einen Fehler gedacht ist. Ferris gibt
dir einen Hinweis bei Code, der nicht funktionieren soll:</p>
<table><thead><tr><th>Ferris</th><th>Bedeutung</th></tr></thead><tbody>
<tr><td><img src="img/ferris/does_not_compile.svg" class="ferris-explain"/></td><td>Dieser Code lässt sich nicht kompilieren!</td></tr>
<tr><td><img src="img/ferris/panics.svg" class="ferris-explain"/></td><td>Dieser Code bricht ab (panic)!</td></tr>
<tr><td><img src="img/ferris/unsafe.svg" class="ferris-explain"/></td><td>Dieser Codeblock enthält unsicheren Code.</td></tr>
<tr><td><img src="img/ferris/not_desired_behavior.svg" class="ferris-explain"/></td><td>Dieser Code liefert nicht das gewünschte Verhalten.</td></tr>
</tbody></table>
<p>In den meisten Situationen führen wir dich zu einer funktionierenden
Codeversion, wenn er sich nicht kompilieren lässt.</p>
<h2><a class="header" href="#quellcode" id="quellcode">Quellcode</a></h2>
<p>Die Quelldateien, aus denen dieses Buch generiert wird, findest du unter
<a href="https://github.com/rust-lang-de/rustbook-de/tree/master/src">GitHub</a>.</p>
<h2><a class="header" href="#datentypen" id="datentypen">Datentypen</a></h2>
<p>Jeder Wert in Rust ist von einem bestimmten <em>Datentyp</em>, der Rust mitteilt,
welche Art von Daten angegeben wird, damit es weiß, wie es mit diesen Daten
arbeiten soll. Wir werden uns zwei Datentyp-Untermengen ansehen: Skalar und
Verbund.</p>
<p>Denk daran, dass Rust eine <em>statisch typisierte</em> Sprache ist, was bedeutet,
dass es die Typen von allen Variablen zur Kompilierzeit kennen muss. Der
Kompilierer kann normalerweise auf der Grundlage des Wertes und wie wir ihn
verwenden ableiten, welchen Typ wir verwenden wollen. Wenn mehrere Typen
möglich sind, wie zum Beispiel als wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number">„Vergleich der Vermutung
mit der Geheimzahl“</a> eine
Zeichenkette (<code>String</code>) mittels <code>parse</code> zu einem numerischen Typ umwandelten,
müssen wir eine Typ-Annotation ergänzen, wie hier:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Keine Zahl!&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir diese Typ-Annotation nicht angeben, zeigt Rust den folgenden Fehler
an, was bedeutet, dass der Kompilierer mehr Informationen von uns benötigt, um
zu wissen welchen Typ wir verwenden wollen:</p>
<pre><code class="language-console">$ cargo build
   Compiling no_type_annotations v0.1.0 (file:///projects/no_type_annotations)
error[E0282]: type annotations needed
 --&gt; src/main.rs:2:9
  |
2 |     let guess = &quot;42&quot;.parse().expect(&quot;Keine Zahl!&quot;);
  |         ^^^^^ consider giving `guess` a type

error: aborting due to previous error

For more information about this error, try `rustc --explain E0282`.
error: could not compile `no_type_annotations`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Für andere Datentypen wirst du andere Typ-Annotationen sehen.</p>
<h3><a class="header" href="#skalare-typen" id="skalare-typen">Skalare Typen</a></h3>
<p>Ein <em>skalarer</em> Typ stellt einen einzelnen Wert dar. Rust hat vier primäre
skalare Typen: Ganze Zahlen, Fließkommazahlen, boolesche Werte (Wahrheitswerte)
und Zeichen. Du erkennst diese vielleicht aus anderen Programmiersprachen. Lass
uns darüber sprechen, wie sie in Rust funktionieren.</p>
<h4><a class="header" href="#ganzzahl-typen" id="ganzzahl-typen">Ganzzahl-Typen</a></h4>
<p>Eine <em>ganze Zahl</em> ist eine Zahl ohne Bruchteilkomponente. Wir verwendeten eine
ganze Zahl in Kapitel 2, den Typ <code>u32</code>. Diese Typdeklaration gibt an, dass der
Wert, dem sie zugeordnet ist, eine 32 Bit große ganze Zahl ohne Vorzeichen ist
(vorzeichenbehaftete Ganzzahl-Typen beginnen mit <code>i</code> anstatt <code>u</code>). Tabelle 3-1
zeigt die in Rust eingebauten Ganzzahl-Typen. Jede Variante in den Spalten
Vorzeichenbehaftet und Vorzeichenlos (zum Beispiel <code>i16</code>) kann benutzt werden,
um den Typ eines ganzzahligen Wertes zu deklarieren.</p>
<p><span class="caption">Tabelle 3-1: Ganzzahlige Typen in Rust</span></p>
<table><thead><tr><th align="right">Länge</th><th>Vorzeichenbehaftet</th><th>Vorzeichenlos</th></tr></thead><tbody>
<tr><td align="right">8 Bit</td><td><code>i8</code></td><td><code>u8</code></td></tr>
<tr><td align="right">16 Bit</td><td><code>i16</code></td><td><code>u16</code></td></tr>
<tr><td align="right">32 Bit</td><td><code>i32</code></td><td><code>u32</code></td></tr>
<tr><td align="right">64 Bit</td><td><code>i64</code></td><td><code>u64</code></td></tr>
<tr><td align="right">128 Bit</td><td><code>i128</code></td><td><code>u128</code></td></tr>
<tr><td align="right">arch</td><td><code>isize</code></td><td><code>usize</code></td></tr>
</tbody></table>
<p>Jede Variante kann entweder vorzeichenbehaftet oder vorzeichenlos sein und hat
eine explizite Größe. <em>Vorzeichenbehaftet</em> und <em>vorzeichenlos</em> bezieht sich
darauf, ob es möglich ist, dass die Zahl negativ oder positiv ist – in
anderen Worten, ob die Zahl ein Vorzeichen haben muss (vorzeichenbehaftet) oder
ob sie immer nur positiv sein wird und daher ohne Vorzeichen dargestellt werden
kann (vorzeichenlos). Es ist wie das Schreiben von Zahlen auf Papier: Wenn das
Vorzeichen eine Rolle spielt, wird die Zahl mit einem Plus- oder Minuszeichen
geschrieben; wenn man jedoch davon ausgehen kann, dass die Zahl positiv ist,
wird sie ohne Vorzeichen geschrieben. Vorzeichenbehaftete Zahlen werden unter
Verwendung der
<a href="https://de.wikipedia.org/wiki/Zweierkomplement">Zweierkomplementdarstellung</a>
gespeichert</p>
<p>Jede vorzeichenbehaftete Variante kann Zahlen von -(2<sup>n - 1</sup>) bis
einschließlich 2<sup>n - 1</sup> - 1 speichern, wobei <em>n</em> die Anzahl an Bits
ist, die diese Variante benutzt. Ein <code>i8</code> kann also Zahlen von -(2<sup>7</sup>)
bis 2<sup>7</sup> - 1 speichern, was -128 bis 127 entspricht. Vorzeichenlose
Varianten können Zahlen von 0 bis 2<sup>n</sup> - 1 speichern, also kann ein
<code>u8</code> Zahlen von 0 bis 2<sup>8</sup> - 1 speichern, was 0 bis 255 entspricht.</p>
<p>Zusätzlich hängen die Typen <code>isize</code> und <code>usize</code> von der Art des Computers ab,
auf dem dein Programm läuft: 64 Bit wenn du dich auf einer 64-Bit-Architektur
befindest und 32 Bit auf einer 32-Bit-Architektur.</p>
<p>Du kannst ganzzahlige Literale in jeder der in Tabelle 3-2 gezeigten Formen
schreiben. Beachte, dass alle Zahlenliterale mit Ausnahme des Byte-Literals
einen Typ-Suffix erlauben, z.B. <code>57u8</code> und <code>_</code> als visuelles Trennzeichen, z.B.
<code>1_000</code>.</p>
<p><span class="caption">Tabelle 3-2: Ganzzahl-Literale in Rust</span></p>
<table><thead><tr><th>Ganzahl-Literal</th><th>Beispiel</th></tr></thead><tbody>
<tr><td>Dezimal</td><td><code>98_222</code></td></tr>
<tr><td>Hex</td><td><code>0xff</code></td></tr>
<tr><td>Oktal</td><td><code>0o77</code></td></tr>
<tr><td>Binär</td><td><code>0b1111_0000</code></td></tr>
<tr><td>Byte (nur <code>u8</code>)</td><td><code>b'A'</code></td></tr>
</tbody></table>
<p>Woher weist du also, welche Ganzzahlart zu verwenden ist? Wenn du dir unsicher
bist, sind Rusts Standards im Allgemeinen eine gute Wahl und ganzzahlige Typen
sind standardmäßig <code>i32</code>: dieser Typ ist im Allgemeinen am schnellsten, selbst
auf 64-Bit-Systemen. Die primäre Situation in der du <code>isize</code> oder <code>usize</code>
benutzen würdest, ist die Indizierung einer Kollektionsart (collection).</p>
<blockquote>
<h5><a class="header" href="#ganzzahlüberlauf" id="ganzzahlüberlauf">Ganzzahlüberlauf</a></h5>
<p>Nehmen wir an, du hast eine Variable vom Typ <code>u8</code>, die Werte zwischen 0 und
255 annehmen kann. Wenn du versuchst, die Variable auf einen Wert außerhalb
dieses Bereiches zu ändern, z.B. auf 256, tritt ein Ganzzahlüberlauf auf.
Rust hat einige interessante Regeln, die dieses Verhalten betreffen. Wenn du
im Fehlersuchmodus (debug mode) kompilierst, fügt Rust Prüfungen auf
Ganzzahlüberläufe ein, was dazu führt, dass dein Programm zur Laufzeit
<em>abbricht</em> (panic), falls dieses Verhalten auftritt. Rust verwendet den
Begriff „panic“, wenn ein Programm durch einen Fehler abgebrochen wird; wir
werden Programmabbrüche im Abschnitt <a href="ch09-01-unrecoverable-errors-with-panic.html">„Unbehebbare Fehler mit
<code>panic!</code>“</a> in Kapitel 9 näher betrachten.</p>
<p>Wenn du mit dem Schalter <code>--release</code> im Freigabemodus (release mode)
kompilierst, fügt Rust <em>keine</em> Prüfungen auf Ganzzahlüberläufe, die das
Programm abbrechen, ein. Wenn ein Überlauf auftritt, führt Rust stattdessen
einen <em>Zweier-Komplement-Umbruch</em> durch. Kurz gesagt, Werte die größer als
der Maximalwert den der Typ enthalten kann sind, werden umgebrochen zum
kleinsten Wert den der Typ enthalten kann. Im Falle eines <code>u8</code> wird 256 zu 0,
257 zu 1 und so weiter. Das Programm wird nicht abbrechen, aber die Variable
wird wahrscheinlich einen anderen Wert annehmen, als du erwartest. Sich auf
das Verhalten von Ganzzahlüberläufen zu verlassen wird als Fehler angesehen.
Wenn du explizit umbrechen willst, kannst du den Typ <a href="https://doc.rust-lang.org/std/num/struct.Wrapping.html"><code>Wrapping</code></a>
aus der Standardbibliothek verwenden.</p>
</blockquote>
<h4><a class="header" href="#fließkomma-typen" id="fließkomma-typen">Fließkomma-Typen</a></h4>
<p>Rust hat auch zwei primitive Typen für <em>Fließkommazahlen</em>, das sind Zahlen mit
Dezimalkomma. Die Fließkomma-Typen in Rust sind <code>f32</code> und <code>f64</code>, die 32 Bit
bzw. 64 Bit groß sind. Der Standardtyp ist <code>f64</code>, da er auf modernen CPUs
ungefähr die gleiche Geschwindigkeit wie <code>f32</code> hat, aber eine höhere Präzision
ermöglicht.</p>
<p>Hier ist ein Beispiel, das Fließkommazahlen in Aktion zeigt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
</code></pre></pre>
<p>Fließkommazahlen werden nach dem IEEE-754-Standard dargestellt. Der Typ <code>f32</code>
ist eine Fließkommazahl mit einfacher Genauigkeit und <code>f64</code> mit doppelter
Genauigkeit.</p>
<h4><a class="header" href="#numerische-operationen" id="numerische-operationen">Numerische Operationen</a></h4>
<p>Rust unterstützt grundlegende mathematische Operationen, die man bei allen
Zahlentypen erwartet: Addition, Subtraktion, Multiplikation, Division und
Restberechnung. Der folgende Code zeigt, wie du die einzelnen Typen in einer
<code>let</code>-Anweisung verwenden würdest:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Addition
    let sum = 5 + 10;

    // Subtraktion
    let difference = 95.5 - 4.3;

    // Multiplikation
    let product = 4 * 30;

    // Division
    let quotient = 56.7 / 32.2;

    // Restberechnung
    let remainder = 43 % 5;
}
</code></pre></pre>
<p>Jeder Ausdruck in diesen Anweisungen verwendet einen mathematischen Operator
und wird zu einem einzelnen Wert ausgewertet, der dann an eine Variable
gebunden wird. Anhang B enthält eine Liste aller Operatoren, die Rust anbietet.</p>
<h4><a class="header" href="#der-boolesche-typ" id="der-boolesche-typ">Der boolesche Typ</a></h4>
<p>Wie in den meisten anderen Programmiersprachen hat ein boolescher Typ in Rust
zwei mögliche Werte: <code>true</code> (wahr) und <code>false</code> (falsch). Boolesche Werte sind
ein Byte groß. In Rust wird der boolesche Typ mit <code>bool</code> spezifiziert. Zum
Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let t = true;

    let f: bool = false; // mit expliziter Typ-Annotation
}
</code></pre></pre>
<p>Hauptsächlich werden boolesche Werte in Bedingungen verwendet, z.B. im
<code>if</code>-Ausdruck. Wie <code>if</code>-Ausdrücke in Rust funktionieren werden wir im Abschnitt
<a href="ch03-05-control-flow.html#control-flow">„Kontrollfluss“</a> erläutern.</p>
<h4><a class="header" href="#der-zeichen-typ" id="der-zeichen-typ">Der Zeichen-Typ</a></h4>
<p>Bislang haben wir nur mit Zahlen gearbeitet, aber Rust unterstützt auch
Buchstaben. Rusts Typ <code>char</code> ist der primitivste alphabetische Typ der Sprache,
der folgende Code zeigt eine Möglichkeit, ihn zu verwenden. (Beachte, dass
<code>char</code>-Literale mit einfachen Anführungszeichen angegeben werden, im Gegensatz
zu Zeichenketten-Literalen, die doppelte Anführungszeichen verwenden.)</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
</code></pre></pre>
<p>Der Typ <code>char</code> von Rust ist vier Bytes groß und stellt einen Unicode-Skalarwert
dar, was bedeutet, dass er viel mehr als nur ASCII darstellen kann.
Akzentuierte Buchstaben, chinesische, japanische und koreanische Zeichen, Emoji
und Leerzeichen mit Null-Breite sind gültige <code>char</code>-Werte in Rust.
Unicode-Skalarwerte reichen von <code>U+0000</code> bis <code>U+D7FF</code> und von <code>U+E000</code> bis
einschließlich <code>U+10FFFF</code>. Ein „Zeichen“ ist jedoch nicht wirklich ein Konzept
in Unicode, deine menschliche Intuition dafür, was ein „Zeichen“ ist, stimmt
möglicherweise nicht mit dem überein, was ein <code>char</code> in Rust ist. Wir werden
dieses Thema in <a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">„UTF-8-kodierten Text in Zeichenketten (strings)
ablegen“</a> in Kapitel 8 im Detail diskutieren.</p>
<h3><a class="header" href="#verbund-typen" id="verbund-typen">Verbund-Typen</a></h3>
<p><em>Verbund-Typen</em> (compound types) können mehrere Werte zu einem Typ gruppieren.
Rust hat zwei primitive Verbund-Typen: Tupel (tuples) und Arrays (arrays).</p>
<h4><a class="header" href="#der-tupel-typ" id="der-tupel-typ">Der Tupel-Typ</a></h4>
<p>Ein Tupel ist eine allgemeine Möglichkeit, eine Reihe von Werten mit einer
Vielzahl von Typen zu einem Verbund-Typ zusammenzufassen. Tupel haben eine
feste Länge: Einmal deklariert, können sie weder wachsen noch schrumpfen.</p>
<p>Wir erzeugen ein Tupel, indem wir eine durch Kommata getrennte Liste von Werten
innerhalb von Klammern schreiben. Jede Position im Tupel hat einen Typ und die
Typen der verschiedenen Werte im Tupel müssen nicht gleich sein. In diesem
Beispiel haben wir optionale Typ-Annotationen angegeben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
</code></pre></pre>
<p>Die Variable <code>tup</code> bindet das gesamte Tupel, da ein Tupel als ein einziges
Verbundelement betrachtet wird. Um die einzelnen Werte aus einem Tupel
herauszubekommen, können wir den Musterabgleich verwenden, um einen Tupelwert
zu destrukturieren, etwa so:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!(&quot;Der Wert von y ist: {}&quot;, y);
}
</code></pre></pre>
<p>Dieses Programm erzeugt zunächst ein Tupel und bindet es an die Variable <code>tup</code>.
Dann benutzt es ein Muster mit <code>let</code>, um <code>tup</code> zu nehmen und in drei separate
Variablen <code>x</code>, <code>y</code> und <code>z</code> umzuwandeln. Dies nennt man <em>destrukturieren</em>
(destructuring), weil es das einzelne Tupel in drei Teile zerlegt. Schließlich
gibt das Programm den Wert von <code>y</code> aus, der <code>6.4</code> ist.</p>
<p>Zusätzlich zum Destrukturieren durch Musterabgleich können wir direkt auf ein
Tupelelement zugreifen, indem wir einen Punkt (<code>.</code>) gefolgt vom Index des
Wertes, auf den wir zugreifen wollen, verwenden. Zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
</code></pre></pre>
<p>Dieses Programm erzeugt ein Tupel <code>x</code> und erstellt dann neue Variablen für
jedes Element, indem es ihre jeweiligen Indizes verwendet. Wie bei den meisten
Programmiersprachen ist der erste Index in einem Tupel 0.</p>
<h4><a class="header" href="#der-array-typ" id="der-array-typ">Der Array-Typ</a></h4>
<p>Eine andere Möglichkeit, eine Kollektion mit mehreren Werten zu haben, ist mit
einem <em>Array</em>. Im Gegensatz zu einem Tupel muss jedes Element eines Arrays den
gleichen Typ haben. Arrays in Rust unterscheiden sich von Arrays in einigen
anderen Sprachen, weil Arrays in Rust eine feste Länge haben, wie Tupel.</p>
<p>In Rust werden die in ein Array eingehenden Werte als kommagetrennte Liste in
eckige Klammern geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];
}
</code></pre></pre>
<p>Arrays sind nützlich, wenn du deine Daten eher auf dem Stapelspeicher als im
dynamischen Speicher abgelegt haben möchtest (auf den Stapelspeicher und den
dynamischen Speicher gehen wir in Kapitel 4 näher ein) oder wenn du
sicherstellen willst, dass du immer eine feste Anzahl von Elementen hast. Ein
Array ist jedoch nicht so flexibel wie der Vektortyp. Ein Vektor ist ein
ähnlicher Kollektionstyp, der von der Standardbibliothek zur Verfügung gestellt
wird und der in seiner Größe wachsen oder schrumpfen kann. Wenn du dir nicht
sicher bist, ob du ein Array oder einen Vektor verwenden sollst, solltest du
wahrscheinlich einen Vektor verwenden. In Kapitel 8 werden Vektoren
ausführlicher besprochen.</p>
<p>Ein Beispiel dafür, wann du ein Array statt eines Vektors verwenden möchtest,
ist in einem Programm, das die Namen der Monate des Jahres kennen muss. Es ist
sehr unwahrscheinlich, dass ein solches Programm Monate hinzufügen oder
entfernen muss, sodass du ein Array verwenden kannst, weil du weißt, dass es
immer 12 Elemente enthalten wird:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let months = [&quot;Januar&quot;, &quot;Februar&quot;, &quot;März&quot;, &quot;April&quot;, &quot;Mai&quot;, &quot;Juni&quot;, &quot;Juli&quot;,
              &quot;August&quot;, &quot;September&quot;, &quot;Oktober&quot;, &quot;November&quot;, &quot;Dezember&quot;];
<span class="boring">}
</span></code></pre></pre>
<p>Du würdest den Typ eines Arrays mit eckigen Klammern schreiben und innerhalb
der Klammern den Typ jedes Elements, ein Semikolon und dann die Anzahl der
Elemente im Array angeben, etwa so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a: [i32; 5] = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Hier ist <code>i32</code> der Typ aller Elemente. Nach dem Semikolon gibt die Zahl <code>5</code> an,
dass das Array fünf Elemente enthält.</p>
<p>Das Angeben eines Array-Typs auf diese Weise ähnelt einer alternativen Syntax
für die Initialisierung eines Arrays: Wenn du ein Array erstellen möchtest, das
für jedes Element den gleichen Wert enthält, kannst du den Anfangswert, gefolgt
von einem Semikolon und dann die Länge des Arrays in eckigen Klammern angeben,
wie hier gezeigt:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [3; 5];
<span class="boring">}
</span></code></pre></pre>
<p>Das Array mit dem Namen <code>a</code> wird <code>5</code> Elemente enthalten, die alle anfänglich
auf den Wert <code>3</code> gesetzt werden. Dies ist dasselbe wie das Schreiben von
<code>let a = [3, 3, 3, 3, 3];</code>, aber in einer prägnanteren Weise.</p>
<h5><a class="header" href="#zugriff-auf-array-elemente" id="zugriff-auf-array-elemente">Zugriff auf Array-Elemente</a></h5>
<p>Ein Array ist ein einzelnes Stück Speicher, das auf den Stapelspeicher gelegt
wird. Du kannst auf Elemente eines Arrays mit Hilfe der Indizierung wie folgt
zugreifen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
</code></pre></pre>
<p>In diesem Beispiel erhält die Variable mit dem Namen <code>first</code> den Wert <code>1</code>, weil
das der Wert am Index <code>[0]</code> im Array ist. Die Variable mit dem Namen <code>second</code>
wird den Wert <code>2</code> vom Index <code>[1]</code> im Array erhalten.</p>
<h5><a class="header" href="#ungültiger-array-element-zugriff" id="ungültiger-array-element-zugriff">Ungültiger Array-Element-Zugriff</a></h5>
<p>Was passiert, wenn du versuchst, auf ein Element eines Arrays zuzugreifen, das
sich hinter dem Ende des Arrays befindet? Angenommen, du änderst das Beispiel
in den folgenden Code, der sich kompilieren lässt, aber mit einem Fehler
abbricht, wenn er ausgeführt wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore panics">fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!(&quot;Der Wert von element ist: {}&quot;, element);
}
</code></pre>
<p>Die Ausführung dieses Codes mit <code>cargo run</code> ergibt folgendes Ergebnis:</p>
<pre><code class="language-console">$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is 10', src/main.rs:5:19
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Das Kompilieren ergab keinen Fehler, aber das Programm führte zu einem
<em>Laufzeitfehler</em> und wurde nicht erfolgreich beendet. Wenn du versuchst, auf
ein Element über die Indizierung zuzugreifen, wird Rust prüfen, ob der von dir
angegebene Index kleiner als die Array-Länge ist. Wenn der Index größer oder
gleich der Array-Länge ist, wird Rust das Programm abbrechen.</p>
<p>Dies ist das erste Beispiel für die Umsetzung der Sicherheitsprinzipien von
Rust. In vielen Low-Level-Sprachen wird diese Art der Überprüfung nicht
durchgeführt und wenn du einen falschen Index angibst, kann auf ungültigen
Speicher zugegriffen werden. Rust schützt dich vor dieser Art von Fehlern,
indem es das Programm sofort beendet, anstatt den Speicherzugriff zuzulassen
und fortzusetzen. In Kapitel 9 wird mehr über die Fehlerbehandlung von Rust
gesprochen.</p>
<h2><a class="header" href="#funktionen" id="funktionen">Funktionen</a></h2>
<p>Funktionen sind im Rust-Code allgegenwärtig. Du hast bereits eine der
wichtigsten Funktionen in der Sprache gesehen: Die Funktion <code>main</code>, die der
Einstiegspunkt vieler Programme ist. Du hast auch das Schlüsselwort <code>fn</code>
gesehen, mit dem du neue Funktionen deklarieren kannst.</p>
<p>Rust-Code verwendet die <em>Schlangenschrift</em>-Stil-Konvention (snake case) für
Funktions- und Variablennamen. In Schlangenschrift sind alle Buchstaben klein
geschrieben und Unterstriche separieren Wörter. Hier ist ein Programm, das eine
Beispiel-Funktionsdefinition enthält:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    println!(&quot;Hallo Welt!&quot;);

    another_function();
}

fn another_function() {
    println!(&quot;Eine andere Funktion.&quot;);
}
</code></pre></pre>
<p>Funktionsdefinitionen in Rust beginnen mit <code>fn</code> und haben einen Satz Klammern
nach dem Funktionsnamen. Die geschweiften Klammern teilen dem Kompilierer mit,
wo der Funktionsrumpf beginnt und endet.</p>
<p>Wir können jede Funktion, die wir definiert haben, aufrufen, indem wir ihren
Namen gefolgt von einem Satz Klammern eingeben. Da <code>another_function</code> im
Programm definiert ist, kann sie von innerhalb der <code>main</code>-Funktion aufgerufen
werden. Beachte, dass wir <code>another_function</code> <em>nach</em> der <code>main</code>-Funktion im
Quellcode definiert haben; wir hätten sie auch vorher definieren können. Rust
interessiert es nicht, wo du deine Funktionen definierst, nur dass sie irgendwo
definiert sind.</p>
<p>Lass uns ein neues Binärprojekt namens „functions“ anfangen, um Funktionen
weiter zu erforschen. Platziere das Beispiel <code>another_function</code> in
<em>src/main.rs</em> und lass es laufen. Du solltest die folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.28s
     Running `target/debug/functions`
Hallo Welt!
Eine andere Funktion.
</code></pre>
<p>Die Zeilen werden in der Reihenfolge ausgeführt, in der sie in der
<code>main</code>-Funktion erscheinen. Zuerst wird die Nachricht „Hallo Welt!“ ausgegeben
und dann wird <code>another_function</code> aufgerufen und ihre Nachricht ausgegeben.</p>
<h3><a class="header" href="#funktionsparameter" id="funktionsparameter">Funktionsparameter</a></h3>
<p>Funktionen können auch so definiert werden, dass sie <em>Parameter</em> haben, das
sind spezielle Variablen, die Teil der Funktionssignatur sind. Wenn eine
Funktion Parameter hat, kannst du sie mit konkreten Werten für diese Parameter
versehen. Technisch gesehen werden die konkreten Werte <em>Argumente</em> genannt,
aber in lockeren Gesprächen neigen Leute dazu, die Worte <em>Parameter</em> und
<em>Argument</em> entweder für die Variablen in der Definition einer Funktion oder für
die konkreten Werte, die beim Aufruf einer Funktion übergeben werden,
synonym zu verwenden.</p>
<p>Die folgende umgeschriebene Version von <code>another_function</code> zeigt, wie Parameter
in Rust aussehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5);
}

fn another_function(x: i32) {
    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Versuche, dieses Programm auszuführen; du solltest die folgende Ausgabe
erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 1.21s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die Deklaration <code>another_function</code> hat einen Parameter namens <code>x</code>. Der Typ von
<code>x</code> wird als <code>i32</code> angegeben. Wenn <code>5</code> an <code>another_function</code> übergeben wird,
setzt das Makro <code>println!</code> <code>5</code> an die Stelle, an der sich das Paar geschweifter
Klammern in der Formatierungszeichenkette befand.</p>
<p>In Funktionssignaturen <em>musst</em> du den Typ jedes Parameters deklarieren. Dies
ist eine bewusste Designentscheidung von Rust: Das Erfordernis von
Typ-Annotationen in Funktionsdefinitionen bedeutet, dass der Kompilierer sie
fast nie an anderer Stelle im Code benötigt, um herauszufinden, was du meinst.</p>
<p>Wenn eine Funktion mehrere Parameter haben soll, trenne die
Parameterdeklarationen mit Kommas, so wie hier:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    another_function(5, 6);
}

fn another_function(x: i32, y: i32) {
    println!(&quot;Der Wert von x ist: {}&quot;, x);
    println!(&quot;Der Wert von y ist: {}&quot;, y);
}
</code></pre></pre>
<p>Dieses Beispiel erzeugt eine Funktion mit zwei Parametern, die beide vom Typ
<code>i32</code> sind. Die Funktion gibt dann die Werte in ihren beiden Parametern aus.
Beachte, dass nicht alle Funktionsparameter vom gleichen Typ sein müssen, das
ist in diesem Beispiel nur zufällig so.</p>
<p>Lass uns versuchen, diesen Code auszuführen. Ersetze das Programm, das sich
derzeit in der Datei <em>src/main.rs</em> deines „functions“-Projekts befindet, durch
das vorhergehende Beispiel und führe es mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31s
     Running `target/debug/functions`
Der Wert von x ist: 5
Der Wert von y ist: 6
</code></pre>
<p>Da wir die Funktion mit <code>5</code> als Wert für <code>x</code> aufgerufen haben und <code>6</code> als Wert
für <code>y</code> übergeben wird, werden die beiden Zeichenketten mit diesen Werten
ausgegeben.</p>
<h4><a class="header" href="#funktionsrümpfe-enthalten-anweisungen-und-ausdrücke" id="funktionsrümpfe-enthalten-anweisungen-und-ausdrücke">Funktionsrümpfe enthalten Anweisungen und Ausdrücke</a></h4>
<p>Funktionsrümpfe bestehen aus einer Reihe von Anweisungen, die optional mit
einem Ausdruck enden können. Bisher haben wir nur Funktionen ohne einen
endenden Ausdruck behandelt, aber du hast einen Ausdruck als Teil einer
Anweisung gesehen. Da Rust eine auf Ausdrücken basierende Sprache ist, ist dies
eine wichtige Unterscheidung, die es zu verstehen gilt. Andere Sprachen haben
nicht dieselben Unterscheidungen, deshalb wollen wir uns ansehen, was
Anweisungen und Ausdrücke sind und wie sich ihre Unterschiede auf die
Funktionsrümpfe auswirken.</p>
<p>Wir haben tatsächlich bereits Anweisungen und Ausdrücke verwendet.
<em>Anweisungen</em> (statements) sind Instruktionen, die eine Aktion ausführen und
keinen Wert zurückgeben. <em>Ausdrücke</em> (expressions) werten zu einem
resultierenden Wert aus. Sehen wir uns einige Beispiele an.</p>
<p>Eine Variable zu erstellen und ihr mit dem Schlüsselwort <code>let</code> einen Wert
zuzuweisen, ist eine Anweisung. In Codeblock 3-1 ist <code>let y = 6;</code> eine
Anweisung.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let y = 6;
}
</code></pre></pre>
<p><span class="caption">Codeblock 3-1: Eine Funktionsdeklaration <code>main</code>, die eine
Anweisung enthält</span></p>
<p>Auch Funktionsdefinitionen sind Anweisungen; das gesamte vorhergehende Beispiel
ist eine Anweisung für sich.</p>
<p>Anweisungen geben keine Werte zurück. Daher kannst du keine <code>let</code>-Anweisung
einer anderen Variablen zuweisen, wie es der folgende Code versucht; du wirst
einen Fehler erhalten:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn main() {
    let x = (let y = 6);
}

</code></pre></pre>
<p>Wenn du dieses Programm ausführst, wirst du in etwa folgenden Fehler erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error: expected expression, found statement (`let`)
 --&gt; src/main.rs:2:14
  |
2 |     let x = (let y = 6);
  |              ^^^
  |
  = note: variable declaration using `let` is a statement
</code></pre>
<p>Die Anweisung <code>let y = 6</code> gibt keinen Wert zurück, also gibt es für <code>x</code> nichts,
woran <code>x</code> gebunden werden kann. Dies unterscheidet sich von dem, was in anderen
Sprachen wie C und Ruby geschieht, wo die Zuweisung den Wert der Zuweisung
zurückgibt. In diesen Sprachen kannst du <code>x = y = 6</code> schreiben und sowohl <code>x</code>
als auch <code>y</code> haben den Wert <code>6</code>; das ist in Rust nicht der Fall.</p>
<p>Ausdrücke werten zu etwas aus und machen den größten Teil des restlichen Codes
aus, den du in Rust schreiben wirst. Betrachte eine einfache mathematische
Operation, z.B. <code>5 + 6</code>, die ein Ausdruck ist, der zum Wert <code>11</code> ausgewertet
wird. Ausdrücke können Teil von Anweisungen sein: In Codeblock 3-1 ist die <code>6</code>
in der Anweisung <code>let y = 6;</code> ein Ausdruck, der den Wert <code>6</code> ergibt. Der Aufruf
einer Funktion ist ein Ausdruck. Der Aufruf eines Makros ist ein Ausdruck. Der
Block <code>{}</code>, den wir zum Erstellen neuer Gültigkeitsbereiche verwenden, ist ein
Ausdruck, zum Beispiel:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 5;

    let y = {
        let x = 3;
        x + 1
    };

    println!(&quot;Der Wert von y ist: {}&quot;, y);
}
</code></pre></pre>
<p>Der Ausdruck</p>
<pre><code class="language-rust ignore">{
    let x = 3;
    x + 1
}
</code></pre>
<p>ist ein Block, der in diesem Fall zu <code>4</code> ausgewertet wird. Dieser Wert wird als
Teil der <code>let</code>-Anweisung an <code>y</code> gebunden. Beachte die Zeile <code>x + 1</code> ohne
Semikolon am Ende, was sich von den meisten Zeilen, die du bisher gesehen hast,
unterscheidet. Ausdrücke enthalten keine abschließenden Semikolons. Wenn du ein
Semikolon an das Ende eines Ausdrucks anfügst, machst du daraus eine Anweisung,
die dann keinen Wert zurückgibt.  Behalte dies im Hinterkopf, wenn du als
nächstes die Rückgabewerte von Funktionen und Ausdrücken untersuchst.</p>
<h3><a class="header" href="#funktionen-mit-rückgabewerten" id="funktionen-mit-rückgabewerten">Funktionen mit Rückgabewerten</a></h3>
<p>Funktionen können Werte an den Code zurückgeben, der sie aufruft. Wir benennen
keine Rückgabewerte, aber wir deklarieren ihren Typ nach einem Pfeil (<code>-&gt;</code>). In
Rust ist der Rückgabewert der Funktion gleichbedeutend mit dem Wert des letzten
Ausdrucks im Block des Funktionsrumpfs. Du kannst frühzeitig von einer Funktion
zurückkehren, indem du das Schlüsselwort <code>return</code> verwendest und einen Wert
angibst, aber die meisten Funktionen geben den letzten Ausdruck implizit
zurück. Hier ist ein Beispiel für eine Funktion, die einen Wert zurückgibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn five() -&gt; i32 {
    5
}

fn main() {
    let x = five();

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}
</code></pre></pre>
<p>Es gibt keine Funktionsaufrufe, Makros oder gar <code>let</code>-Anweisungen in der
<code>five</code>-Funktion – nur die Zahl <code>5</code> selbst. Das ist eine vollkommen
gültige Funktion in Rust. Beachte, dass der Rückgabetyp der Funktion ebenfalls
angegeben ist, mit <code>-&gt; i32</code>. Versuche diesen Code auszuführen; die Ausgabe
sollte wie folgt aussehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30s
     Running `target/debug/functions`
Der Wert von x ist: 5
</code></pre>
<p>Die <code>5</code> in <code>five</code> ist der Rückgabewert der Funktion, weshalb der Rückgabetyp
<code>i32</code> ist. Lass uns dies genauer untersuchen. Es gibt zwei wichtige Teile:
Erstens zeigt die Zeile <code>let x = five();</code>, dass wir den Rückgabewert einer
Funktion verwenden, um eine Variable zu initialisieren. Da die Funktion <code>five</code>
den Wert <code>5</code> zurückgibt, ist diese Zeile die gleiche wie die folgende:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
<span class="boring">}
</span></code></pre></pre>
<p>Zweitens hat die Funktion <code>five</code> keine Parameter und definiert den Typ des
Rückgabewertes, aber der Funktionsrumpf ist eine einsame <code>5</code> ohne Semikolon,
weil es ein Ausdruck ist, dessen Wert wir zurückgeben wollen.</p>
<p>Sehen wir uns ein weiteres Beispiel an:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = plus_one(5);

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1
}
</code></pre></pre>
<p>Beim Ausführen dieses Codes wird <code>Der Wert von x ist: 6</code> ausgegeben. Wenn wir
aber ein Semikolon an das Ende der Zeile mit <code>x + 1</code> setzen und es von einem
Ausdruck in eine Anweisung ändern, erhalten wir einen Fehler.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn main() {
    let x = plus_one(5);

    println!(&quot;Der Wert von x ist: {}&quot;, x);
}

fn plus_one(x: i32) -&gt; i32 {
    x + 1;
}
</code></pre></pre>
<p>Das Kompilieren dieses Codes führt zum folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling functions v0.1.0 (file:///projects/functions)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:24
  |
7 | fn plus_one(x: i32) -&gt; i32 {
  |    --------            ^^^ expected `i32`, found `()`
  |    |
  |    implicitly returns `()` as its body has no tail or `return` expression
8 |     x + 1;
  |          - help: consider removing this semicolon

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `functions`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Hauptfehlermeldung „nicht übereinstimmende Typen“ („mismatched types“)
offenbart das Kernproblem dieses Codes. Die Definition der Funktion <code>plus_one</code>
besagt, dass sie ein <code>i32</code> zurückgibt, aber Anweisungen werden nicht zu einem
Wert ausgewertet, was durch das leere Tupel <code>()</code> ausgedrückt wird. Daher wird
nichts zurückgegeben, was der Funktionsdefinition widerspricht und zu einem
Fehler führt. In dieser Ausgabe gibt Rust eine Meldung aus, die möglicherweise
helfen kann, dieses Problem zu beheben: Es wird vorgeschlagen, das Semikolon zu
entfernen, was den Fehler beheben würde.</p>
<h2><a class="header" href="#kommentare" id="kommentare">Kommentare</a></h2>
<p>Alle Programmierer bemühen sich, ihren Code leicht verständlich zu machen, aber
manchmal sind zusätzliche Erklärungen angebracht. In solchen Fällen versehen
Entwickler den Quellcode mit <em>Kommentaren</em>, welche der Kompilierer ignoriert
und für andere Entwickler nützlich sein können.</p>
<p>Dies ist ein einfacher Kommentar:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Hallo Welt
<span class="boring">}
</span></code></pre></pre>
<p>In Rust beginnt ein gewöhnlicher Kommentar mit zwei Schrägstrichen; der
Kommentar reicht dann bis zum Ende der Zeile. Für Kommentare, die über eine
einzelne Zeile hinausgehen, musst du bei jedem Zeilenanfang <code>//</code> angeben:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>// Hier passiert etwas kompliziertes, so komplex dass wir
// mehrere Kommentarzeilen brauchen! Puh! Hoffentlich erklärt
// dieser Kommentar, was hier passiert.
<span class="boring">}
</span></code></pre></pre>
<p>Kommentare können auch am Ende einer Codezeile stehen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let lucky_number = 7; // Heute habe ich Glück
}
</code></pre></pre>
<p>Gängiger ist jedoch die Schreibweise mit dem Kommentar über der Codezeile, die
er beschreibt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Heute habe ich Glück
    let lucky_number = 7;
}
</code></pre></pre>
<p>Rust hat auch Dokumentations-Kommentare, welche im Bereich „Kisten (crate) auf
crates.io veröffentlichen“ in Kapitel 14 erklärt werden.</p>
<h1><a class="header" href="#eigentümerschaft-ownership-verstehen" id="eigentümerschaft-ownership-verstehen">Eigentümerschaft (ownership) verstehen</a></h1>
<p>Eigentümerschaft (ownership) ist das wichtigste Alleinstellungsmerkmal von
Rust, und sie ermöglicht es Rust, Speichersicherheitsgarantien ohne Einsatz
einer automatischen Speicherbereinigung (garbage collector) zu geben. Deshalb
ist es wichtig zu verstehen, wie Eigentümerschaft in Rust funktioniert. In
diesem Kapitel werden wir uns neben der Eigentümerschaft weitere diesbezügliche
Funktionalitäten ansehen: Ausleihen (borrowing), Anteilstypen (slices) und wie
Rust Daten im Speicher anordnet.</p>
<h2><a class="header" href="#was-ist-eigentümerschaft-ownership" id="was-ist-eigentümerschaft-ownership">Was ist Eigentümerschaft (ownership)?</a></h2>
<p>Die zentrale Funktionalität von Rust ist <em>Eigentümerschaft</em> (ownership). Obwohl
diese Funktionalität einfach zu erklären ist, hat sie weitgehende Auswirkungen
auf den Rest der Sprache.</p>
<p>Alle Programme müssen den Arbeitsspeicher eines Rechners verwalten, während sie
ausgeführt werden. Einige Sprachen verfügen über eine automatische
Speicherbereinigung, die während der Programmausführung ständig nach nicht mehr
genutztem Speicher sucht. Bei anderen Sprachen muss der Programmierer selbst
den Speicher explizit reservieren und freigeben. Rust verwendet einen dritten
Ansatz: Der Speicher wird durch ein System aus Eigentümerschaft und einer Reihe
von Regeln verwaltet, die der Kompilierer zur Kompilierzeit überprüft. Keine
der Eigentümerschaftsfunktionalitäten verlangsamt dein Programm, während es
läuft.</p>
<p>Da die Eigentümerschaft für viele Programmierer ein neues Konzept ist, braucht
es etwas Zeit, sich daran zu gewöhnen. Die gute Nachricht ist, je mehr
Erfahrung du mit Rust und den Regeln der Eigentümerschaft gesammelt hast, desto
mehr kannst du auf natürliche Weise Code entwickeln, der sicher und effizient
ist. Bleib dran!</p>
<p>Wenn du Eigentümerschaft verstehst, hast du eine solide Grundlage, um die
Funktionalitäten zu verstehen, die Rust einzigartig machen. In diesem Kapitel
lernst du Eigentümerschaft kennen, indem du einige Beispiele durcharbeitest,
die sich auf eine sehr verbreitete Datenstruktur konzentrieren: Zeichenketten
(strings).</p>
<blockquote>
<h3><a class="header" href="#stapelspeicher-stack-und-dynamischer-speicher-heap" id="stapelspeicher-stack-und-dynamischer-speicher-heap">Stapelspeicher (stack) und dynamischer Speicher (heap)</a></h3>
<p>In vielen Programmiersprachen musst du nicht sehr oft über Stapelspeicher und
dynamischen Speicher nachdenken. Aber in einer Systemprogrammiersprache wie
Rust hat die Frage, ob ein Wert auf dem Stapelspeicher oder im dynamischen
Speicher liegt, einen größeren Einfluss darauf, wie sich die Sprache verhält
und warum du bestimmte Entscheidungen treffen musst. Teile der
Eigentümerschaft werden später in diesem Kapitel in Bezug auf den
Stapelspeicher und den dynamischen Speicher beschrieben, daher hier eine
kurze Erklärung zur Vorbereitung.</p>
<p>Sowohl Stapelspeicher als auch dynamischer Speicher sind Teile des
Arbeitsspeichers, die deinem Code zur Laufzeit zur Verfügung stehen, aber sie
sind unterschiedlich strukturiert. Der Stapelspeicher speichert Werte in der
Reihenfolge, in der er sie erhält, und entfernt die Werte in umgekehrter
Reihenfolge. Dies wird als <em>zuletzt herein, zuerst hinaus</em> (last in, first
out) bezeichnet. Denke an einen Stapel Teller: Wenn du weitere Teller
hinzufügst, legst du sie auf den Stapel, und wenn du einen Teller benötigst,
nimmst du einen von oben. Das Hinzufügen oder Entfernen von Tellern aus der
Mitte oder von unten würde nicht so gut funktionieren! Das Hinzufügen von
Daten nennt man <em>auf den Stapel legen</em>, und das Entfernen von Daten nennt man
<em>vom Stapel nehmen</em>.</p>
<p>Alle im Stapelspeicher gespeicherten Daten müssen eine bekannte, feste Größe
haben. Daten mit einer zur Kompilierzeit unbekannten Größe oder einer Größe,
die sich ändern könnte, müssen stattdessen im dynamischen Speicher
gespeichert werden. Der dynamische Speicher ist weniger organisiert: Wenn du
Daten in den dynamischen Speicher legst, forderst du eine bestimmte Menge an
Speicherplatz an. Das Betriebssystem sucht eine leere Stelle im dynamischen
Speicher, die groß genug ist, markiert sie als in Benutzung und gibt einen
<em>Zeiger</em> (pointer) zurück, der die Adresse dieser Stelle ist. Dieser Vorgang
wird als <em>Allokieren im dynamischen Speicher</em> bezeichnet und manchmal mit
<em>Allokieren</em> abgekürzt. Das Legen von Werten auf den Stapelspeicher gilt
nicht als Allokieren. Da es sich beim Zeiger um eine bekannte, feste Größe
handelt, kannst du den Zeiger auf den Stapelspeicher legen, aber wenn du die
eigentlichen Daten benötigst, musst du dem Zeiger folgen.</p>
<p>Stell dir vor, du sitzst in einem Restaurant. Wenn du hineingehst, gibst du
die Anzahl der Personen deiner Gruppe an, und das Personal findet einen
leeren Tisch, der groß genug ist, und führt euch dorthin. Wenn jemand aus
deiner Gruppe zu spät kommt, kann er fragen, wo ihr Platz genommen habt, um
euch zu finden.</p>
<p>Das Legen auf den Stapelspeicher ist schneller als das Allokieren im
dynamischen Speicher, da das Betriebssystem nie nach Platz zum Speichern
neuer Daten suchen muss; dieser Ort ist immer ganz oben auf dem Stapel. Im
Vergleich dazu erfordert das Allokieren von Speicherplatz im dynamischen
Speicher mehr Arbeit, da das Betriebssystem zunächst einen ausreichend großen
Platz für die Daten finden und dann Buch führen muss, um die nächste
Allokation vorzubereiten.</p>
<p>Der Zugriff auf Daten im dynamischen Speicher ist langsamer als der Zugriff
auf Daten auf dem Stapelspeicher, da du einem Zeiger folgen musst, um dorthin
zu gelangen. Heutige Prozessoren sind schneller, wenn sie weniger im Speicher
herumspringen. Um die Analogie fortzusetzen, betrachte einen Kellner in einem
Restaurant, der an vielen Tischen Bestellungen aufnimmt. Es ist am
effizientesten, alle Bestellungen an einem Tisch aufzunehmen, bevor man zum
nächsten Tisch weitergeht. Eine Bestellung von Tisch A, dann eine Bestellung
von Tisch B, dann wieder eine von A und dann wieder eine von B aufzunehmen,
wäre ein viel langsamerer Vorgang. Umgekehrt kann ein Prozessor seine Arbeit
besser erledigen, wenn er mit Daten arbeitet, die nahe beieinander liegen
(wie sie auf dem Stapelspeicher liegen) und nicht weiter voneinander entfernt
(wie sie im dynamischen Speicher liegen können). Das Allokieren einer großen
Menge an Platz im dynamischen Speicher kann ebenfalls Zeit in Anspruch
nehmen.</p>
<p>Wenn dein Code eine Funktion aufruft, werden die an die Funktion übergebenen
Werte (einschließlich potentieller Zeiger auf Daten im dynamischen Speicher)
und die lokalen Variablen der Funktion auf den Stapelspeicher gelegt. Wenn
die Funktion beendet ist, werden diese Werte vom Stapelspeicher genommen.</p>
<p>Das Nachverfolgen, welche Codeteile welche Daten im dynamischen Speicher
verwenden, das Minimieren der Menge an doppelten Daten im dynamischen
Speicher und das Aufräumen ungenutzter Daten im dynamischen Speicher, damit
dir der Speicherplatz nicht ausgeht, sind alles Probleme, die durch
Eigentümerschaft gelöst werden. Wenn du Eigentümerschaft einmal verstanden
hast, brauchst du nicht mehr so oft über Stapelspeicher und dynamischen
Speicher nachzudenken. Aber zu wissen, dass die Verwaltung von dynamischen
Speicherdaten der Grund für Eigentümerschaft ist, kann helfen zu erklären,
warum es so funktioniert, wie es funktioniert.</p>
</blockquote>
<h3><a class="header" href="#eigentumsregeln" id="eigentumsregeln">Eigentumsregeln</a></h3>
<p>Lass uns zunächst einen Blick auf die Eigentumsregeln (ownership rules) werfen.
Behalte diese Regeln im Hinterkopf, während wir veranschaulichende Beispiele
durcharbeiten:</p>
<ul>
<li>Jeder Wert in Rust hat eine Variable, die als sein <em>Eigentümer</em> bezeichnet
wird.</li>
<li>Es kann immer nur einen Eigentümer zur gleichen Zeit geben.</li>
<li>Wenn der Eigentümer den Gültigkeitsbereich verlässt, wird der Wert gelöscht.</li>
</ul>
<h3><a class="header" href="#gültigkeitsbereich-scope-einer-variable" id="gültigkeitsbereich-scope-einer-variable">Gültigkeitsbereich (scope) einer Variable</a></h3>
<p>Wir sind bereits in Kapitel 2 ein Beispiel für ein Rust-Programm durchgegangen.
Da wir nun über die grundlegende Syntax hinausgehen, werden wir nicht mehr den
gesamten <code>fn main() {</code>-Code in die Beispiele aufnehmen. Wenn du also
weitermachst, musst du die folgenden Beispiele manuell in eine Funktion <code>main</code>
einfügen. Folglich werden unsere Beispiele etwas prägnanter sein, damit wir uns
auf die eigentlichen Details konzentrieren können, anstatt auch den Code darum
herum betrachten zu müssen.</p>
<p>Als erstes Beispiel zu Eigentümerschaft werden wir uns den <em>Gültigkeitsbereich</em>
(scope) einiger Variablen ansehen. Der Gültigkeitsbereich ist der Bereich
innerhalb eines Programms, in dem ein Element gültig ist. Nehmen wir an, wir
haben eine Variable, die so aussieht:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Die Variable <code>s</code> bezieht sich auf ein Zeichenkettenliteral, wobei der Wert der
Zeichenkette fest in den Text unseres Programms kodiert ist. Die Variable ist
ab der Stelle, an der sie deklariert wurde, bis zum Ende des aktuellen
<em>Gültigkeitsbereichs</em> gültig. Codeblock 4-1 enthält Kommentare mit Anmerkungen,
wo die Variable <code>s</code> gültig ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{                      // s ist hier nicht gültig, es wurde noch nicht deklariert
    let s = &quot;Hallo&quot;;   // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                      // dieser Gültigkeitsbereich ist nun vorbei,
                       // und s ist nicht mehr gültig
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-1: Eine Variable und der Bereich, in dem sie
gültig ist</span></p>
<p>Mit anderen Worten, es gibt hier zwei wichtige Zeitpunkte:</p>
<ul>
<li>Wenn <code>s</code> <em>in den Gültigkeitsbereich</em> kommt, ist es gültig.</li>
<li>Es bleibt gültig, bis es <em>den Gültigkeitsbereich</em> verlässt.</li>
</ul>
<p>An diesem Punkt ist die Beziehung zwischen Gültigkeitsbereichen und wann
Variablen gültig sind ähnlich zu anderen Programmiersprachen. Nun werden wir
auf diesem Verständnis aufbauen, indem wir den Typ <code>String</code> einführen.</p>
<h3><a class="header" href="#der-typ-string" id="der-typ-string">Der Typ <code>String</code></a></h3>
<p>Um die Eigentumsregeln zu veranschaulichen, benötigen wir einen Datentyp, der
komplexer ist als die, die wir im Abschnitt <a href="ch03-02-data-types.html#data-types">&quot;Datentypen&quot;</a> in
Kapitel 3 behandelt haben. Die zuvor behandelten Typen werden alle auf den
Stapelspeicher gelegt und vom Stapelspeicher entfernt, wenn ihr
Gültigkeitsbereich beendet ist, aber wir wollen uns Daten ansehen, die im
dynamischen Speicher gespeichert sind, und untersuchen, woher Rust weiß, wann
es diese Daten aufräumen muss.</p>
<p>Wir werden hier <code>String</code> als Beispiel nehmen und uns auf die Teile von <code>String</code>
konzentrieren, die sich auf die Eigentümerschaft beziehen. Diese Aspekte gelten
auch für andere komplexe Datentypen, unabhängig davon, ob sie von der
Standardbibliothek bereitgestellt oder von dir erstellt wurden. Wir werden
<code>String</code> in Kapitel 8 eingehender behandeln.</p>
<p>Wir haben bereits Zeichenkettenliterale gesehen, bei denen ein
Zeichenkettenwert fest in unserem Programm kodiert ist. Zeichenkettenliterale
sind praktisch, aber sie eignen sich nicht für jede Situation, in der wir Text
verwenden möchten. Ein Grund dafür ist, dass sie unveränderlich sind. Ein
anderer Grund ist, dass nicht jeder Zeichenkettenwert bekannt ist, wenn wir
unseren Code schreiben: Was ist zum Beispiel, wenn wir Benutzereingaben
entgegennehmen und speichern wollen? Für diese Situationen hat Rust einen
zweiten Zeichenkettentyp: <code>String</code>. Dieser Typ wird im dynamischen Speicher
allokiert und kann so eine Textmenge speichern, die uns zur Kompilierzeit
unbekannt ist. Du kannst einen <code>String</code> aus einem Zeichenkettenliteral
erzeugen, indem du die Funktion <code>from</code> wie folgt verwendest:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Der doppelte Doppelpunkt (<code>::</code>) ist ein Operator, der es uns erlaubt, diese
spezielle Funktion <code>from</code> mit dem Namensraum des <code>String</code>-Typs zu benennen,
anstatt einen Namen wie <code>string_from</code> zu verwenden. Wir werden diese Syntax im
Abschnitt <a href="ch05-03-method-syntax.html#method-syntax">„Methodensyntax“</a> in Kapitel 5 näher betrachten, und
wenn wir in Kapitel 7 unter <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit Pfaden auf ein Element im Modulbaum
verweisen“</a> über den Namensraum mit Modulen sprechen. </p>
<p>Diese Art von Zeichenkette kann <em>verändert</em> werden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

s.push_str(&quot; Welt!&quot;); // push_str() hängt ein Literal an eine Zeichenfolge an

println!(&quot;{}&quot;, s);    // Gibt `Hallo Welt!` aus
<span class="boring">}
</span></code></pre></pre>
<p>Was ist hier nun der Unterschied? Warum kann <code>String</code> verändert werden,
Literale jedoch nicht? Der Unterschied liegt darin, wie diese beiden Typen mit
dem Arbeitsspeicher umgehen.</p>
<h3><a class="header" href="#speicher-und-allokation" id="speicher-und-allokation">Speicher und Allokation</a></h3>
<p>Im Falle eines Zeichenkettenliterals kennen wir den Inhalt zum Zeitpunkt der
Kompilierung, sodass der Text direkt in die endgültige ausführbare Datei fest
kodiert wird. Aus diesem Grund sind Zeichenkettenliterale schnell und
effizient. Allerdings ergeben sich diese Eigenschaften nur aus der
Unveränderlichkeit des Zeichenkettenliterals. Leider können wir nicht für jedes
Stück Text, dessen Größe zum Zeitpunkt der Kompilierung unbekannt ist und
dessen Größe sich während der Ausführung des Programms ändern könnte, einen
Speicherblock in die Binärdatei packen.</p>
<p>Um mit dem Typ <code>String</code> einen veränderlichen, größenänderbaren Textabschnitt zu
unterstützen, müssen wir Speicher im dynamischen Speicher allokieren, dessen
Größe zur Kompilierzeit unbekannt ist. Dies bedeutet:</p>
<ul>
<li>Der Speicher muss zur Laufzeit vom Betriebssystem angefordert werden.</li>
<li>Wir brauchen eine Möglichkeit, diesen Speicher an das Betriebssystem
zurückzugeben, wenn wir mit unserem <code>String</code> fertig sind.</li>
</ul>
<p>Der erste Teil wird von uns erledigt: Wenn wir <code>String::from</code> aufrufen, fordert
seine Implementierung den Speicher an, den sie benötigt. Dies ist in
Programmiersprachen ziemlich einheitlich.</p>
<p>Der zweite Teil ist jedoch anders. In Sprachen mit einer <em>automatischen
Speicherbereinigung</em> (garbage collector, GC) behält der GC den Überblick und
räumt Speicherplatz, der nicht mehr verwendet wird, auf; wir brauchen nicht
darüber nachzudenken. Ohne einen GC liegt es in unserer Verantwortung, zu
erkennen, wann Speicherplatz nicht mehr benutzt wird, und Code aufzurufen, der
ihn explizit zurückgibt, so wie wir es beim Anfordern auch getan haben. Dies
korrekt zu tun, war in der Vergangenheit ein schwieriges Programmierproblem.
Wenn wir es vergessen, verschwenden wir Speicher. Wenn wir es zu früh machen,
haben wir eine ungültige Variable. Wenn wir es zweimal machen, ist das auch ein
Fehler. Wir müssen eine <em>Allokierung</em> mit genau einer <em>Freigabe</em> paaren.</p>
<p>Rust geht einen anderen Weg: Der Speicher wird automatisch zurückgegeben,
sobald die Variable, die ihn besitzt, den Gültigkeitsbereich verlässt. Hier ist
eine Variante unseres Gültigkeitsbereich-Beispiels aus Codeblock 4-1, bei der
ein <code>String</code> anstelle eines Zeichenkettenliterals verwendet wird:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let s = String::from(&quot;Hallo&quot;); // s ist ab dieser Stelle gültig

    // etwas mit s machen
}                                  // dieser Gültigkeitsbereich ist nun vorbei,
                                   // und s ist nicht mehr gültig
<span class="boring">}
</span></code></pre></pre>
<p>Es gibt eine natürliche Stelle, an der wir den Speicher, den unser <code>String</code>
benötigt, an das Betriebssystem zurückgeben können: Wenn <code>s</code> den
Gültigkeitsbereich verlässt. Wenn eine Variable den Gültigkeitsbereich
verlässt, ruft Rust für uns eine spezielle Funktion auf: Diese Funktion heißt
<code>drop</code> und an dieser Stelle kann der Autor von <code>String</code> Code einfügen, um den
Speicher zurückzugeben. Rust ruft <code>drop</code> automatisch an der schließenden
geschweiften Klammer auf.</p>
<blockquote>
<p>Hinweis: In C++ wird dieses Muster der Freigabe von Ressourcen am Ende der
Lebensdauer eines Elements manchmal als <em>Ressourcenbelegung ist
Initialisierung</em> (resource acquisition is initialization, RAII) bezeichnet.
Die Funktion <code>drop</code> in Rust wird dir vertraut vorkommen, wenn du bereits
RAII-Muster verwendet hast.</p>
</blockquote>
<p>Dieses Muster hat einen tiefgreifenden Einfluss auf die Art und Weise, wie
Rust-Code geschrieben wird. Es mag im Moment einfach erscheinen, aber das
Verhalten von Code kann in komplizierteren Situationen unerwartet sein, wenn
wir wollen, dass mehrere Variablen Daten verwenden, die wir im dynamischen
Speicher allokiert haben. Lass uns jetzt einige dieser Situationen untersuchen.</p>
<h4><a class="header" href="#wege-wie-variablen-und-daten-interagieren-verschieben-move" id="wege-wie-variablen-und-daten-interagieren-verschieben-move">Wege, wie Variablen und Daten interagieren: Verschieben (move)</a></h4>
<p>Mehrere Variablen können in Rust auf unterschiedliche Weise mit denselben Daten
interagieren. Betrachten wir ein Beispiel mit einer ganzen Zahl in Codeblock
4-2.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-2: Zuweisen des ganzzahligen Wertes der
Variablen <code>x</code> an <code>y</code></span></p>
<p>Wir können wahrscheinlich erahnen, was das bewirkt: „Binde den Wert <code>5</code> an <code>x</code>;
dann erstelle eine Kopie des Wertes in <code>x</code> und binde ihn an <code>y</code>.“ Wir haben
jetzt zwei Variablen <code>x</code> und <code>y</code> und beide sind gleich <code>5</code>. Das ist in der Tat
der Fall, denn ganze Zahlen sind einfache Werte mit einer bekannten, festen
Größe, und diese beiden Werte <code>5</code> werden auf den Stapelspeicher gelegt.</p>
<p>Schauen wir uns nun die <code>String</code>-Variante an:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;
<span class="boring">}
</span></code></pre></pre>
<p>Dieser sieht dem vorherigen Code sehr ähnlich, sodass wir annehmen könnten,
dass die Funktionsweise die gleiche wäre: Das heißt, die zweite Zeile würde
eine Kopie des Wertes in <code>s1</code> erstellen und sie an <code>s2</code> binden. Aber das ist
nicht ganz das, was passiert.</p>
<p>Betrachte Abbildung 4-1, um zu sehen, was mit dem <code>String</code> unter der Haube
geschieht. Ein <code>String</code> besteht aus drei Teilen, die auf der linken Seite
dargestellt sind: Einem Zeiger auf den Speicherbereich, der den Inhalt der
Zeichenkette enthält, die Länge und die Kapazität. Dieser Datenblock wird auf
dem Stapelspeicher gespeichert. Auf der rechten Seite ist der Speicherbereich
im dynamischen Speicher, der den Inhalt enthält.</p>
<img alt="String im Arbeitsspeicher" src="img/trpl04-01.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-1: Speicherdarstellung eines <code>String</code> mit dem
Wert „Hallo“, gebunden an <code>s1</code></span></p>
<p>Die Länge gibt an, wie viel Speicherplatz in Bytes der Inhalt der Zeichenkette
derzeit belegt. Die Kapazität ist die Gesamtmenge des Speichers in Bytes, die
der <code>String</code> vom Betriebssystem erhalten hat. Der Unterschied zwischen Länge
und Kapazität ist von Bedeutung, aber nicht in diesem Zusammenhang, deshalb ist
es im Moment in Ordnung, die Kapazität zu ignorieren.</p>
<p>Wenn wir <code>s1</code> an <code>s2</code> zuweisen, werden die <code>String</code>-Daten kopiert, d.h. wir
kopieren den Zeiger, die Länge und die Kapazität, die sich auf dem
Stapelspeicher befinden. Wir kopieren nicht die Daten im dynamischen Speicher,
auf die sich der Zeiger bezieht. Die Speicherdarstellung sieht also wie in
Abbildung 4-2 aus.</p>
<img alt="s1 und s2 zeigen auf denselben Wert" src="img/trpl04-02.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-2: Speicherdarstellung der Variable <code>s2</code>, die
eine Kopie des Zeigers, der Länge und der Kapazität von <code>s1</code> hat</span></p>
<p>Die Darstellung sieht <em>nicht</em> wie Abbildung 4-3 aus, so wie der Speicher
aussehen würde, wenn Rust stattdessen auch die Daten im dynamischen Speicher
kopieren würde. Würde Rust dies tun, könnte die Operation <code>s2 = s1</code> bei großen
Datenmengen im dynamischen Speicher sehr teuer hinsichtlich der
Laufzeitperformanz werden.</p>
<img alt="s1 und s2 als vollständige Kopien" src="img/trpl04-03.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-3: Eine weitere Möglichkeit für das, was
<code>s2 = s1</code> tun könnte, falls Rust auch die Daten im dynamischen Speicher
kopieren würde</span></p>
<p>Vorhin sagten wir, dass Rust automatisch die Funktion <code>drop</code> aufruft und den
dynamischen Speicher für diese Variable säubert, wenn eine Variable den
Gültigkeitsbereich verlässt. Abbildung 4-2 zeigt jedoch, dass beide Datenzeiger
auf dieselbe Stelle zeigen. Das ist ein Problem: Wenn <code>s2</code> und <code>s1</code> den
Gültigkeitsbereich verlassen, werden beide versuchen, den gleichen Speicher
freizugeben.</p>
<p>Dies wird als <em>doppelter Freigabefehler</em> (double free error) bezeichnet und ist
einer der Speichersicherheitsfehler, die wir zuvor erwähnt haben. Das
zweimalige Freigeben des Speichers kann zu einer Speicherverfälschung führen,
was potenziell zu Sicherheitslücken führen kann.</p>
<p>Um Speichersicherheit zu gewährleisten, gibt es noch ein weiteres Detail, was
Rust in dieser Situation macht. Anstatt zu versuchen, den allokierten Speicher
zu kopieren, sieht Rust <code>s1</code> als nicht mehr gültig an, und deshalb muss Rust
nichts freigeben, wenn <code>s1</code> den Gültigkeitsbereich verlässt. Schau dir an, was
passiert, wenn du versuchst, <code>s1</code> zu benutzen, nachdem <code>s2</code> erstellt wurde; es
wird nicht funktionieren:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1;

println!(&quot;{} Welt!&quot;, s1);
<span class="boring">}
</span></code></pre></pre>
<p>Du erhältst eine Fehlermeldung wie diese, wodurch Rust dich daran hindert, die
ungültige Referenz zu verwenden:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0382]: borrow of moved value: `s1`
 --&gt; src/main.rs:5:28
  |
2 |     let s1 = String::from(&quot;Hallo&quot;);
  |         -- move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
3 |     let s2 = s1;
  |              -- value moved here
4 | 
5 |     println!(&quot;{} Welt!&quot;, s1);
  |                          ^^ value borrowed here after move

error: aborting due to previous error

For more information about this error, try `rustc --explain E0382`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Wenn du beim Arbeiten mit anderen Sprachen schon mal die Begriffe <em>flache
Kopie</em> (shallow copy) und <em>tiefe Kopie</em> (deep copy) gehört hast, hört sich das
Konzept des Kopierens des Zeigers, der Länge und der Kapazität ohne Kopieren
der Daten nach einer flachen Kopie an. Aber weil Rust auch die erste Variable
ungültig macht, wird es nicht als flache Kopie, sondern als <em>Verschieben</em>
(move) bezeichnet. In diesem Beispiel würden wir sagen, dass <code>s1</code> in <code>s2</code>
<em>verschoben</em> wurde. Was tatsächlich geschieht, ist in Abbildung 4-4
dargestellt.</p>
<img alt="s1 moved to s2" src="img/trpl04-04.svg" class="center" style="width: 50%;" />
<p><span class="caption">Abbildung 4-4: Speicherdarstellung, nachdem <code>s1</code> ungültig
gemacht wurde</span></p>
<p>Damit ist unser Problem gelöst! Da nur <code>s2</code> gültig ist, wenn es den
Gültigkeitsbereich verlässt, wird es allein den Speicher freigeben, und wir
sind fertig.</p>
<p>Darüber hinaus gibt es eine Entwurfsentscheidung, die damit impliziert ist:
Rust wird niemals automatisch „tiefe“ Kopien deiner Daten erstellen. Daher kann
man davon ausgehen, dass jedes <em>automatische</em> Kopieren im Hinblick auf die
Laufzeitperformanz kostengünstig ist.</p>
<h4><a class="header" href="#wege-wie-variablen-und-daten-interagieren-klonen-clone" id="wege-wie-variablen-und-daten-interagieren-klonen-clone">Wege, wie Variablen und Daten interagieren: Klonen (clone)</a></h4>
<p>Wenn wir die Daten von <code>String</code> im dynamischen Speicher <em>tief</em> kopieren wollen,
nicht nur die Stapelspeicher-Daten, können wir eine gängige Methode namens
<code>clone</code> verwenden. Wir werden die Methodensyntax in Kapitel 5 besprechen, aber
da Methoden eine gängige Funktionalität vieler Programmiersprachen sind, hast
du sie wahrscheinlich schon einmal gesehen.</p>
<p>Hier ist ein Beispiel für die Methode <code>clone</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let s2 = s1.clone();

println!(&quot;s1 = {}, s2 = {}&quot;, s1, s2);
<span class="boring">}
</span></code></pre></pre>
<p>Das funktioniert sehr gut und erzeugt explizit das in Abbildung 4-3 gezeigte
Verhalten, bei dem die Daten im dynamischen Speicher <em>kopiert</em> werden.</p>
<p>Wenn du einen Aufruf von <code>clone</code> siehst, weißt du, dass irgendein beliebiger
Code ausgeführt wird und dass dieser Code teuer sein könnte. Es ist ein
visueller Indikator dafür, dass etwas anderes vor sich geht.</p>
<h4><a class="header" href="#nur-stapelspeicher-daten-kopieren-copy" id="nur-stapelspeicher-daten-kopieren-copy">Nur Stapelspeicher-Daten: Kopieren (copy)</a></h4>
<p>Es gibt noch einen weiteren Kniff, über den wir noch nicht gesprochen haben.
Folgender Code mit ganzen Zahlen, der teilweise in Codeblock 4-2 gezeigt wurde,
funktioniert und ist gültig:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x = 5;
let y = x;

println!(&quot;x = {}, y = {}&quot;, x, y);
<span class="boring">}
</span></code></pre></pre>
<p>Aber dieser Code scheint dem zu widersprechen, was wir gerade gelernt haben:
Wir haben keinen Aufruf von <code>clone</code>, aber <code>x</code> ist immer noch gültig und wurde
nicht in <code>y</code> verschoben.</p>
<p>Der Grund dafür ist, dass Typen wie ganze Zahlen, die zur Kompilierzeit eine
bekannte Größe haben, vollständig auf dem Stack gespeichert werden, so dass
Kopien der tatsächlichen Werte schnell erstellt werden können. Das bedeutet,
dass es keinen Grund gibt, warum wir verhindern wollen, dass <code>x</code> gültig ist,
nachdem wir die Variable <code>y</code> erstellt haben. Mit anderen Worten, es gibt hier
keinen Unterschied zwischen tiefen und flachen Kopien, also würde der Aufruf
<code>clone</code> nichts anderes tun als das übliche flache Kopieren, und wir können es
weglassen.</p>
<p>Rust hat eine spezielle Annotation, das Merkmal <code>Copy</code>, die wir an Typen wie
ganze Zahlen hängen können, die auf dem Stapelspeicher gespeichert sind (wir
werden in Kapitel 10 mehr über Merkmale sprechen). Wenn ein Typ das Merkmal
<code>Copy</code> hat, ist eine ältere Variable nach der Zuweisung noch verwendbar. Rust
lässt uns einen Typ nicht mit dem Merkmal <code>Copy</code> annotieren, wenn der Typ oder
einer seiner Teile das Merkmal <code>Drop</code> implementiert. Wenn der Typ eine
Sonderbehandlung braucht, wenn der Wert den Gültigkeitsbereich verlässt und wir
die Annotation <code>Copy</code> zu diesem Typ hinzufügen, erhalten wir einen
Kompilierfehler. Um zu erfahren, wie du die <code>Copy</code>-Annotation zu deinem Typ
hinzufügen kannst, siehe <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale (traits)“</a> in
Anhang C.</p>
<p>Welche Typen unterstützen also <code>Copy</code>? Du kannst die Dokumentation für einen
gegebenen Typ überprüfen, um sicherzugehen, aber als allgemeine Regel gilt,
dass jede Gruppierung von einfachen skalaren Werten <code>Copy</code> unterstützt, und
nichts, was eine Allokation erfordert oder irgendeine Form von Ressource ist,
<code>Copy</code> erlaubt. Hier sind einige Typen, die <code>Copy</code> unterstützen:</p>
<ul>
<li>Alle ganzzahligen Typen, z.B. <code>u32</code>.</li>
<li>Der boolesche Typ <code>bool</code> mit den Werten <code>true</code> und <code>false</code>.</li>
<li>Alle Fließkomma-Typen, z.B. <code>f64</code>.</li>
<li>Der Zeichentyp <code>char</code>.</li>
<li>Tupel, wenn sie nur Typen enthalten, die auch <code>Copy</code> unterstützen. Zum
Beispiel unterstützt <code>(i32, i32)</code> <code>Copy</code>, nicht aber <code>(i32, String)</code>.</li>
</ul>
<h3><a class="header" href="#eigentümerschaft-und-funktionen" id="eigentümerschaft-und-funktionen">Eigentümerschaft und Funktionen</a></h3>
<p>Die Semantik für die Übergabe eines Wertes an eine Funktion ist ähnlich wie bei
der Zuweisung eines Wertes an eine Variable. Wenn eine Variable an eine
Funktion übergeben wird, wird sie verschoben oder kopiert, genau wie bei der
Zuweisung. Codeblock 4-3 enthält ein Beispiel mit einigen Anmerkungen, aus
denen hervorgeht, wo Variablen in den Gültigkeitsbereich fallen und wo nicht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s = String::from(&quot;Hallo&quot;);  // s kommt in den Gültigkeitsbereich

    takes_ownership(s);             // Der Wert von s wird in die Funktion verschoben,
                                    // und ist daher hier nicht mehr gültig.

    let x = 5;                      // x kommt in den Gültigkeitsbereich

    makes_copy(x);                  // x würde in die Funktion verschoben werden,
                                    // aber i32 erlaubt Copy, also ist es in Ordnung,
                                    // danach immer noch x zu verwenden,

} // Hier verlässt x den Gültigkeitsbereich, dann s.
  // Aber weil der Wert von s verschoben wurde, passiert nichts Besonderes.

fn takes_ownership(some_string: String) { // some_string kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_string);
} // Hier verlässt some_string den Gültigkeitsbereich und `drop` wird aufgerufen.
  // Der zugehörige Speicherplatz wird freigegeben.

fn makes_copy(some_integer: i32) { // some_integer kommt in den Gültigkeitsbereich
    println!(&quot;{}&quot;, some_integer);
} // Hier verlässt some_integer den Gültigkeitsbereich. Es passiert nichts Besonderes.
</code></pre></pre>
<p><span class="caption">Codeblock 4-3: Funktionen mit kommentierter
Eigentümerschaft und Gültigkeitsbereich</span></p>
<p>Wenn wir versuchen würden, <code>s</code> nach dem Aufruf von <code>takes_ownership</code> zu
verwenden, würde Rust einen Kompilierfehler anzeigen. Diese statischen
Prüfungen schützen uns vor Fehlern. Versuche, weiteren Code zu <code>main</code>
hinzuzufügen, der <code>s</code> und <code>x</code> verwendet, um zu sehen, wo du sie verwenden
kannst und wo die Eigentumsregeln dich daran hindern.</p>
<h3><a class="header" href="#rückgabewerte-und-gültigkeitsbereich" id="rückgabewerte-und-gültigkeitsbereich">Rückgabewerte und Gültigkeitsbereich</a></h3>
<p>Rückgabewerte können auch Eigentümerschaft übertragen. Codeblock 4-4 ist ein
Beispiel mit ähnlichen Anmerkungen wie die in Codeblock 4-3.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = gives_ownership();         // gives_ownership verschiebt seinen
                                        // Rückgabewert in s1

    let s2 = String::from(&quot;Hallo&quot;);     // s2 kommt in den Gültigkeitsbereich

    let s3 = takes_and_gives_back(s2);  // s2 wird in takes_and_gives_back verschoben
                                        // und der Rückgabewert wird in s3 verschoben

} // Hier verlässt s3 den Gültigkeitsbereich und wird aufgeräumt.
  // s2 verlässt den Gültigkeitsbereich, wurde aber verschoben, es passiert also nichts.
  // s1 verlässt den Gültigkeitsbereich und wird aufgeräumt.

fn gives_ownership() -&gt; String {        // gives_ownership verschiebt seinen
                                        // Rückgabewert in die aufrufende Funktion

    let some_string = String::from(&quot;Hallo&quot;); // some_string kommt in den
                                             // Gültigkeitsbereich

    some_string                         // some_string wird zurückgegeben und
                                        // wird an die aufrufende Funktion verschoben
}

// takes_and_gives_back nimmt einen String entgegen und gibt einen zurück
fn takes_and_gives_back(a_string: String) -&gt; String { // a_string kommt in den
                                                      // Gültigkeitsbereich

    a_string  // a_string wird zurückgegeben und
              // an die aufrufende Funktion verschoben
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-4: Übertragen der Eigentümerschaft an Rückgabewerten</span></p>
<p>Die Eigentümerschaft an einer Variable folgt jedes Mal dem gleichen Muster: Das
Zuweisen eines Wertes an eine andere Variable verschiebt diese. Wenn eine
Variable, die Daten im dynamischen Speicher enthält, den Gültigkeitsbereich
verlässt, wird der Wert durch <code>drop</code> aufgeräumt, es sei denn, die Daten wurden
in das Eigentum einer anderen Variable verschoben.</p>
<p>Es ist etwas mühsam, das Eigentum zu übernehmen und es dann mit jeder Funktion
zurückzugeben. Was ist, wenn wir eine Funktion einen Wert nutzen lassen wollen,
aber nicht die Eigentümerschaft übergeben wollen? Es ist ziemlich lästig, dass
alles, was wir übergeben, auch wieder zurückgegeben werden muss, wenn wir es
wieder verwenden wollen, zusätzlich zu den Daten, die sich aus dem
Funktionsrumpf ergeben, die wir vielleicht auch zurückgeben wollen.</p>
<p>Es ist möglich, mehrere Werte mit Hilfe eines Tupels zurückzugeben, wie in
Codeblock 4-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let (s2, len) = calculate_length(s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s2, len);
}

fn calculate_length(s: String) -&gt; (String, usize) {
    let length = s.len(); // len() gibt die Länge der Zeichenkette zurück

    (s, length)
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-5: Rückgeben der Eigentümerschaft an
Parametern</span></p>
<p>Aber das ist zu viel Zeremonie und zu viel Arbeit für ein Konzept, das
gebräuchlich sein sollte. Zum Glück hat Rust für uns eine Funktionalität zu
diesem Konzept, das <em>Referenzen</em> (references) genannt wird.</p>
<h2><a class="header" href="#referenzen-und-ausleihen-borrowing" id="referenzen-und-ausleihen-borrowing">Referenzen und Ausleihen (borrowing)</a></h2>
<p>Das Problem mit dem Tupelcode in Codeblock 4-5 ist, dass wir der aufrufenden
Funktion den <code>String</code> zurückgeben müssen, damit wir den <code>String</code> nach dem
Aufruf von <code>calculate_length</code> weiter verwenden können, weil der <code>String</code> in
<code>calculate_length</code> verschoben wurde.</p>
<p>Im Folgenden siehst du, wie du eine Funktion <code>calculate_length</code> definieren und
verwenden kannst, die eine Referenz auf ein Objekt als Parameter hat, anstatt
die Eigentümerschaft (ownership) des Wertes zu übernehmen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);

    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
}

fn calculate_length(s: &amp;String) -&gt; usize {
    s.len()
}
</code></pre></pre>
<p>Beachte, dass der gesamte Tupelcode aus der Variablendeklaration und dem
Rückgabewert der Funktion verschwunden ist. Beachte des Weiteren, dass wir
<code>&amp;s1</code> an <code>calculate_length</code> übergeben und in seiner Definition <code>&amp;String</code> statt
<code>String</code> steht.</p>
<p>Das <code>&amp;</code>-Zeichen steht für eine <em>Referenz</em>, und sie ermöglicht es dir, sich auf
einen Wert zu beziehen, ohne dessen Eigentümerschaft zu übernehmen. Abbildung
4-5 zeigt die Speicherdarstellung.</p>
<img alt="&String s zeigt auf String s1" src="img/trpl04-05.svg" class="center" />
<p><span class="caption">Abbildung 4-5: Eine Grafik mit <code>&amp;String s</code>, das auf
<code>String s1</code> zeigt</span></p>
<blockquote>
<p>Anmerkung: Das Gegenteil der Referenzierung durch <code>&amp;</code> ist die
<em>Dereferenzierung</em> (dereferencing), die mittels Dereferenzoperator <code>*</code>
erfolgt. Wir werden in Kapitel 8 einige Verwendungen des Dereferenzoperators
sehen und in Kapitel 15 Einzelheiten der Dereferenzierung besprechen.</p>
</blockquote>
<p>Schauen wir uns den Funktionsaufruf hier genauer an:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span>    let s1 = String::from(&quot;Hallo&quot;);

    let len = calculate_length(&amp;s1);
<span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn calculate_length(s: &amp;String) -&gt; usize {
</span><span class="boring">    s.len()
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Syntax <code>&amp;s1</code> erlaubt es uns, eine Referenz zu erstellen, die auf den Wert
von <code>s1</code> <em>referenziert</em>, ihn aber nicht besitzt. Da sie diese nicht besitzt,
verfällt der Wert, auf den sie verweist, nicht, wenn die Referenz den
Gültigkeitsbereich verlässt.</p>
<p>Ebenso verwendet die Signatur der Funktion das Zeichen <code>&amp;</code>, um anzuzeigen, dass
der Typ des Parameters <code>s</code> eine Referenz ist. Lass uns einige erklärende
Anmerkungen ergänzen:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let s1 = String::from(&quot;Hallo&quot;);
</span><span class="boring">
</span><span class="boring">    let len = calculate_length(&amp;s1);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Die Länge von '{}' ist {}.&quot;, s1, len);
</span><span class="boring">}
</span><span class="boring">
</span>fn calculate_length(s: &amp;String) -&gt; usize { // s ist eine Referenz
                                           // auf eine Zeichenkette
    s.len()
} // Hier verlässt s den Gültigkeitsbereich. Aber weil es keine
  // Eigentümerschaft an dem hat, worauf es referenziert, passiert nichts.
</code></pre></pre>
<p>Der Gültigkeitsbereich, in dem die Variable <code>s</code> gültig ist, ist derselbe wie
der Gültigkeitsbereich aller Funktionsparameter, aber wir lassen nicht
verfallen, worauf die Referenz verweist, wenn sie den Gültigkeitsbereich
verlässt, weil wir keine Eigentümerschaft haben. Wenn Funktionen statt der
tatsächlichen Werte Referenzen als Parameter haben, brauchen wir die Werte
nicht zurückzugeben, um die Eigentümerschaft zurückzugeben, denn wir hatten nie
die Eigentümerschaft.</p>
<p>Referenzen als Funktionsparameter bezeichnen wir als <em>Ausleihen</em> (borrowing).
Wenn eine Person im richtigen Leben etwas besitzt, kannst du es von ihr
ausleihen. Wenn du fertig bist, musst du es zurückgeben.</p>
<p>Was passiert nun, wenn wir versuchen, etwas zu verändern, das wir uns
ausleihen? Versuche den Code in Codeblock 4-6. Achtung: Es funktioniert nicht!</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn main() {
    let s = String::from(&quot;Hallo&quot;);

    change(&amp;s);
}

fn change(some_string: &amp;String) {
    some_string.push_str(&quot; Welt&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-6: Versuch, einen ausgeliehenen Wert zu
verändern</span></p>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0596]: cannot borrow `*some_string` as mutable, as it is behind a `&amp;` reference
 --&gt; src/main.rs:8:5
  |
7 | fn change(some_string: &amp;String) {
  |                        ------- help: consider changing this to be a mutable reference: `&amp;mut std::string::String`
8 |     some_string.push_str(&quot; Welt&quot;);
  |     ^^^^^^^^^^^ `some_string` is a `&amp;` reference, so the data it refers to cannot be borrowed as mutable

error: aborting due to previous error

For more information about this error, try `rustc --explain E0596`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>So wie Variablen standardmäßig unveränderlich sind, so sind auch Referenzen
unveränderlich. Es ist uns nicht erlaubt, etwas zu verändern, auf das wir eine
Referenz haben.</p>
<h3><a class="header" href="#veränderliche-referenzen" id="veränderliche-referenzen">Veränderliche Referenzen</a></h3>
<p>Wir können den Fehler im Code von Codeblock 4-6 mit nur einer kleinen Änderung
beheben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let mut s = String::from(&quot;Hallo&quot;);

    change(&amp;mut s);
}

fn change(some_string: &amp;mut String) {
    some_string.push_str(&quot; Welt&quot;);
}
</code></pre></pre>
<p>Zuerst mussten wir <code>s</code> ändern, um <code>mut</code> zu sein. Dann mussten wir eine
veränderliche Referenz mit <code>&amp;mut s</code> erstellen und eine veränderliche Referenz
mit <code>some_string: &amp;mut String</code> entgegennehmen.</p>
<p>Veränderliche Referenzen haben jedoch eine große Einschränkung: Du kannst nur
eine veränderliche Referenz auf einen bestimmten Datenwert in einem bestimmten
Gültigkeitsbereich haben. Dieser Code wird fehlschlagen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;mut s;
let r2 = &amp;mut s;

println!(&quot;{}, {}&quot;, r1, r2);
<span class="boring">}
</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0499]: cannot borrow `s` as mutable more than once at a time
 --&gt; src/main.rs:5:14
  |
4 |     let r1 = &amp;mut s;
  |              ------ first mutable borrow occurs here
5 |     let r2 = &amp;mut s;
  |              ^^^^^^ second mutable borrow occurs here
6 | 
7 |     println!(&quot;{}, {}&quot;, r1, r2);
  |                        -- first borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0499`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Beschränkung erlaubt das Verändern von Werten, aber auf eine sehr
kontrollierte Weise. Das ist etwas, womit neue Rust-Entwickler zu kämpfen
haben, denn in den meisten Sprachen kann man verändern, wann immer man will.</p>
<p>Diese Beschränkung hat den Vorteil, dass Rust Daten-Wettlaufsituation zur
Kompilierzeit verhindern kann. Eine <em>Daten-Wettlaufsituation</em> (data race) ist
ähnlich einer Wettlaufsituation (race condition) und tritt auf, wenn diese drei
Verhaltensweisen auftreten:</p>
<ul>
<li>Zwei oder mehr Zeiger greifen gleichzeitig auf dasselbe Datum zu.</li>
<li>Mindestens einer der Zeiger wird zum Schreiben auf das Datum verwendet.</li>
<li>Es kommt kein Mechanismus zur Anwendung, den Zugriff auf die Daten zu
synchronisieren.</li>
</ul>
<p>Daten-Wettlaufsituationen verursachen undefiniertes Verhalten und können
schwierig zu diagnostizieren und zu beheben sein, wenn du versuchst, sie zur
Laufzeit aufzuspüren; Rust verhindert dieses Problem, indem es Code mit
Daten-Wettlaufsituationen gar nicht erst kompiliert!</p>
<p>Wie immer können wir geschweifte Klammern verwenden, um einen neuen
Gültigkeitsbereich zu schaffen, der mehrere veränderliche Verweise erlaubt, nur
nicht <em>gleichzeitige</em>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

{
    let r1 = &amp;mut s;
} // r1 verlässt hier den Gültigkeitsbereich, sodass wir
  // problemlos eine neue Referenz erstellen können.

let r2 = &amp;mut s;
<span class="boring">}
</span></code></pre></pre>
<p>Eine ähnliche Regel gibt es für die Kombination von veränderlichen und
unveränderlichen Referenzen. Dieser Code führt zu einem Fehler:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s;     // kein Problem
let r2 = &amp;s;     // kein Problem
let r3 = &amp;mut s; // GROSSES PROBLEM

println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:14
  |
4 |     let r1 = &amp;s;     // kein Problem
  |              -- immutable borrow occurs here
5 |     let r2 = &amp;s;     // kein Problem
6 |     let r3 = &amp;mut s; // GROSSES PROBLEM
  |              ^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;{}, {} und {}&quot;, r1, r2, r3);
  |                               -- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Puh! Wir können auch keine veränderlichen Referenzen haben, solange wir eine
unveränderliche haben. Nutzer einer unveränderlichen Referenz erwarten nicht,
dass sich die Werte dahinter plötzlich ändern! Mehrere unveränderliche
Referenzen sind jedoch in Ordnung, da niemand, der die Daten nur liest, die
Möglichkeit hat, das Lesen der Daten durch andere zu beeinflussen.</p>
<p>Beachte, dass der Gültigkeitsbereich einer Referenz dort beginnt, wo sie
eingeführt wird, und sich bis zur letzten Verwendung dieser Referenz fortsetzt. 
Zum Beispiel kompiliert dieser Code, weil die letzte Verwendung der
unveränderlichen Referenzen vor der Einführung der veränderlichen Referenz
erfolgt:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;Hallo&quot;);

let r1 = &amp;s; // kein Problem
let r2 = &amp;s; // kein Problem
println!(&quot;{} und {}&quot;, r1, r2);
// r1 und r2 werden nach dieser Stelle nicht mehr verwendet

let r3 = &amp;mut s; // kein Problem
println!(&quot;{}&quot;, r3);
<span class="boring">}
</span></code></pre></pre>
<p>Die Gültigkeitsbereiche der unveränderlichen Referenzen <code>r1</code> und <code>r2</code> enden
nach dem <code>println!</code>, wo sie zuletzt verwendet werden, d.h. bevor die
veränderliche Referenz <code>r3</code> erstellt wird. Diese Gültigkeitsbereiche
überschneiden sich nicht, daher ist dieser Code zulässig.</p>
<p>Auch wenn das Ausleihen von Fehlern manchmal frustrierend sein kann, denke
daran, dass es der Rust-Kompilierer ist, der frühzeitig (zur Kompilierzeit und
nicht zur Laufzeit) auf einen möglichen Fehler hinweist und dir genau zeigt, wo
das Problem liegt. Dann musst du nicht aufspüren, warum deine Daten nicht so
sind, wie du dachtest.</p>
<h3><a class="header" href="#hängende-referenzen" id="hängende-referenzen">Hängende Referenzen</a></h3>
<p>In Sprachen mit Zeigern ist es leicht, fälschlicherweise einen <em>hängenden
Zeiger</em> (dangling pointer) zu erzeugen, also einen Zeiger, der auf eine Stelle
im Speicher verweist, die vielleicht an jemand anderem vergeben wurde, weil der
Speicher freigegeben wurde, während noch ein Zeiger auf diesen Speicher
bestehen bleibt. In Rust hingegen garantiert der Kompilierer, dass Referenzen
niemals hängende Referenzen sein können: Wenn du eine Referenz auf Daten hast,
stellt der Kompilierer sicher, dass die Daten nicht den Gültigkeitsbereich
verlassen, bevor die Referenz auf die Daten dies tut.</p>
<p>Versuchen wir, eine hängende Referenz zu erstellen, was Rust mit einem
Kompilierfehler verhindern wird:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -&gt; &amp;String {
    let s = String::from(&quot;Hallo&quot;);

    &amp;s
}
</code></pre></pre>
<p>Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:5:16
  |
5 | fn dangle() -&gt; &amp;String {
  |                ^ help: consider giving it a 'static lifetime: `&amp;'static`
  |
  = help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Diese Fehlermeldung bezieht sich auf eine Funktionalität, die wir noch nicht
behandelt haben: Die Lebensdauer. Wir werden die Lebensdauer in Kapitel 10 im
Detail besprechen. Abgesehen von den Hinweisen zur Lebensdauer enthält die
Meldung den entscheidenden Hinweis, warum dieser Code nicht funktioniert:</p>
<blockquote>
<p>Hilfe: Der Rückgabetyp dieser Funktion enthält einen ausgeliehenen Wert, aber
es gibt keinen Wert der ausgeliehen werden kann.</p>
</blockquote>
<p>Lass uns einen genaueren Blick auf das werfen, was in jeder Phase unseres
<code>dangle</code>-Codes geschieht:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let reference_to_nothing = dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn dangle() -&gt; &amp;String { // dangle gibt eine Referenz
                         // auf eine Zeichenkette zurück

    let s = String::from(&quot;Hallo&quot;); // s ist eine neue Zeichenkette

    &amp;s // wir geben einen Verweis auf die Zeichenkette s zurück
} // Hier verlässt s den Gültigkeitsbereich und wird verworfen.
  // Sein Speicherplatz wird aufgeräumt. Gefahr!
</code></pre></pre>
<p>Da <code>s</code> innerhalb <code>dangle</code> erzeugt wird, wird <code>s</code> wieder freigegeben, wenn der
Code von <code>dangle</code> zu Ende ist. Aber wir haben versucht, eine Referenz darauf
zurückzugeben. Das heißt, diese Referenz würde auf einen ungültigen <code>String</code>
verweisen. Das ist nicht gut! Rust lässt uns das nicht tun.</p>
<p>Die Lösung ist, den <code>String</code> direkt zurückzugeben:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string = no_dangle();
</span><span class="boring">}
</span><span class="boring">
</span>fn no_dangle() -&gt; String {
    let s = String::from(&quot;Hallo&quot;);

    s
}
</code></pre></pre>
<p>Dies funktioniert ohne Probleme. Die Eigentümerschaft wird nach außen
verschoben, und nichts wird freigegeben.</p>
<h3><a class="header" href="#regeln-für-referenzen" id="regeln-für-referenzen">Regeln für Referenzen</a></h3>
<p>Lass uns rekapitulieren, was wir über Referenzen gelernt haben:</p>
<ul>
<li>Zu jedem beliebigen Zeitpunkt kannst du <em>entweder</em> eine veränderliche
Referenz <em>oder</em> eine beliebige Anzahl unveränderlicher Referenzen haben.</li>
<li>Referenzen müssen immer gültig sein.</li>
</ul>
<p>Als Nächstes werden wir uns mit einer anderen Art von Referenz befassen:
Anteilstypen (slice).</p>
<h2><a class="header" href="#der-anteilstyp-slice" id="der-anteilstyp-slice">Der Anteilstyp (slice)</a></h2>
<p>Ein weiterer Datentyp, für den keine Eigentümerschaft besteht, ist der
<em>Anteilstyp</em> (slice). Mit Anteilstypen kannst du auf eine zusammenhängende
Folge von Elementen in einer Kollektion verweisen, anstatt auf die gesamte
Kollektion.</p>
<p>Hier ist ein kleines Programmierproblem: Schreibe eine Funktion, die eine
Zeichenkette entgegennimmt und das erste Wort zurückgibt, das sie in dieser
Zeichenkette findet. Wenn die Funktion kein Leerzeichen in der Zeichenkette
findet, muss die gesamte Zeichenkette ein Wort sein, also sollte die gesamte
Zeichenkette zurückgegeben werden.</p>
<p>Lass uns über die Signatur dieser Funktion nachdenken:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; ?
</code></pre>
<p>Diese Funktion <code>first_word</code> hat einen <code>&amp;String</code> als Parameter. Wir wollen keine
Eigentümerschaft, also ist das in Ordnung. Aber was sollen wir zurückgeben? Wir
haben nicht wirklich eine Möglichkeit, über <em>einen Teil</em> einer Zeichenkette zu
sprechen. Wir könnten jedoch den Index des Wortendes zurückgeben. Versuchen wir
das, wie in Codeblock 4-7 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;String) -&gt; usize {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-7: Die Funktion <code>first_word</code>, die einen
Byte-Indexwert zum Parameter <code>String</code> zurückgibt</span></p>
<p>Da wir den <code>String</code> Zeichen für Zeichen durchgehen und prüfen müssen, ob ein
Wert ein Leerzeichen ist, wandeln wir unseren <code>String</code> mit der Methode
<code>as_bytes</code> in ein Byte-Array um:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span>    let bytes = s.as_bytes();
<span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Als nächstes erstellen wir einen Iterator über das Byte-Array, indem wir die
Methode <code>iter</code> verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span>    for (i, &amp;item) in bytes.iter().enumerate() {
<span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Auf Iteratoren werden wir in Kapitel 13 näher eingehen. Fürs Erste solltest du
wissen, dass <code>iter</code> eine Methode ist, die jedes Element in einer Kollektion
zurückgibt und dass <code>enumerate</code> das Ergebnis von <code>iter</code> umhüllt und stattdessen
jedes Element als Teil eines Tupels zurückgibt. Das erste Element des Tupels,
das von <code>enumerate</code> zurückgegeben wird, ist der Index, und das zweite Element
ist eine Referenz auf das Element. Das ist etwas bequemer, als den Index selbst
zu berechnen.</p>
<p>Da die Methode <code>enumerate</code> ein Tupel zurückgibt, können wir Muster verwenden,
um dieses Tupel zu zerlegen, so wie überall in Rust. In der <code>for</code>-Schleife
spezifizieren wir also ein Muster, das <code>i</code> für den Index im Tupel und <code>&amp;item</code>
für das einzelne Byte im Tupel hat. Da wir eine Referenz auf das Element aus
<code>.iter().enumerate()</code> erhalten, verwenden wir <code>&amp;</code> im Muster.</p>
<p>Innerhalb der <code>for</code>-Schleife suchen wir mit Hilfe der Byte-Literal-Syntax
<code>b' '</code> nach dem Byte, das das Leerzeichen repräsentiert. Wenn wir ein
Leerzeichen finden, geben wir die Position zurück. Andernfalls geben wir die
Länge der Zeichenkette zurück, indem wir <code>s.len()</code> verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span>        if item == b' ' {
            return i;
        }
    }

    s.len()
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wir haben jetzt eine Möglichkeit, den Index des ersten Wortendes in der
Zeichenkette herauszufinden, aber es gibt ein Problem. Wir geben ein <code>usize</code>
für sich allein zurück, aber die Zahl ist nur aussagekräftig im Kontext des
<code>&amp;String</code>. Mit anderen Worten: Da es sich um einen vom <code>String</code> getrennten Wert
handelt, gibt es keine Garantie, dass er auch in Zukunft noch gültig ist.
Betrachte das Programm in Codeblock 4-8, das die Funktion <code>first_word</code> aus
Codeblock 4-7 verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;String) -&gt; usize {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return i;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    s.len()
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s); // word erhält den Wert 5

    s.clear(); // leert die Zeichenkette und macht sie gleich &quot;&quot;

    // word hat noch immer den Wert 5, aber es gibt keine Zeichenkette mehr,
    // mit der wir den Wert 5 sinnvoll verwenden könnten.
    // word ist jetzt völlig ungültig!
}
</code></pre></pre>
<p><span class="caption">Codeblock 4-8: Speichern des Ergebnisses des
Funktionsaufrufs <code>first_word</code> und anschließendes Ändern des Inhalts der
Zeichenkette</span></p>
<p>Dieses Programm kompiliert fehlerfrei und würde dies auch tun, wenn wir <code>word</code>
nach dem Aufruf von <code>s.clear()</code> benutzen würden. Da <code>word</code> überhaupt nicht mit
dem Zustand von <code>s</code> verbunden ist, enthält <code>word</code> immer noch den Wert <code>5</code>. Wir
könnten den Wert <code>5</code> mit der Variable <code>s</code> verwenden, um zu versuchen, das erste
Wort zu extrahieren, aber das wäre ein Fehler, weil sich der Inhalt von <code>s</code>
geändert hat, nachdem wir <code>5</code> in <code>word</code> gespeichert haben.</p>
<p>Sich darum kümmern zu müssen, dass der Index in <code>word</code> mit den Daten in <code>s</code>
konform ist, ist mühsam und fehleranfällig! Das Verwalten dieser Indizes ist
noch fehleranfälliger, wenn wir eine Funktion <code>second_word</code> schreiben. Ihre
Signatur müsste dann so aussehen:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; (usize, usize) {
</code></pre>
<p>Jetzt verfolgen wir einen Anfangs- <em>und</em> einen Endindex, und wir haben noch
mehr Werte, die aus Daten in einem bestimmten Zustand berechnet wurden, aber
überhaupt nicht an diesen Zustand gebunden sind. Wir haben jetzt drei
unverbundene Variablen, die synchron gehalten werden müssen.</p>
<p>Glücklicherweise hat Rust eine Lösung für dieses Problem:
Zeichenkettenanteilstypen</p>
<h3><a class="header" href="#zeichenkettenanteilstypen-string-slices" id="zeichenkettenanteilstypen-string-slices">Zeichenkettenanteilstypen (string slices)</a></h3>
<p>Ein <em>Zeichenkettenanteilstyp</em>  (string slice) ist ein Verweis auf einen Teil
eines <code>String</code>, und er sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo Welt&quot;);

let hello = &amp;s[0..5];
let world = &amp;s[6..10];
<span class="boring">}
</span></code></pre></pre>
<p>Dies ist ähnlich zu einem Verweis auf den gesamten <code>String</code>, aber mit
zusätzlichem <code>[0..5]</code>. Es handelt sich nicht um eine Referenz auf den gesamten
<code>String</code>, sondern auf einen Teil des <code>String</code>.</p>
<p>Wir können Anteilstypen mit einem Bereich innerhalb Klammern erstellen, indem
wir <code>[starting_index..ending_index]</code> angeben, wobei <code>starting_index</code> die erste
Position im Anteilstyp ist und <code>ending_index</code> die Position hinter der letzten
Position im Anteilstyp. Intern speichert die Anteilstyp-Datenstruktur die
Startposition und die Länge des Anteilstyps, was <code>ending_index</code> minus
<code>starting_index</code> entspricht. Im Fall von <code>let world = &amp;s[6..10];</code> wäre <code>world</code>
also ein Anteilstyp, der einen Zeiger auf das 7. Byte (von 1 an gezählt) von
<code>s</code> mit einem Längenwert von 4 enthält.</p>
<p>Abbildung 4-6 zeigt dies.</p>
<p><img alt="world mit einem Zeiger auf das 6. Byte von String s und einer Länge von 4"
src="img/trpl04-06.svg" class="center" style="width: 50%;" /></p>
<p><span class="caption">Abbildung 4-6: Zeichenkettenanteilstyp, der sich auf einen
Teil eines <code>String</code> bezieht</span></p>
<p>Wenn du mit der Bereichssyntax <code>..</code> in Rust beim ersten Index (Null) beginnen
willst, kannst du den Wert vor den zwei Punkte weglassen. Mit anderen Worten
sind diese gleich:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let slice = &amp;s[0..2];
let slice = &amp;s[..2];
<span class="boring">}
</span></code></pre></pre>
<p>Ebenso kannst du den Endindex weglassen, wenn dein Anteilstyp das letzte Byte
des <code>String</code> enthält. Das bedeutet, dass diese gleich sind:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[3..len];
let slice = &amp;s[3..];
<span class="boring">}
</span></code></pre></pre>
<p>Du kannst auch beide Werte weglassen, um einen Ausschnitt der gesamten
Zeichenkette zu beschreiben. Diese sind also gleichwertig:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;Hallo&quot;);

let len = s.len();

let slice = &amp;s[0..len];
let slice = &amp;s[..];
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>Hinweis: Bereichsindizes bei Zeichenkettenanteilstypen müssen sich nach
gültigen UTF-8-Zeichengrenzen richten. Wenn du versuchst, einen
Zeichenkettenanteilstyp in der Mitte eines Mehrbyte-Zeichens zu erstellen,
wird dein Programm mit einem Fehler abbrechen. Bei der Einführung von
Zeichenkettenanteilstypen in diesem Abschnitt gehen wir nur von ASCII aus;
eine eingehendere Diskussion der UTF-8-Behandlung findet sich im Abschnitt
<a href="ch08-02-strings.html#storing-utf-8-encoded-text-with-strings">„Speichern von UTF-8-kodiertem Text mit Zeichenketten“</a> in Kapitel
8.</p>
</blockquote>
<p>Mit all diesen Informationen im Hinterkopf schreiben wir <code>first_word</code> so um,
dass es einen Anteilstyp zurückgibt. Der Typ mit der Bedeutung
„Zeichenkettenanteilstyp“ wird <code>&amp;str</code> geschrieben:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;String) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Den Index für das Wortende erhalten wir auf die gleiche Weise wie in Codeblock
4-7, indem wir nach dem ersten Vorkommen eines Leerzeichens suchen. Wenn wir
ein Leerzeichen finden, geben wir einen Zeichenkettenanteilstyp zurück, wobei
wir den Anfang der Zeichenkette und den Index des Leerzeichens als Anfangs-
bzw. Endindex verwenden.</p>
<p>Wenn wir nun <code>first_word</code> aufrufen, erhalten wir einen einzelnen Wert zurück,
der an die zugrundeliegenden Daten gebunden ist. Der Wert setzt sich aus einer
Referenz auf den Startpunkt des Anteilstyps und der Anzahl der Elemente im
Anteilstyp zusammen.</p>
<p>Die Rückgabe eines Anteilstyps würde auch für eine Funktion <code>second_word</code>
funktionieren:</p>
<pre><code class="language-rust ignore">fn second_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Wir haben jetzt eine einfache API, die viel schwieriger durcheinanderzubringen
ist, weil der Kompilierer sicherstellt, dass die Referenzen auf den <code>String</code>
gültig bleiben. Erinnere dich an den Fehler im Programm in Codeblock 4-8, als
wir den Index bis zum Ende des ersten Wortes erhielten, dann aber die
Zeichenkette löschten, sodass unser Index ungültig wurde. Dieser Code war
logisch falsch, zeigte aber keine unmittelbaren Fehler. Die Probleme würden
sich später zeigen, wenn wir weiterhin versuchen würden, den ersten Wortindex
mit einer leeren Zeichenkette zu verwenden. Anteilstypen machen diesen Fehler
unmöglich und lassen uns viel früher wissen, dass wir ein Problem mit unserem
Code haben. Die Anteilstypen-Variante von <code>first_word</code> führt zu einem
Kompilierfehler:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile"><span class="boring">fn first_word(s: &amp;String) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let mut s = String::from(&quot;Hallo Welt&quot;);

    let word = first_word(&amp;s);

    s.clear(); // Fehler!

    println!(&quot;Das erste Wort ist: {}&quot;, word);
}
</code></pre></pre>
<p>Hier ist der Kompilierfehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling ownership v0.1.0 (file:///projects/ownership)
error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:18:5
   |
16 |     let word = first_word(&amp;s);
   |                           -- immutable borrow occurs here
17 | 
18 |     s.clear(); // Fehler!
   |     ^^^^^^^^^ mutable borrow occurs here
19 | 
20 |     println!(&quot;Das erste Wort ist: {}&quot;, word);
   |                                        ---- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `ownership`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Erinnere dich an die Ausleihregeln, durch die wir, wenn wir eine
unveränderliche Referenz auf etwas haben, nicht noch eine veränderliche
Referenz anlegen können. Da <code>clear</code> den <code>String</code> abschneiden muss, muss es
eine veränderliche Referenz erhalten. Rust erlaubt dies nicht und die
Kompilierung schlägt fehl. Rust hat nicht nur die Benutzung unserer API
vereinfacht, sondern auch eine ganze Klasse von Fehlern zur Kompilierzeit
beseitigt!</p>
<h4><a class="header" href="#zeichenkettenliterale-sind-anteilstypen" id="zeichenkettenliterale-sind-anteilstypen">Zeichenkettenliterale sind Anteilstypen</a></h4>
<p>Erinnere dich, dass wir darüber sprachen, dass Zeichenkettenliterale in der
Binärdatei gespeichert werden. Jetzt, da wir über Anteilstypen Bescheid wissen,
können wir Zeichenkettenliterale richtig verstehen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = &quot;Hallo Welt!&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Der Typ von <code>s</code> hier ist <code>&amp;str</code>: Es ist ein Anteilstyp, der auf diesen
speziellen Punkt der Binärdatei zeigt. Das ist auch der Grund, warum
Zeichenkettenliterale unveränderlich sind; <code>&amp;str</code> ist ein unveränderliche
Referenz.</p>
<h4><a class="header" href="#zeichenkettenanteilstypen-als-parameter" id="zeichenkettenanteilstypen-als-parameter">Zeichenkettenanteilstypen als Parameter</a></h4>
<p>Das Wissen, dass man Anteilstypen von Literalen und <code>String</code>-Werten erstellen
kann, führt uns zu einer weiteren Verbesserung von <code>first_word</code>, und das ist
ihre Signatur:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;String) -&gt; &amp;str {
</code></pre>
<p>Ein erfahrenerer Rust-Entwickler würde stattdessen die in Codeblock 4-9
gezeigte Signatur schreiben, da sie es uns erlaubt, dieselbe Funktion sowohl
auf <code>&amp;String</code>-Werte als auch auf <code>&amp;str</code>-Werte anzuwenden.</p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
<span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;Hallo Welt&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;Hallo Welt&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 4-9: Verbessern der Funktion <code>first_word</code> durch
Verwenden eines Zeichenkettenanteilstyps für den Typ des Parameters <code>s</code></span></p>
<p>Wenn wir einen Zeichenkettenanteilstyp haben, können wir diesen direkt
übergeben. Wenn wir einen <code>String</code> haben, können wir einen Anteilstyp des
gesamten <code>String</code> übergeben. Das Definieren einer Funktion, die einen
Zeichenkettenanteilstyp statt einer Referenz auf einen <code>String</code> entgegennimmt,
macht unsere API allgemeiner und nützlicher, ohne an Funktionalität einzubüßen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn first_word(s: &amp;str) -&gt; &amp;str {
</span><span class="boring">    let bytes = s.as_bytes();
</span><span class="boring">
</span><span class="boring">    for (i, &amp;item) in bytes.iter().enumerate() {
</span><span class="boring">        if item == b' ' {
</span><span class="boring">            return &amp;s[0..i];
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    &amp;s[..]
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let my_string = String::from(&quot;Hallo Welt&quot;);

    // first_word funktioniert mit Anteilstypen von `String`
    let word = first_word(&amp;my_string[..]);

    let my_string_literal = &quot;Hallo Welt&quot;;

    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
    let word = first_word(&amp;my_string_literal[..]);

    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
    // funktioniert dies auch ohne die Anteilstypensyntax!
    let word = first_word(my_string_literal);
}
</code></pre></pre>
<h3><a class="header" href="#andere-anteilstypen" id="andere-anteilstypen">Andere Anteilstypen</a></h3>
<p>Zeichenkettenanteilstypen sind, wie du dir vorstellen kannst, spezifisch für
Zeichenketten. Es gibt aber auch einen allgemeineren Anteilstyp. Betrachte
dieses Array:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];
<span class="boring">}
</span></code></pre></pre>
<p>Genauso wie wir vielleicht auf einen Teil einer Zeichenkette verweisen möchten,
möchten wir vielleicht auf einen Teil eines Arrays verweisen. Wir würden das so
machen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let a = [1, 2, 3, 4, 5];

let slice = &amp;a[1..3];
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Anteilstyp hat den Typ <code>&amp;[i32]</code>. Es funktioniert auf die gleiche Weise
wie bei Zeichenkettenanteilstypen, indem es eine Referenz auf das erste Element
und eine Länge speichert. Du wirst diese Art von Anteilstyp für alle möglichen
anderen Kollektionen verwenden. Wir werden diese Kollektionen im Detail
besprechen, wenn wir in Kapitel 8 über Vektoren sprechen.</p>
<h2><a class="header" href="#zusammenfassung" id="zusammenfassung">Zusammenfassung</a></h2>
<p>Die Konzepte von Eigentümerschaft, Ausleihen und Anteilstypen gewährleisten
Speichersicherheit zur Kompilierzeit in Rust-Programmen. Die Sprache Rust gibt
dir Kontrolle über die Speicherverwendung auf die gleiche Weise wie andere
Systemprogrammiersprachen, aber dadurch dass der Eigentümer der Daten diese
automatisch aufräumt, wenn der Eigentümer den Gültigkeitsbereich verlässt,
bedeutet dies, dass du keinen zusätzlichen Code schreiben und debuggen musst,
um diese Kontrolle zu erhalten.</p>
<p>Die Eigentümerschaft wirkt sich auf die Funktionsweise vieler anderer Teile von
Rust aus, deshalb werden wir im weiteren Verlauf des Buchs weiter über diese
Konzepte sprechen. Lass uns zu Kapitel 5 übergehen und uns das Gruppieren von
Datenteilen zu einer <code>struct</code> ansehen.</p>
<h1><a class="header" href="#strukturen-structs-für-zusammenhängende-daten-verwenden" id="strukturen-structs-für-zusammenhängende-daten-verwenden">Strukturen (structs) für zusammenhängende Daten verwenden</a></h1>
<p>Eine <em>Struktur</em> (struct) ist ein benutzerdefinierter Datentyp, mit dem man
mehrere zusammenhängende Werte, die eine sinnvolle Gruppe bilden,
zusammenpacken und benennen kann. Wenn du mit einer objektorientierten Sprache
vertraut bist, ist eine <em>Struktur</em> analog zu den Datenattributen eines Objekts.
In diesem Kapitel vergleichen wir Tupel mit Strukturen, stellen die
Unterschiede dar, zeigen die Verwendung von Strukturen und erörtern, wie
Methoden und zugehörige Funktionen definiert werden, um das mit den Daten einer
Struktur verbundene Verhalten zu spezifizieren. Strukturen und Aufzählungen
(enums) (siehe Kapitel 6) sind die Bausteine zum Erstellen neuer Typen in der
Domäne deines Programms, mit denen du die Vorteile der Kompilierzeit-Typprüfung
von Rust voll auszuschöpfen kannst.</p>
<h2><a class="header" href="#strukturen-structs-definieren-und-instanziieren" id="strukturen-structs-definieren-und-instanziieren">Strukturen (structs) definieren und instanziieren</a></h2>
<p>Strukturen (structs) ähneln Tupeln, die in Kapitel 3 besprochen wurden. Wie
bei Tupeln können die Teile einer Struktur verschiedene Typen haben. Anders als
bei Tupeln benennst du jedes Teil, damit ist klar, was die Werte bedeuten.
Durch diese Namen sind Strukturen flexibler als Tupel: Du musst dich nicht auf
die Reihenfolge der Daten verlassen, um die Werte einer Instanz zu
spezifizieren oder auf sie zuzugreifen.</p>
<p>Um eine Struktur zu definieren, geben wir das Schlüsselwort <code>struct</code> an und
benennen die gesamte Struktur. Der Name einer Struktur sollte die Bedeutung der
Daten beschreiben, die gruppiert werden. Dann definieren wir innerhalb
geschweifter Klammern die Namen und Typen der Datenteile, die wir <em>Felder</em>
nennen. Beispielsweise zeigt Codeblock 5-1 eine Struktur, die Informationen
über ein Benutzerkonto speichert.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-1: Definition der Struktur <code>User</code></span></p>
<p>Um eine Struktur zu verwenden, nachdem wir sie definiert haben, erstellen wir
eine <em>Instanz</em> dieser Struktur, indem wir für jedes Feld einen konkreten Wert
angeben. Wir erzeugen eine Instanz, indem wir den Namen der Struktur angeben
und dann in geschweiften Klammern die <code>Schlüssel: Wert</code>-Paare angeben, wobei
die Schlüssel die Namen der Felder und die Werte die Daten sind, die wir in
diesen Feldern speichern wollen. Wir müssen die Felder nicht in der gleichen
Reihenfolge angeben, in der wir sie in der Struktur deklariert haben. Anders
gesagt ist die Strukturdefinition wie eine allgemeine Typvorlage und Instanzen
füllen diese Vorlage mit bestimmten Daten aus, um Werte des Typs zu erzeugen.
Beispielsweise können wir einen bestimmten Benutzer deklarieren, wie in
Codeblock 5-2 zu sehen ist.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-2: Eine Instanz der Struktur <code>User</code>
erzeugen</span></p>
<p>Um auf einen bestimmten Wert in einer Struktur zuzugreifen, können wir die
Punktnotation verwenden. Wenn wir nur die E-Mail-Adresse dieses Benutzers
wollen, können wir <code>user1.email</code> überall dort einsetzen, wo wir diesen Wert
verwenden wollen. Wenn die Instanz veränderlich ist, können wir einen Wert
mittels Punktnotation verändern. Codeblock 5-3 gezeigt, wie der Wert im
Feld <code>email</code> einer veränderlichen <code>User</code>-Instanz geändert werden kann.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let mut user1 = User {
        email: String::from(&quot;jemand@example.com&quot;),
        username: String::from(&quot;benutzername123&quot;),
        active: true,
        sign_in_count: 1,
    };

    user1.email = String::from(&quot;andere-email@example.com&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-3: Wert im Feld <code>email</code> einer <code>User</code>-Instanz ändern</span></p>
<p>Beachte, dass die gesamte Instanz veränderlich sein muss. Rust erlaubt es
nicht, nur einzelne Felder als veränderlich zu markieren. Wie mit jedem
Ausdruck können wir eine neue Instanz der Struktur als letzten Ausdruck im
Funktionsrumpf erzeugen, um diese neue Instanz implizit zurückzugeben.</p>
<p>Codeblock 5-4 zeigt eine Funktion <code>build_user</code>, die eine <code>User</code>-Instanz mit der
angegebenen E-Mail und dem Benutzernamen zurückgibt. Das Feld <code>active</code> erhält
den Wert <code>true</code> und das Feld <code>sign_in_count</code> den Wert <code>1</code>.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-4: Funktion <code>build_user</code>, die eine E-Mail und
einen Benutzernamen entgegennimmt und eine <code>User</code>-Instanz zurückgibt</span></p>
<p>Es ist sinnvoll, den Funktionsparametern dieselben Namen wie die der
Strukturfelder zu geben, jedoch ist das Wiederholen der Feldnamen <code>email</code> und
<code>username</code> etwas mühsam. Wenn die Struktur mehr Felder hätte, würde das
Wiederholen jedes Namens noch lästiger werden. Glücklicherweise gibt es eine
praktische Kurznotation!</p>
<h3><a class="header" href="#kurznotation-der-feld-initialisierung-verwenden-wenn-variablen-und-felder-den-gleichen-namen-haben" id="kurznotation-der-feld-initialisierung-verwenden-wenn-variablen-und-felder-den-gleichen-namen-haben">Kurznotation der Feld-Initialisierung verwenden, wenn Variablen und Felder den gleichen Namen haben</a></h3>
<p>Da die Parameter und die Strukturfelder in Codeblock 5-4 die gleichen Namen
haben, können wir die <em>Kurznotation der Feld-Initialisierung</em> (field init
shorthand syntax) verwenden, um die Funktion <code>build_user</code> so umzuschreiben,
dass sie sich unverändert gleich verhält, ohne <code>email</code> und <code>username</code> zu
wiederholen, siehe Codeblock 5-5.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span>fn build_user(email: String, username: String) -&gt; User {
    User {
        email,
        username,
        active: true,
        sign_in_count: 1,
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = build_user(
</span><span class="boring">        String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        String::from(&quot;benutzername123&quot;),
</span><span class="boring">    );
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-5: Funktion <code>build_user</code> mit Kurznotation der
Feld-Initialisierung, weil die Parameternamen <code>email</code> und <code>username</code> identisch
mit den Strukturfeldern sind</span></p>
<p>Hier erzeugen wir eine neue Instanz der Struktur <code>User</code>, die ein Feld namens
<code>email</code> hat. Wir wollen den Wert des Feldes <code>email</code> auf den Wert des Parameters
<code>email</code> der Funktion <code>build_user</code> setzen. Da das Feld <code>email</code> und der Parameter
<code>email</code> den gleichen Namen haben, brauchen wir nur <code>email</code> statt <code>email: email</code>
zu schreiben.</p>
<h3><a class="header" href="#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax" id="instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">Instanzen aus anderen Instanzen erzeugen mit der Strukturaktualisierungssyntax</a></h3>
<p>Oft ist es hilfreich, eine neue Instanz einer Struktur zu erstellen, die die
meisten Werte einer alten Instanz verwendet und nur einige davon verändert. Du
kannst dazu die <em>Strukturaktualisierungssyntax</em> (struct update syntax)
verwenden.</p>
<p>Zunächst zeigt Codeblock 5-6, wie wir eine neue <code>User</code>-Instanz <code>user2</code> ohne
Aktualisierungssyntax erstellen. Wir setzen neue Werte für <code>email</code> und
<code>username</code>, verwenden aber ansonsten die gleichen Werte von <code>user1</code>, die wir in
Codeblock 5-2 erstellt haben.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        username: String::from(&quot;andererbenutzername567&quot;),
        active: user1.active,
        sign_in_count: user1.sign_in_count,
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-6: Erstellen einer neuen <code>User</code>-Instanz unter
Verwendung einiger der Werte von <code>user1</code>.</span></p>
<p>Durch Verwenden der Strukturaktualisierungssyntax können wir dasselbe Ergebnis
mit weniger Code erreichen, wie Codeblock 5-7 zeigt. Die Syntax <code>..</code> gibt an,
dass die restlichen Felder, die nicht explizit gesetzt wurden, den gleichen
Wert haben sollen wie die Felder in der gegebenen Instanz.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    username: String,
</span><span class="boring">    email: String,
</span><span class="boring">    sign_in_count: u64,
</span><span class="boring">    active: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let user1 = User {
</span><span class="boring">        email: String::from(&quot;jemand@example.com&quot;),
</span><span class="boring">        username: String::from(&quot;benutzername123&quot;),
</span><span class="boring">        active: true,
</span><span class="boring">        sign_in_count: 1,
</span><span class="boring">    };
</span><span class="boring">
</span>    let user2 = User {
        email: String::from(&quot;andere@example.com&quot;),
        username: String::from(&quot;andererbenutzername567&quot;),
        ..user1
    };
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-7: Verwenden der
Strukturaktualisierungssyntax, um neue Werte für <code>email</code> und <code>username</code> in der
<code>User</code>-Instanz zu setzen und die restlichen Werte aus den Feldern der Instanz
<code>user1</code> zu übernehmen</span></p>
<p>Der Code in Codeblock 5-7 erzeugt auch eine Instanz <code>user2</code>, die andere Werte
für <code>email</code> und <code>username</code> hat, aber die gleichen Werte der Felder <code>active</code> und
<code>sign_in_count</code> wie <code>user1</code>.</p>
<h3><a class="header" href="#verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen" id="verwenden-von-tupel-strukturen-ohne-benannte-felder-um-verschiedene-typen-zu-erzeugen">Verwenden von Tupel-Strukturen ohne benannte Felder um verschiedene Typen zu erzeugen</a></h3>
<p>Du kannst auch Strukturen definieren, die wie Tupel aussehen, sogenannte
<em>Tupel-Strukturen</em> (tuple structs). Tupel-Strukturen sind Strukturen, die
keine Feldnamen haben, sondern nur die Typen der Felder. Tupel-Strukturen sind
hilfreich, wenn du dem gesamten Tupel einen Namen geben und erreichen willst,
dass das Tupel einen anderen Typ als die anderen Tupel hat und Feldnamen wie in
einer regulären Struktur langatmig oder unnötig wären.</p>
<p>Um eine Tupel-Struktur zu definieren, starte mit dem Schlüsselwort <code>struct</code>,
gefolgt vom Strukturnamen und den Typen im Tupel. Nachfolgend ein Beispiel mit
Definition und Verwendung zweier Tupel-Strukturen <code>Color</code> und <code>Point</code>:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
<span class="boring">}
</span></code></pre></pre>
<p>Beachte, dass die Werte <code>black</code> und <code>origin</code> unterschiedliche Typen haben, weil
sie Instanzen unterschiedlicher Tupel-Strukturen sind. Jede von dir definierte
Struktur ist ein eigenständiger Typ, auch wenn die Felder innerhalb der
Struktur die gleichen Typen haben. Zum Beispiel kann eine Funktion, die einen
Parameter vom Typ <code>Color</code> hat, keinen <code>Point</code> als Argument nehmen, obwohl beide
Typen aus drei <code>i32</code>-Werten bestehen. Ansonsten verhalten sich
Tupel-Struktur-Instanzen wie Tupel: Du kannst sie in ihre Einzelteile zerlegen,
indem du <code>.</code> gefolgt vom Index schreibst, um auf einen einzelnen Wert
zuzugreifen, und so weiter.</p>
<h3><a class="header" href="#einheitstyp" id="einheitstyp">Einheitstyp</a></h3>
<p>Du kannst auch Strukturen definieren, die gar keine Felder haben! Diese werden
<em>Einheitstyp</em> (unit-like structs) genannt, weil sie sich ähnlich zum leeren
Tupel <code>()</code> verhalten. Einheitstypen können in Situationen nützlich sein, in
denen du ein Merkmal (trait) zu einem Typ implementieren musst, du aber keine
Daten hast, die im Typ gespeichert werden sollen. Wir werden Merkmale in
Kapitel 10 besprechen.</p>
<blockquote>
<h3><a class="header" href="#eigentümerschaft-von-strukturdaten" id="eigentümerschaft-von-strukturdaten">Eigentümerschaft von Strukturdaten</a></h3>
<p>In der Strukturdefinition <code>User</code> in Codeblock 5-1 haben wir den Typ <code>String</code>
anstelle von <code>&amp;str</code> verwendet. Dies ist eine bewusste Entscheidung, denn wir
wollen, dass Instanzen dieser Struktur all ihre Daten besitzen und diese
Daten so lange gültig sind, wie die gesamte Struktur gültig ist.</p>
<p>Bei Strukturen ist es möglich, Referenzen auf Daten zu speichern, die im
Besitz von etwas anderem sind, aber das erfordert die Verwendung von
<em>Lebensdauern</em>, einer Rust-Funktionalität, die wir in Kapitel 10 besprechen
werden. Die Lebensdauer stellt sicher, dass die von einer Struktur
referenzierten Daten so lange gültig sind, wie die Struktur gültig ist.
Angenommen, du versuchst eine Referenz in einer Struktur zu speichern, ohne
eine Lebensdauer anzugeben, wird das nicht funktionieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">struct User {
    username: &amp;str,
    email: &amp;str,
    sign_in_count: u64,
    active: bool,
}

fn main() {
    let user1 = User {
        email: &quot;jemand@example.com&quot;,
        username: &quot;benutzername123&quot;,
        active: true,
        sign_in_count: 1,
    };
}
</code></pre></pre>
<p>Der Compiler wird sich beschweren, dass die Lebensdauer nicht angegeben ist:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:2:15
  |
2 |     username: &amp;str,
  |               ^ expected lifetime parameter

error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:3:12
  |
3 |     email: &amp;str,
  |            ^ expected lifetime parameter

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0106`.
error: could not compile `structs`.

To learn more, run the command again with --verbose.
</code></pre>
<p>In Kapitel 10 werden wir klären, wie man diese Fehler behebt und Referenzen
in Strukturen speichern kann. Aber für den Moment werden wir Fehler wie diese
vermeiden, indem wir Typen wie <code>String</code> anstelle von Referenzen wie <code>&amp;str</code>
verwenden.</p>
</blockquote>
<h2><a class="header" href="#beispielprogramm-mit-strukturen-structs" id="beispielprogramm-mit-strukturen-structs">Beispielprogramm mit Strukturen (structs)</a></h2>
<p>Um besser zu verstehen, wann wir Strukturen verwenden können, schreiben wir ein
Programm, das die Fläche eines Rechtecks berechnet. Wir beginnen mit einzelnen
Variablen und schreiben das Programm dann um, bis wir stattdessen Strukturen
einsetzen.</p>
<p>Legen wir mit Cargo ein neues Binärprojekt namens <em>rectangles</em> an, das die
Breite und Höhe eines in Pixeln angegebenen Rechtecks nimmt und die Fläche des
Rechtecks berechnet.</p>
<p>Codeblock 5-8 zeigt ein kurzes Programm, das genau das in <em>src/main.rs</em> unseres
Projekts macht.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let width1 = 30;
    let height1 = 50;

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(width1, height1)
    );
}

fn area(width: u32, height: u32) -&gt; u32 {
    width * height
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-8: Berechnen der Fläche eines Rechtecks, das
durch separate Breiten- und Höhenvariablen beschrieben wird</span></p>
<p>Nun führe dieses Programm mit <code>cargo run</code> aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/structs`
Die Fläche des Rechtecks ist 1500 Quadratpixel.
</code></pre>
<p>Auch wenn Codeblock 5-8 funktioniert und die Fläche des Rechtecks durch
Aufrufen der Funktion <code>area</code> mit jeder Dimension herausfindet, können wir es
besser machen. Breite und Höhe hängen zusammen, sie beschreiben zusammen ein
Rechteck.</p>
<p>Das Problem dieses Codes wird bei der Signatur von <code>area</code> deutlich:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let width1 = 30;
</span><span class="boring">    let height1 = 50;
</span><span class="boring">
</span><span class="boring">    println!(
</span><span class="boring">        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
</span><span class="boring">        area(width1, height1)
</span><span class="boring">    );
</span><span class="boring">}
</span><span class="boring">
</span>fn area(width: u32, height: u32) -&gt; u32 {
<span class="boring">    width * height
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Funktion <code>area</code> soll die Fläche eines Rechtecks berechnen, aber die von uns
geschriebene Funktion hat zwei Parameter. Dass die Parameter zusammenhängen,
wird aber nirgendwo in unserem Programm ausgedrückt. Es wäre besser lesbar und
überschaubarer, Breite und Höhe zusammenzufassen. Eine Möglichkeit dazu haben
wir bereits im Abschnitt <a href="ch03-02-data-types.html#the-tuple-type">„Der Tupeltyp“</a> in Kapitel 3
vorgestellt: Der Einsatz von Tupeln.</p>
<h3><a class="header" href="#refaktorierung-mit-tupeln" id="refaktorierung-mit-tupeln">Refaktorierung mit Tupeln</a></h3>
<p>Codeblock 5-9 zeigt eine weitere Version unseres Programms, die Tupel
verwendet.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let rect1 = (30, 50);

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(rect1)
    );
}

fn area(dimensions: (u32, u32)) -&gt; u32 {
    dimensions.0 * dimensions.1
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-9: Breite und Höhe des Rechtecks werden mit
einem Tupel beschrieben</span></p>
<p>In einem Punkt ist dieses Programm besser. Das Tupel bringt etwas Struktur
hinein und wir geben jetzt nur noch ein Argument weiter. Andererseits ist
dieser Ansatz weniger deutlich: Tupel benennen ihre Elemente nicht, so dass
unsere Berechnung noch unübersichtlicher geworden ist, weil wir die Teile des
Tupels indizieren müssen.</p>
<p>Es spielt zwar keine Rolle, wenn wir bei der Flächenberechnung Breite und Höhe
verwechseln, aber wenn wir das Rechteck auf dem Bildschirm zeichnen wollten,
würde es eine Rolle spielen! Wir müssten berücksichtigen, dass <code>width</code> den
Tupelindex <code>0</code> und <code>height</code> den Tupelindex <code>1</code> hat. Wenn eine andere Person an
diesem Code arbeiten würde, müsste er das herausfinden und sich das ebenfalls
merken. Es wäre leicht, diese Werte zu vergessen oder zu verwechseln und Fehler
zu verursachen, weil wir die Bedeutung unserer Daten in unserem Code nicht
hinterlegt haben.</p>
<h3><a class="header" href="#refaktorierung-mit-strukturen-mehr-semantik" id="refaktorierung-mit-strukturen-mehr-semantik">Refaktorierung mit Strukturen: Mehr Semantik</a></h3>
<p>Verwenden wir Strukturen, um durch die Benennung der Daten deren Bedeutung
anzugeben. Wir können das verwendete Tupel in einen Datentyp mit einem Namen
für das Ganze sowie mit Namen für die Einzelteile umwandeln, wie in Codeblock
5-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        area(&amp;rect1)
    );
}

fn area(rectangle: &amp;Rectangle) -&gt; u32 {
    rectangle.width * rectangle.height
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-10: Definieren der Struktur <code>Rectangle</code></span></p>
<p>Hier haben wir eine Struktur definiert und sie <code>Rectangle</code> genannt. Innerhalb
der geschweiften Klammern haben wir die Felder <code>width</code> und <code>height</code> definiert,
die beide den Typ <code>u32</code> haben. Dann erzeugten wir in <code>main</code> eine Instanz von
<code>Rectangle</code> mit der Breite 30 und Höhe 50.</p>
<p>Unsere Funktion <code>area</code> hat nun einen Parameter, den wir <code>rectangle</code> genannt
haben und dessen Typ eine unveränderliche Ausleihe (immutable borrow) einer
Strukturinstanz <code>Rectangle</code> ist. Wie in Kapitel 4 erwähnt, wollen wir die
Struktur nur ausleihen, nicht aber deren Eigentümerschaft (ownership)
übernehmen. Auf diese Weise behält <code>main</code> seine Eigentümerschaft und kann
weiterhin <code>rect1</code> verwenden, weshalb wir <code>&amp;</code> in der Funktionssignatur und an
der Aufrufstelle verwenden.</p>
<p>Die Funktion <code>area</code> greift auf die Felder <code>width</code> und <code>height</code> der Instanz
<code>Rectangle</code> zu. Unsere Funktionssignatur für <code>area</code> sagt jetzt genau was wir
meinen: Berechne die Fläche von <code>Rectangle</code> unter Verwendung seiner Felder
<code>width</code> und <code>height</code>. Dies drückt aus, dass Breite und Höhe in Beziehung
zueinander stehen, und gibt den Werten beschreibende Namen, ohne die
Tupelindexwerte <code>0</code> und <code>1</code> zu verwenden. Das erhöht die Lesbarkeit.</p>
<h3><a class="header" href="#hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits" id="hilfreiche-funktionalität-mit-abgeleiteten-merkmalen-derived-traits">Hilfreiche Funktionalität mit abgeleiteten Merkmalen (derived traits)</a></h3>
<p>Es wäre schön, eine Instanz von <code>Rectangle</code> samt der Werte seiner Felder
ausgeben zu können, während wir unser Programm debuggen. In Codeblock 5-11
versuchen wir das Makro <code>println!</code> zu verwenden, das wir in den vorangegangenen
Kapiteln verwendet haben. Dies wird jedoch nicht funktionieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-11: Versuch, eine <code>Rectangle</code>-Instanz
auszugeben</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Display`
</code></pre>
<p>Das Makro <code>println!</code> kann diverse Formatierungen vornehmen. Die geschweiften
Klammern weisen <code>println!</code> an, die Formatierung <code>Display</code> zu verwenden, bei der
die Ausgabe direkt für den Endbenutzer bestimmt ist. Die primitiven Typen, die
wir bisher gesehen haben, implementieren <code>Display</code> standardmäßig, denn es gibt
nur eine Möglichkeit, dem Benutzer eine <code>1</code> oder einen anderen primitiven Typ
zu zeigen. Aber bei Strukturen ist die Formatierung, die <code>println!</code> verwenden
soll, weniger klar, da es mehrere Darstellungsmöglichkeiten gibt: Möchtest du
Kommas oder nicht? Möchtest du die geschweiften Klammern ausgeben? Sollen alle
Felder angezeigt werden? Aufgrund der vielen Möglichkeiten versucht Rust nicht
zu erraten, was wir wollen. Strukturen haben daher keine
Standardimplementierung von <code>Display</code>.</p>
<p>Wenn wir die Fehlerausgabe weiterlesen, werden wir diesen hilfreichen Hinweis
finden:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Display` is not implemented for `Rectangle`
   = note: in format strings you may be able to use `{:?}` (or {:#?} for pretty-print) instead
</code></pre>
<p>Lass es uns versuchen! Der Makroaufruf <code>println!</code> wird geändert in
<code>println!(&quot;rect1 ist {:?}&quot;, rect1);</code>. Wenn wir das Symbol <code>:?</code> innerhalb der
geschweiften Klammern angeben, teilen wir <code>println!</code> mit, dass wir das
Ausgabeformat <code>Debug</code> verwenden wollen. Das Merkmal <code>Debug</code> ermöglicht es, die
Struktur so auszugeben, dass Entwickler ihren Wert erkennen können, während sie
den Code debuggen.</p>
<p>Kompiliere den Code mit dieser Änderung. Verflixt! Wir erhalten immer noch
einen Fehler:</p>
<pre><code class="language-text">error[E0277]: `Rectangle` doesn't implement `std::fmt::Debug`
</code></pre>
<p>Aber auch hier gibt uns der Compiler einen hilfreichen Hinweis:</p>
<pre><code class="language-text">   = help: the trait `std::fmt::Debug` is not implemented for `Rectangle`
   = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
</code></pre>
<p>Rust enthält durchaus eine Funktionalität zum Ausgeben von Debug-Informationen,
aber wir müssen diese explizit für unsere Struktur aktivieren. Dazu fügen wir
die Annotation <code>#[derive(Debug)]</code> unmittelbar vor der Strukturdefinition ein,
wie in Codeblock 5-12 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(&quot;rect1 ist {:?}&quot;, rect1);
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-12: Annotation zum Verwenden des Merkmals
<code>Debug</code> und Ausgeben der Instanz <code>Rectangle</code> mittels Debug-Formatierung</span></p>
<p>Wenn wir das Programm nun ausführen, werden wir keinen Fehler mehr erhalten und
folgende Ausgabe sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle { width: 30, height: 50 }
</code></pre>
<p>Toll! Es ist nicht die schönste Ausgabe, aber sie zeigt die Werte aller Felder
dieser Instanz, was bei der Fehlersuche definitiv hilfreich ist. Bei größeren
Strukturen ist es hilfreich eine Ausgabe zu haben, die etwas leichter zu lesen
ist. In diesen Fällen können wir <code>{:#?}</code> anstelle von <code>{:?}</code> in der
<code>println!</code>-Meldung verwenden. Die Ausgabe sieht dann wie folgt aus:</p>
<pre><code class="language-console">$ cargo run
   Compiling structs v0.1.0 (file:///projects/structs)
    Finished dev [unoptimized + debuginfo] target(s) in 0.48s
     Running `target/debug/structs`
rect1 ist Rectangle {
    width: 30,
    height: 50,
}
</code></pre>
<p>Rust stellt uns eine Reihe von Merkmalen zur Verfügung, die wir mit der
Annotation <code>derive</code> verwenden können, um damit unseren benutzerdefinierten
Typen nützliches Verhalten zu verleihen. Diese Merkmale und ihr Verhalten sind
in Anhang C aufgeführt. In Kapitel 10 werden wir behandeln, wie man diese
Merkmale mit benutzerdefiniertem Verhalten implementiert und wie man eigene
Merkmale erstellt.</p>
<p>Unsere Funktion <code>area</code> ist sehr spezifisch: Sie berechnet nur die Fläche von
Rechtecken. Es wäre hilfreich, dieses Verhalten enger mit unserer Struktur
<code>Rectangle</code> zu verbinden, da es zu keinem anderen Typ passt. Schauen wir uns
an, wie wir den Code weiter umgestalten und unsere Funktion <code>area</code> in eine
<em>Methode</em> <code>area</code> unseres Typs <code>Rectangle</code> verwandeln können.</p>
<h2><a class="header" href="#methodensyntax" id="methodensyntax">Methodensyntax</a></h2>
<p><em>Methoden</em> sind Funktionen recht ähnlich: Sie werden mit dem Schlüsselwort <code>fn</code>
und ihrem Namen deklariert, sie können Parameter und einen Rückgabewert haben,
und sie enthalten etwas Code, der ausgeführt wird, wenn sie aufgerufen werden. 
Methoden unterscheiden sich jedoch von Funktionen dadurch, dass sie im Kontext
einer Struktur (struct) (oder einer Aufzählung (enum) oder eines
Merkmalsobjektes (trait object), die wir in Kapitel 6 und 17 behandeln)
definiert werden und ihr erster Parameter stets <code>self</code> ist. <code>self</code>
repräsentiert die Instanz der Struktur zu der die Methode aufgerufen wird.</p>
<h3><a class="header" href="#definieren-von-methoden" id="definieren-von-methoden">Definieren von Methoden</a></h3>
<p>Lass uns die Funktion <code>area</code>, die eine <code>Rectangle</code>-Instanz als Parameter hat,
ändern und stattdessen eine Methode <code>area</code> auf der Struktur <code>Rectangle</code>
definieren, wie in Codeblock 5-13 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        &quot;Die Fläche des Rechtecks ist {} Quadratpixel.&quot;,
        rect1.area()
    );
}
</code></pre></pre>
<p><span class="caption">Codeblock 5-13: Methode <code>area</code> der Struktur <code>Rectangle</code></span></p>
<p>Um die Funktion im Kontext von <code>Rectangle</code> zu definieren, beginnen wir mit dem
Block <code>impl</code> (Implementierung). Dann verschieben wir die Funktion <code>area</code> in die
geschweiften Klammern von <code>impl</code>, ändern den ersten (und in diesem Fall
einzigen) Parameter zu <code>self</code> und passen den Methodenrumpf entsprechend an. In 
<code>main</code>, wo wir die Funktion <code>area</code> aufrufen und <code>rect1</code> als Argument übergeben,
können wir stattdessen die <em>Methodensyntax</em> verwenden, um die Methode <code>area</code>
auf unserer <code>Rectangle</code>-Instanz aufzurufen. Die Methodensyntax bezieht sich auf
eine Instanz: Wir ergänzen einen Punkt, gefolgt vom Methodennamen, Klammern und
Argumenten.</p>
<p>In der Signatur von <code>area</code> verwenden wir <code>&amp;self</code> anstelle von
<code>rectangle: &amp;Rectangle</code>, denn Rust weiß, dass <code>self</code> den Typ <code>Rectangle</code> hat,
da die Methode innerhalb des Kontextes <code>impl Rectangle</code> liegt. Beachte, dass
wir immer noch das <code>&amp;</code> vor <code>self</code> verwenden müssen, so wie wir es bei
<code>&amp;Rectangle</code> getan haben. Methoden können die Eigentümerschaft von <code>self</code>
übernehmen, <code>self</code> unveränderlich ausleihen, wie wir es hier getan haben, oder
<code>self</code> veränderlich ausleihen, so wie bei jedem anderen Parameter auch.</p>
<p>Wir haben hier <code>&amp;self</code> aus dem gleichen Grund gewählt wie <code>&amp;Rectangle</code> in der
Funktionsvariante: Wir wollen keine Eigentümerschaft übernehmen, wir wollen die
Daten der Struktur nur lesen, nicht schreiben. Wenn wir die Instanzdaten ändern
wollten, müssten wir <code>&amp;mut self</code> als ersten Parameter verwenden. Es kommt nur
selten vor, dass eine Methode die Eigentümerschaft der Instanz übernimmt, indem
sie <code>self</code> als ersten Parameter verwendet. Diese Technik wird typischerweise
dann verwendet, wenn die Methode <code>self</code> in etwas anderes transformiert und man
verhindern will, dass der Aufrufer nach der Transformation die ursprüngliche
Instanz verwendet.</p>
<p>Der Hauptvorteil von Methoden gegenüber Funktionen liegt abgesehen davon, dass
bei jeder Methodendeklaration der Typ von <code>self</code> nicht ständig wiederholt
werden muss, in der Organisation. Wir haben alle Dinge, die wir mit einer
Instanz eines Typs tun können, in einen einzigen <code>impl</code> Block gepackt.
Zukünftige Nutzer unseres Codes müssen so nicht an verschiedenen Stellen in der
von uns bereitgestellten Bibliothek nach Fähigkeiten von <code>Rectangle</code> suchen.</p>
<blockquote>
<h3><a class="header" href="#wo-ist-der-operator--" id="wo-ist-der-operator--">Wo ist der Operator <code>-&gt;</code>?</a></h3>
<p>In C und C++ werden zwei verschiedene Operatoren für den Aufruf von Methoden
verwendet: Man verwendet <code>.</code>, wenn eine Methode direkt auf dem Objekt
aufgerufen wird, und <code>-&gt;</code>, wenn die Methode auf einem Zeiger auf das Objekt
aufrufen und der Zeiger zuerst dereferenziert werden muss. Anders gesagt,
wenn <code>object</code> ein Zeiger ist, ist <code>object-&gt;something()</code> ähnlich zu
<code>(*object).something()</code>.</p>
<p>Rust hat kein Äquivalent zum Operator <code>-&gt;</code>. Stattdessen hat Rust eine
Funktionalität namens <em>automatische Referenzierung und Dereferenzierung</em>
(automatic referencing and dereferencing). Der Aufruf von Methoden ist einer
der wenigen Orte in Rust, der dieses Verhalten aufweist.</p>
<p>Und so funktioniert es: Wenn du eine Methode mit <code>object.something()</code>
aufrufst, fügt Rust automatisch <code>&amp;</code>, <code>&amp;mut</code> oder <code>*</code> hinzu, sodass <code>object</code>
zur Signatur der Methode passt. Mit anderen Worten sind folgende Aufrufe
gleich:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">#[derive(Debug,Copy,Clone)]
</span><span class="boring">struct Point {
</span><span class="boring">    x: f64,
</span><span class="boring">    y: f64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Point {
</span><span class="boring">   fn distance(&amp;self, other: &amp;Point) -&gt; f64 {
</span><span class="boring">       let x_squared = f64::powi(other.x - self.x, 2);
</span><span class="boring">       let y_squared = f64::powi(other.y - self.y, 2);
</span><span class="boring">
</span><span class="boring">       f64::sqrt(x_squared + y_squared)
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">let p1 = Point { x: 0.0, y: 0.0 };
</span><span class="boring">let p2 = Point { x: 5.0, y: 6.5 };
</span>p1.distance(&amp;p2);
(&amp;p1).distance(&amp;p2);
<span class="boring">}
</span></code></pre></pre>
<p>Der erste Aufruf sieht viel sauberer aus. Die automatische Referenzierung
funktioniert, weil Methoden einen eindeutigen Empfänger haben - den Typ von
<code>self</code>. Wenn man den Empfänger und den Namen einer Methode angibt, kann Rust
eindeutig herausfinden, ob die Methode lesend (<code>&amp;self</code>), veränderlich
(<code>&amp;mut self</code>) oder konsumierend (<code>self</code>) ist. Die Tatsache, dass Rust das
Ausleihen für die Methodenempfänger implizit macht, ist ein großer Beitrag
zur Ergonomie der Eigentümerschaft in der Praxis.</p>
</blockquote>
<h3><a class="header" href="#methoden-mit-mehreren-parametern" id="methoden-mit-mehreren-parametern">Methoden mit mehreren Parametern</a></h3>
<p>Lass uns den Umgang mit Methoden üben, indem wir eine zweite Methode zur
Struktur <code>Rectangle</code> implementieren. Diesmal soll eine zweite Instanz von
<code>Rectangle</code> entgegengenommen und <code>true</code> zurückgeben werden, wenn das zweite
<code>Rectangle</code> vollständig in <code>self</code> hineinpasst; andernfalls soll <code>false</code>
zurückgegeben werden. Das heißt, wir wollen in der Lage sein, das in Codeblock
5-14 gezeigte Programm zu schreiben, sobald wir die Methode <code>can_hold</code>
definiert haben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };
    let rect2 = Rectangle {
        width: 10,
        height: 40,
    };
    let rect3 = Rectangle {
        width: 60,
        height: 45,
    };

    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
}
</code></pre>
<p><span class="caption">Codeblock 5-14: Verwendung der noch nicht geschriebenen
Methode <code>can_hold</code></span></p>
<p>Die erwartete Ausgabe würde wie folgt aussehen, da beide Dimensionen von
<code>rect2</code> kleiner als die Dimensionen von <code>rect1</code> sind, aber <code>rect3</code> breiter als
<code>rect1</code> ist:</p>
<pre><code class="language-text">Umfasst rect1 rect2? true
Umfasst rect1 rect3? false
</code></pre>
<p>Wir wissen, dass wir eine Methode definieren wollen, also wird sie innerhalb
des Blocks <code>impl Rectangle</code> liegen. Die Methode wird <code>can_hold</code> heißen und sie
wird einen weiteren Parameter vom Typ <code>Rectangle</code> unveränderlich ausleihen. Wir
können den Typ des Parameters erkennen, indem wir uns den Code ansehen, der die
Methode aufruft: <code>rect1.can_hold(&amp;rect2)</code> nimmt <code>&amp;rect2</code> entgegen, also eine
unveränderliche Ausleihe von <code>rect2</code> vom Typ <code>Rectangle</code>. Das macht Sinn, da
wir <code>rect2</code> nur lesen müssen (anstatt zu schreiben, wofür wir eine
veränderliche Ausleihe bräuchten) und <code>main</code> die Eigentümerschaft an <code>rect2</code>
zurückerhalten soll, so dass wir es nach dem Aufruf der Methode <code>can_hold</code>
weiter verwenden können. Der Rückgabewert von <code>can_hold</code> ist ein boolescher
Wert und die Implementierung prüft, ob Breite und Höhe von <code>self</code> jeweils
größer als von <code>Rectangle</code> sind. Fügen wir die neue Methode <code>can_hold</code> zum
Block <code>impl</code> aus Codeblock 5-13 hinzu, wie in Codeblock 5-15 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-15: Implementierung der Methode <code>can_hold</code>
auf <code>Rectangle</code>, die eine weitere <code>Rectangle</code>-Instanz als Parameter hat</span></p>
<p>Wenn wir diesen Code mit der Funktion <code>main</code> in Codeblock 5-14 ausführen,
erhalten wir die gewünschte Ausgabe. Methoden können mehrere Parameter haben,
die wir in der Signatur nach dem Parameter <code>self</code> angeben. Diese Parameter
funktionieren genau wie Parameter in Funktionen.</p>
<h3><a class="header" href="#assoziierte-funktionen" id="assoziierte-funktionen">Assoziierte Funktionen</a></h3>
<p>Eine weitere nützliche Funktionalität von <code>impl</code>-Blöcken ist, dass wir darin
auch Funktionen <em>ohne</em> den Parameter <code>self</code> definieren können. Diese werden
<em>assoziierte Funktionen</em> (associated functions) genannt, weil sie mit der
Struktur assoziiert sind. Dabei handelt es sich um Funktionen, nicht um
Methoden, weil sie nicht auf einer Instanz der Struktur arbeiten können. Du
hast bereits die assoziierte Funktion <code>String::from</code> verwendet.</p>
<p>Assoziierte Funktionen werden oft als Konstruktoren verwendet, die eine neue
Instanz der Struktur zurückgeben. Zum Beispiel könnten wir eine assoziierte
Funktion bereitstellen, die einen eindimensionalen Parameter hat und diesen
sowohl als Breite als auch als Höhe verwendet, wodurch auf einfache Weise ein
quadratisches <code>Rectangle</code> erzeugt werden kann, ohne denselben Wert zweimal
angeben zu müssen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn square(size: u32) -&gt; Rectangle {
        Rectangle {
            width: size,
            height: size,
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let sq = Rectangle::square(3);
</span><span class="boring">}
</span></code></pre></pre>
<p>Um diese assoziierte Funktion aufzurufen, verwenden wir die Syntax <code>::</code> mit dem
Strukturnamen, z.B. <code>let sq = Rectangle::square(3);</code>. Diese Funktion gehört zum
Namensraum der Struktur: Die Syntax <code>::</code> wird sowohl für assoziierte Funktionen
als auch für Namensräume, die von Modulen erzeugt werden, verwendet. Wir werden
die Module in Kapitel 7 besprechen.</p>
<h3><a class="header" href="#mehrere-impl-blöcke" id="mehrere-impl-blöcke">Mehrere <code>impl</code>-Blöcke</a></h3>
<p>Jede Struktur darf mehrere <code>impl</code>-Blöcke haben. Beispielsweise entspricht
Codeblock 5-15 dem in Codeblock 5-16 gezeigten Code, bei dem jede Methode in
einem eigenen <code>impl</code>-Block steht.</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let rect1 = Rectangle {
</span><span class="boring">        width: 30,
</span><span class="boring">        height: 50,
</span><span class="boring">    };
</span><span class="boring">    let rect2 = Rectangle {
</span><span class="boring">        width: 10,
</span><span class="boring">        height: 40,
</span><span class="boring">    };
</span><span class="boring">    let rect3 = Rectangle {
</span><span class="boring">        width: 60,
</span><span class="boring">        height: 45,
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!(&quot;Umfasst rect1 rect2? {}&quot;, rect1.can_hold(&amp;rect2));
</span><span class="boring">    println!(&quot;Umfasst rect1 rect3? {}&quot;, rect1.can_hold(&amp;rect3));
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 5-16: Neuschreiben von Codeblock 5-15 unter
Verwendung mehrerer <code>impl</code>-Blöcke</span></p>
<p>Es ist nicht nötig, diese Methoden hier auf mehrere <code>impl</code>-Blöcke zu verteilen,
aber es handelt sich um eine gültige Syntax. Wir werden in Kapitel 10 einen
Fall sehen, bei dem mehrere <code>impl</code>-Blöcke hilfreich sind, wenn wir generische
Typen und Merkmale behandeln.</p>
<h2><a class="header" href="#zusammenfassung-1" id="zusammenfassung-1">Zusammenfassung</a></h2>
<p>Mit Strukturen kannst du benutzerdefinierte Typen erstellen, die in deiner
Domäne eine Bedeutung haben. Durch die Verwendung von Strukturen kannst du
zusammengehörige Datenteile miteinander verbunden halten und jedes Teil
benennen, um deinen Code verständlich zu machen. Mit Methoden kannst du das
Verhalten von Instanzen deiner Strukturen spezifizieren und mit assoziierten
Funktionen kannst du Funktionalität zum Namensraum deiner Struktur hinzufügen,
die ohne Instanz auskommen.</p>
<p>Aber Strukturen sind nicht die einzige Möglichkeit, benutzerdefinierte Typen zu
definieren: Wenden wir uns der Rust-Funktionalität Aufzählung zu, um ein
weiteres Werkzeug in deinen Werkzeugkasten zu legen.</p>
<h1><a class="header" href="#aufzählungen-enums-und-musterabgleich-pattern-matching" id="aufzählungen-enums-und-musterabgleich-pattern-matching">Aufzählungen (enums) und Musterabgleich (pattern matching)</a></h1>
<p>In diesem Kapitel werden wir uns mit <em>Aufzählungen</em> (enumerations, kurz: enums)
befassen. Aufzählungen erlauben es, einen Typ durch Aufzählung seiner möglichen
<em>Varianten</em> (variants) zu definieren. Zuerst werden wir eine Aufzählung
definieren und verwenden, um zu zeigen, wie eine Aufzählung mit Daten eine
Bedeutung kodieren kann. Als Nächstes werden wir eine besonders nützliche
Aufzählung untersuchen, die <code>Option</code> genannt wird und zum Ausdruck bringt, dass
ein Wert entweder etwas oder nichts sein kann. Dann sehen wir uns an, wie man
mit dem Musterabgleich (pattern matching) im Ausdruck <code>match</code> auf einfache
Weise unterschiedlichen Code für verschiedene Werte einer Aufzählung
auszuführen kann. Schließlich werden wir uns mit dem Konstrukt <code>if let</code>
befassen, einem weiteren bequemen und prägnanten Idiom, das dir zur Verfügung
steht, um mit Aufzählungen in deinem Code umzugehen.</p>
<p>Aufzählungen sind eine Funktionalität in vielen Sprachen, aber deren
Möglichkeiten unterscheiden sich in jeder Sprache. Rusts Aufzählungen sind den
<em>algebraischen Datentypen</em> in funktionalen Sprachen wie F#, OCaml und Haskell
am ähnlichsten.</p>
<h2><a class="header" href="#eine-aufzählung-enum-definieren" id="eine-aufzählung-enum-definieren">Eine Aufzählung (enum) definieren</a></h2>
<p>Schauen wir uns eine Situation an, die wir mit Code ausdrücken wollen, bei der
Aufzählungen (enums) nützlich und geeigneter sind als Strukturen (structs).
Angenommen, wir müssen mit IP-Adressen arbeiten. Aktuell werden zwei
Hauptstandards für IP-Adressen verwendet: Version vier und Version sechs. Das
sind die einzigen Möglichkeiten einer IP-Adresse, mit denen unser Programm zu
tun haben wird: Wir können alle möglichen Varianten <em>aufzählen</em>, daher auch der
Name der Aufzählung.</p>
<p>Jede IP-Adresse kann entweder eine Adresse der Version vier oder der Version
sechs sein, aber nicht beides gleichzeitig. Diese Eigenschaft der IP-Adressen
passt zur Aufzählungs-Datenstruktur, da Aufzählungswerte nur eine ihrer
Varianten sein können. Sowohl die Adressen der Version vier als auch der
Version sechs sind grundsätzlich immer noch IP-Adressen, so dass sie als der
gleiche Typ behandelt werden sollten, wenn der Code mit Situationen zu tun hat,
die für beide IP-Adressenarten gelten.</p>
<p>Wir können dieses Konzept im Code ausdrücken, indem wir eine Aufzählung
<code>IpAddrKind</code> definieren und die möglichen Varianten auflisten, die eine
IP-Adresse haben kann, <code>V4</code> und <code>V6</code>. Hier die Varianten der Aufzählung:</p>
<pre><pre class="playpen"><code class="language-rust">enum IpAddrKind {
    V4,
    V6,
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p><code>IpAddrKind</code> ist jetzt ein benutzerdefinierter Datentyp, den wir an anderer
Stelle in unserem Code verwenden können.</p>
<h3><a class="header" href="#werte-in-aufzählungen" id="werte-in-aufzählungen">Werte in Aufzählungen</a></h3>
<p>Wir können Instanzen von beiden Varianten von <code>IpAddrKind</code> wie folgt erstellen:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let four = IpAddrKind::V4;
    let six = IpAddrKind::V6;
<span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Beachte, dass die Varianten der Aufzählung mit dem Namensraum des Bezeichners
angegeben sind und wir einen doppelten Doppelpunkt verwenden, um die beiden zu
trennen. Das ist sinnvoll, weil beide Werte <code>IpAddrKind::V4</code> und
<code>IpAddrKind::V6</code> vom gleichen Typ sind: <code>IpAddrKind</code>. Wir können dann zum
Beispiel eine Funktion definieren, die jedes <code>IpAddrKind</code> annimmt:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span><span class="boring">    route(IpAddrKind::V4);
</span><span class="boring">    route(IpAddrKind::V6);
</span><span class="boring">}
</span><span class="boring">
</span>fn route(ip_kind: IpAddrKind) {}
</code></pre></pre>
<p>Und wir können diese Funktion mit beiden Varianten aufrufen:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum IpAddrKind {
</span><span class="boring">    V4,
</span><span class="boring">    V6,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let four = IpAddrKind::V4;
</span><span class="boring">    let six = IpAddrKind::V6;
</span><span class="boring">
</span>    route(IpAddrKind::V4);
    route(IpAddrKind::V6);
<span class="boring">}
</span><span class="boring">
</span><span class="boring">fn route(ip_kind: IpAddrKind) {}
</span></code></pre></pre>
<p>Aufzählungen haben noch weitere Vorteile. Wenn wir weiter über unseren
IP-Adresstyp nachdenken, haben wir im Moment keine Möglichkeit, den <em>Wert</em> der
tatsächlichen IP-Adresse zu speichern; wir wissen nur, um welche <em>Variante</em> es
sich handelt. Mit dem was du gerade erst in Kapitel 5 über Strukturen gelernt
hast, könntest du dieses Problem wie in Codeblock 6-1 dargestellt angehen.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddrKind {
    V4,
    V6,
}

struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

let home = IpAddr {
    kind: IpAddrKind::V4,
    address: String::from(&quot;127.0.0.1&quot;),
};

let loopback = IpAddr {
    kind: IpAddrKind::V6,
    address: String::from(&quot;::1&quot;),
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-1: Speichern des Wertes und der
<code>IpAddrKind</code>-Variante einer IP-Adresse mittels <code>struct</code></span></p>
<p>Hier haben wir eine Struktur <code>IpAddr</code> definiert, die zwei Felder hat:  Ein Feld
<code>kind</code> vom Typ <code>IpAddrKind</code> (die zuvor definierte Aufzählung) und ein Feld
<code>address</code> vom Typ <code>String</code>. Wir haben zwei Instanzen dieser Struktur erzeugt.
Die erste, <code>home</code>, hat die Variante <code>IpAddrKind::V4</code> und die zugehörige Adresse
<code>127.0.0.1</code>. Die zweite Instanz, <code>loopback</code>, hat die Variante <code>V6</code> von
<code>IpAddrKind</code> als ihren Wert für <code>kind</code> und die zugehörige Adresse <code>::1</code>. Wir
haben eine Struktur verwendet, um die Werte <code>kind</code> und <code>address</code> zu bündeln, so
dass jetzt die Variante mit dem Wert verbunden ist.</p>
<p>Wir können dasselbe Konzept prägnanter darstellen, indem wir nur eine
Aufzählung, anstelle einer Aufzählung innerhalb einer Struktur, verwenden,
indem wir Daten direkt in jede Aufzählungsvariante einfügen. Diese neue
Definition der Aufzählung <code>IpAddr</code> legt fest, dass sowohl die Variante <code>V4</code> als
auch <code>V6</code> zugehörige <code>String</code>-Werte haben:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(String),
    V6(String),
}

let home = IpAddr::V4(String::from(&quot;127.0.0.1&quot;));

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Wir hängen die Daten direkt an jede Variante der Aufzählung an, so dass keine
zusätzliche Struktur erforderlich ist.</p>
<p>Es gibt noch einen weiteren Vorteil, eine Aufzählung statt einer Struktur zu
verwenden: Jede Variante kann verschiedene Typen und verschieden viele
zugehöriger Daten haben. IP-Adressen der Version vier haben stets vier
numerische Komponenten, die Werte zwischen 0 und 255 haben. Wenn wir
<code>V4</code>-Adressen als vier <code>u8</code>-Werte speichern und <code>V6</code>-Adressen als einen
<code>String</code>-Wert ausdrücken wollten, wäre das mit einer Struktur nicht möglich.
Aufzählungen lösen diesen Fall ganz einfach:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum IpAddr {
    V4(u8, u8, u8, u8),
    V6(String),
}

let home = IpAddr::V4(127, 0, 0, 1);

let loopback = IpAddr::V6(String::from(&quot;::1&quot;));
<span class="boring">}
</span></code></pre></pre>
<p>Wir haben verschiedene Möglichkeiten zur Definition von Datenstrukturen
gezeigt, die Version vier und sechs einer IP-Adresse speichern können.
Wie sich jedoch herausstellt, ist der Wunsch, IP-Adressen inklusive deren
Variante zu speichern, so verbreitet, dass <a href="https://doc.rust-lang.org/std/net/enum.IpAddr.html">die Standardbibliothek eine
Definition bereitstellt</a>, die wir verwenden können! Schauen wir uns an,
wie die Standardbibliothek <code>IpAddr</code> definiert: Es hat genau die Aufzählung und
die Varianten, die wir definiert und verwendet haben, aber es bettet die
Adressdaten innerhalb der Varianten in Form von zwei verschiedenen Strukturen
ein, die für jede Variante unterschiedlich definiert sind:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>struct Ipv4Addr {
    // --snip--
}

struct Ipv6Addr {
    // --snip--
}

enum IpAddr {
    V4(Ipv4Addr),
    V6(Ipv6Addr),
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code veranschaulicht, dass du jede Art von Daten in eine
Aufzählungsvariante einfügen kannst: Zeichenketten, numerische Typen,
Strukturen usw. Du kannst sogar eine weitere Aufzählung einfügen! Außerdem sind
Standardbibliothekstypen oft nicht viel komplizierter als das, was du dir
vielleicht ausdenkst. Beachte, dass wir, obwohl die Standardbibliothek eine
Definition für <code>IpAddr</code> enthält, konfliktfrei unsere eigene Definition
erstellen und verwenden können, da wir die Definition der Standardbibliothek
nicht in unseren Gültigkeitsbereich aufgenommen haben. Wir werden in Kapitel 7
mehr darauf eingehen, wie man Typen in den Gültigkeitsbereich aufnimmt.</p>
<p>Schauen wir uns ein weiteres Beispiel für eine Aufzählung in Codeblock 6-2 an:
In dieser Aufzählung ist eine Vielzahl von Typen in ihren Varianten eingebettet.</p>
<pre><pre class="playpen"><code class="language-rust">enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-2: Eine Aufzählung <code>Message</code>, deren Varianten
jeweils eine unterschiedliche Anzahl an Werttypen speichern</span></p>
<p>Diese Aufzählung hat vier Varianten mit unterschiedlichen Typen:</p>
<ul>
<li><code>Quit</code> hat überhaupt keine Daten.</li>
<li><code>Move</code> enthält eine anonyme Struktur.</li>
<li><code>Write</code> enthält einen einzelnen <code>String</code>.</li>
<li><code>ChangeColor</code> enthält drei <code>i32</code>-Werte.</li>
</ul>
<p>Die Definition einer Aufzählung mit Varianten wie in Codeblock 6-2 ist ähnlich
zur Definition verschiedener Arten von Strukturdefinitionen, außer dass die
Aufzählung nicht das Schlüsselwort <code>struct</code> verwendet und alle Varianten unter
dem Typ <code>Message</code> zusammengefasst sind. Die folgenden Strukturen könnten die
gleichen Daten aufnehmen wie die vorhergehenden Aufzählungsvarianten:</p>
<pre><pre class="playpen"><code class="language-rust">struct QuitMessage; // leere Struktur
struct MoveMessage {
    x: i32,
    y: i32,
}
struct WriteMessage(String); // Tupelstruktur
struct ChangeColorMessage(i32, i32, i32); // Tupelstruktur
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Aber wenn wir die verschiedenen Strukturen verwenden würden, die jeweils ein
eigener Typ sind, könnten wir nicht so einfach eine Funktion definieren, die
eine dieser Nachrichtenarten entgegennimmt, wie wir es mit der in Codeblock 6-2
definierten Aufzählung <code>Message</code> gemacht haben, bei der es sich um einen
einzigen Typ handelt.</p>
<p>Es gibt noch eine weitere Ähnlichkeit zwischen Aufzählungen und Strukturen: So
wie wir Methoden für Strukturen mit <code>impl</code> definieren können, können wir auch
Methoden für Aufzählungen definieren. Hier ist eine Methode namens <code>call</code>, die
wir für unsere Aufzählung <code>Message</code> definieren könnten:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    enum Message {
</span><span class="boring">        Quit,
</span><span class="boring">        Move { x: i32, y: i32 },
</span><span class="boring">        Write(String),
</span><span class="boring">        ChangeColor(i32, i32, i32),
</span><span class="boring">    }
</span><span class="boring">
</span>    impl Message {
        fn call(&amp;self) {
            // Methodenrumpf
        }
    }

    let m = Message::Write(String::from(&quot;hallo&quot;));
    m.call();
<span class="boring">}
</span></code></pre></pre>
<p>Der Methodenrumpf würde <code>self</code> benutzen, um den Wert zu erhalten, auf den wir
die Methode aufgerufen haben. In diesem Beispiel haben wir eine Variable <code>m</code>
erstellt, die den Wert <code>Message::Write(String::from(&quot;hallo&quot;))</code> hat. Genau
diesen Wert wird <code>self</code> im Rumpf der Methode <code>call</code> haben, wenn <code>m.call()</code>
ausgeführt wird.</p>
<p>Sehen wir uns eine weitere Aufzählung in der Standardbibliothek an, die sehr
verbreitet und hilfreich ist: <code>Option</code></p>
<h3><a class="header" href="#die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten" id="die-aufzählung-option-und-ihre-vorteile-gegenüber-nullwerten">Die Aufzählung <code>Option</code> und ihre Vorteile gegenüber Nullwerten</a></h3>
<p>Im vorigen Abschnitt haben wir uns angesehen, wie es die Aufzählung <code>IpAddr</code>
ermöglicht, Rusts Typsystem zu verwenden, um mehr Informationen als nur die
Daten in unserem Programm zu kodieren. Dieser Abschnitt befasst sich mit einer
Fallstudie zu <code>Option</code>, einer weiteren Aufzählung, die von der
Standardbibliothek definiert wird. Der Typ <code>Option</code> wird an vielen Stellen
verwendet, weil er das sehr häufige Szenario abbildet, in dem ein Wert etwas
oder nichts sein könnte. Im Sinne des Typsystems bedeutet das, dass der
Kompilierer überprüfen kann, ob du alle Fälle behandelt hast, die du behandelt
sollst. Diese Funktionalität kann Fehler vermeiden, die in anderen
Programmiersprachen extrem häufig auftreten.</p>
<p>Bei der Entwicklung von Programmiersprachen wird oft überlegt, welche
Funktionalität aufgenommen werden soll, aber auch die auszuschließende
Funktionalität ist wichtig. Rust hat nicht die Funktionalität „null“, die es in
vielen anderen Sprachen gibt. <em>Null</em> ist ein Wert, der bedeutet, dass kein Wert
vorhanden ist. In Sprachen mit null können sich Variablen immer in einem von
zwei Zuständen befinden: null oder nicht null.</p>
<p>In seinem Vortrag „Nullreferenzen: Der milliardenschwere Fehler“ von 2009 hat
Tony Hoare, der Erfinder von null, folgendes gesagt:</p>
<blockquote>
<p>Ich nenne es meinen milliardenschweren Fehler. Zu dieser Zeit entwarf ich das
erste umfangreiche Typsystem für Referenzen in einer objektorientierten
Sprache. Mein Ziel war es, sicherzustellen, dass jede Verwendung von
Referenzen absolut sicher sein sollte, wobei die Überprüfung automatisch
durch den Kompilierer durchgeführt wird. Aber ich konnte der Versuchung nicht
widerstehen, eine Nullreferenz einzuführen, nur weil sie so einfach
umzusetzen war. Dies hat zu unzähligen Fehlern, Schwachstellen und
Systemabstürzen geführt, die in den letzten vierzig Jahren wahrscheinlich
eine Milliarde Dollar Schmerz und Schaden verursacht haben.</p>
</blockquote>
<p>Das Problem mit Nullwerten besteht darin, dass du einen Fehler erhältst, wenn
du versuchst, einen Nullwert als Nicht-Nullwert zu verwenden. Da diese Null-
oder Nicht-Null-Eigenschaft allgegenwärtig ist, ist es extrem einfach, einen
derartigen Fehler zu machen.</p>
<p>Das Konzept, das die Null zum Ausdruck bringen will, ist jedoch nach wie vor
nützlich: Null ist ein Wert, der aktuell ungültig ist oder aus irgendeinem
Grund nicht vorhanden ist.</p>
<p>Das Problem liegt nicht wirklich im Konzept, sondern in der konkreten
Umsetzung. Als solches hat Rust keine Nullen, aber es hat eine Aufzählung, die
das Konzept des Vorhandenseins oder Nichtvorhandenseins eines Wertes abbilden
kann. Diese Aufzählung heißt <code>Option&lt;T&gt;</code> und ist
<a href="https://doc.rust-lang.org/std/option/enum.Option.html">in der Standardbibliothek</a> wie folgt definiert:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Aufzählung <code>Option&lt;T&gt;</code> ist so nützlich, dass sie sogar im Präludium
enthalten ist; du musst sie nicht explizit in den Anwendungsbereich aufnehmen.
Dasselbe gilt für ihre Varianten: Du kannst <code>Some</code> und <code>None</code> direkt ohne
Präfix <code>Option::</code> verwenden. Die Aufzählung <code>Option&lt;T&gt;</code> ist dennoch nur eine
normale Aufzählung, und <code>Some(T)</code> und <code>None</code> sind nur Varianten des Typs
<code>Option&lt;T&gt;</code>.</p>
<p>Die Syntax <code>&lt;T&gt;</code> ist eine Funktionalität von Rust, über die wir noch nicht
gesprochen haben. Es handelt sich um einen generischen Typparameter, auf den
wir in Kapitel 10 näher eingehen werden. Für den Moment musst du nur wissen,
dass <code>&lt;T&gt;</code> bedeutet, dass die Variante <code>Some</code> der Aufzählung <code>Option</code> einen
Wert eines beliebigen Typs enthalten kann. Hier sind einige Beispiele für die
Verwendung von <code>Option</code>-Werten zur Aufnahme von Zahlentypen und
Zeichenkettentypen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_number = Some(5);
let some_string = Some(&quot;eine Zeichenkette&quot;);

let absent_number: Option&lt;i32&gt; = None;
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir <code>None</code> anstelle von <code>Some</code> verwenden, müssen wir Rust sagen, welchen
Typ von <code>Option&lt;T&gt;</code> wir haben, weil der Compiler nicht auf den Typ schließen
kann, den die Variante <code>Some</code> haben soll, wenn er nur einen Wert <code>None</code> sieht.</p>
<p>Wenn wir einen Wert <code>Some</code> haben, wissen wir, dass ein Wert vorhanden ist und
der Wert innerhalb von <code>Some</code> gehalten wird. Wenn wir einen Wert <code>None</code> haben,
bedeutet das in gewisser Weise dasselbe wie Null: Wir haben keinen gültigen
Wert. Warum ist nun besser <code>Option&lt;T&gt;</code> anstelle von Null zu verwenden?</p>
<p>Kurz gesagt, weil <code>Option&lt;T&gt;</code> und <code>T</code> (wobei <code>T</code> ein beliebiger Typ sein kann)
unterschiedliche Typen sind, erlaubt es der Kompilierer nicht <code>Option&lt;T&gt;</code> so zu
verwenden als wäre es definitiv ein gültiger Wert. Beispielsweise lässt sich
dieser Code nicht kompilieren, weil er versucht, ein <code>i8</code> mit einem
<code>Option&lt;i8&gt;</code> zu addieren:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let x: i8 = 5;
let y: Option&lt;i8&gt; = Some(5);

let sum = x + y;
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir diesen Code ausführen, erhalten wir eine Fehlermeldung wie diese:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0277]: cannot add `std::option::Option&lt;i8&gt;` to `i8`
 --&gt; src/main.rs:5:17
  |
5 |     let sum = x + y;
  |                 ^ no implementation for `i8 + std::option::Option&lt;i8&gt;`
  |
  = help: the trait `std::ops::Add&lt;std::option::Option&lt;i8&gt;&gt;` is not implemented for `i8`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Stark! Tatsächlich bedeutet diese Fehlermeldung, dass Rust nicht versteht, wie
man ein <code>i8</code> und eine <code>Option&lt;i8&gt;</code> addiert, da es sich um unterschiedliche Typen
handelt. Wenn wir einen Wert eines Typs wie <code>i8</code> in Rust haben, stellt der
Kompilierer sicher, dass wir immer einen gültigen Wert haben. Wir können mit
Zuversicht vorgehen, ohne vor der Verwendung dieses Wertes auf Null prüfen zu
müssen. Nur wenn wir eine <code>Option&lt;i8&gt;</code> (oder einen anderen Werttyp) haben,
müssen wir befürchten, dass wir möglicherweise keinen Wert haben, und der
Kompilierer wird sicherstellen, dass wir diesen Fall behandeln, bevor wir den
Wert verwenden.</p>
<p>Mit anderen Worten musst du eine <code>Option&lt;T&gt;</code> in ein <code>T</code> konvertieren, bevor du
<code>T</code>-Operationen damit durchführen kannst. Im Allgemeinen hilft dies, eines der
häufigsten Probleme mit Null abzufangen: Anzunehmen, dass etwas nicht null ist,
obwohl es tatsächlich null ist.</p>
<p>Wenn du dir keine Sorgen machen musst, dass fälschlicherweise ein
Nicht-Null-Wert angenommen wird, hilft dir das mehr Vertrauen in deinen Code zu
haben. Um einen Wert zu haben, der möglicherweise null sein kann, musst du dich
explizit dafür entscheiden, indem du als Typ <code>Option&lt;T&gt;</code> verwendest. Wenn du
dann diesen Wert verwendest, musst du den Fall null explizit behandeln. Überall
dort, wo ein Wert nicht den Typ <code>Option&lt;T&gt;</code> hat, kannst du <em>sicher</em> sein, dass
der Wert nicht null ist. Dies war eine bewusste Konstruktionsentscheidung bei 
Rust, um die Verbreitung von Null einzuschränken und die Sicherheit von
Rust-Code zu erhöhen.</p>
<p>Wie erhältst du nun den <code>T</code>-Wert aus einer Variante <code>Some</code>, wenn du einen Wert
vom Typ <code>Option&lt;T&gt;</code> hast? Die Aufzählung <code>Option&lt;T&gt;</code> enthält eine große Anzahl
von Methoden, die in einer Vielzahl von Situationen nützlich sind; mehr dazu
findest du in <a href="https://doc.rust-lang.org/std/option/enum.Option.html">der Dokumentation</a>. Sich mit den Methoden von <code>Option&lt;T&gt;</code>
vertraut zu machen, wird dir auf deiner Reise mit Rust äußerst nützlich sein.</p>
<p>Um einen <code>Option&lt;T&gt;</code>-Wert zu verwenden, benötigst du im Allgemeinen Code, der
jede Variante behandelt. Du möchtest einen Code, der nur läuft, wenn du einen
Wert <code>Some(T)</code> hast, und dieser Code darf das innere <code>T</code> benutzen. Du möchtest,
dass ein anderer Code ausgeführt wird, wenn du einen Wert <code>None</code> hast, und
dieser Code hat keinen <code>T</code>-Wert. Der Ausdruck <code>match</code> ist ein
Kontrollflusskonstrukt, das genau dies tut, wenn es mit Aufzählungen verwendet
wird: Es führt unterschiedlichen Code aus, je nachdem, welche Variante der
Aufzählung es hat, und dieser Code kann die Daten innerhalb des passenden
Wertes verwenden.</p>
<h2><a class="header" href="#der-kontrollflussoperator-match" id="der-kontrollflussoperator-match">Der Kontrollflussoperator <code>match</code></a></h2>
<p>Rust verfügt über einen extrem leistungsfähigen Kontrollflussoperator namens
<code>match</code>, der es dir ermöglicht, einen Wert mit einer Reihe von Mustern
abzugleichen und dann Code zum jeweils passenden Muster auszuführen. Muster
können sich aus Literalen, Variablennamen, Platzhaltern und vielen anderen
Dingen zusammensetzen. Kapitel 18 befasst sich mit all den verschiedenen
Musterarten und wie sie funktionieren. Die Mächtigkeit von <code>match</code> kommt von
der Ausdruckskraft der Muster und der Tatsache, dass der Kompilierer
sicherstellt, dass alle möglichen Fälle behandelt werden.</p>
<p>Stelle dir einen <code>match</code>-Ausdruck wie eine Münzsortiermaschine vor:  Die Münzen
rutschen eine Bahn mit unterschiedlich großen Löchern entlang, und jede Münze
fällt durch das erste Loch, in das sie hineinpasst. Auf die gleiche Weise
durchlaufen die Werte die Muster in einem <code>match</code>-Ausdruck und beim ersten
„passenden“ Muster fällt der Wert in den zugehörigen Codeblock, der ausgeführt
werden soll.</p>
<p>Da wir eben Münzen erwähnt haben, nehmen wir sie als Beispiel für die
Verwendung von <code>match</code>! Wir können eine Funktion schreiben, die eine unbekannte
Münze der Vereinigten Staaten nimmt und, ähnlich wie die Zählmaschine,
bestimmt, um welche Münze es sich handelt und ihren Wert in Cent zurückgibt,
wie hier in Codeblock 6-3 gezeigt.</p>
<pre><pre class="playpen"><code class="language-rust">enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter,
}

fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-3: Eine Aufzählung und ein <code>match</code>-Ausdruck,
der die Varianten der Aufzählung als Muster hat</span></p>
<p>Lass uns den <code>match</code>-Ausdruck in der Funktion <code>value_in_cents</code> aufschlüsseln. 
Zuerst geben wir das Schlüsselwort <code>match</code> an, gefolgt von einem Ausdruck, der
in diesem Fall der Wert <code>coin</code> ist. Dies scheint einem Ausdruck sehr ähnlich zu
sein, der bei <code>if</code> verwendet wird, aber es gibt einen großen Unterschied: Bei
<code>if</code> muss der Ausdruck einen booleschen Wert zurückgeben, aber hier kann es
sich um einen beliebigen Typ handeln. Der Typ von <code>coin</code> ist in diesem Beispiel
die Aufzählung <code>Coin</code>, die wir in Zeile 1 definiert haben.</p>
<p>Als nächstes kommen die <code>match</code>-Zweige. Ein Zweig hat zwei Teile: Ein Muster
und etwas Code. Der erste Zweig hat als Muster den Wert <code>Coin::Penny</code>, dann den
Operator <code>=&gt;</code>, der das Muster und den auszuführenden Code trennt. Der Code ist
in diesem Fall nur der Wert <code>1</code>. Jeder Zweig wird durch ein Komma vom nächsten
getrennt.</p>
<p>Wenn der <code>match</code>-Ausdruck ausgeführt wird, gleicht er den resultierenden Wert
mit dem Muster jedes Zweigs ab, und zwar der Reihe nach. Wenn ein Muster zum
Wert passt, wird der zu diesem Muster gehörende Code ausgeführt. Wenn das
Muster nicht zum Wert passt, wird die Ausführung beim nächsten Zweig
fortgesetzt, ähnlich wie bei einer Münzsortiermaschine. Wir können so viele
Zweige haben, wie wir brauchen: In Codeblock 6-3 hat unser <code>match</code>-Ausdruck
vier Zweige.</p>
<p>Der zu jedem Zweig gehörende Code ist ein Ausdruck, und der resultierende Wert
des Ausdrucks im zugehörenden Zweig ist der Wert, der für den gesamten
<code>match</code>-Ausdruck zurückgegeben wird. </p>
<p>Geschweifte Klammern werden in der Regel nicht verwendet, wenn der Zweig-Code
kurz ist, so wie in Codeblock 6-3, wo jeder Zweig nur einen Wert zurückgibt.
Wenn du mehrere Codezeilen in einem Zweig ausführen möchtest, kannst du
geschweifte Klammern verwenden. Zum Beispiel würde der folgende Code jedes Mal
&quot;Glückspfennig!&quot; ausgeben, wenn die Methode mit <code>Coin::Penny</code> aufgerufen wird,
aber immer noch als letzten Wert des Blocks <code>1</code> zurückgeben:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter,
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; {
            println!(&quot;Glückspfennig!&quot;);
            1
        }
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter =&gt; 25,
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<h3><a class="header" href="#muster-die-werte-binden" id="muster-die-werte-binden">Muster, die Werte binden</a></h3>
<p>Ein weitere nützliche Funktionalität von <code>match</code>-Zweigen ist, dass sie Teile
der Werte binden können, die dem Muster entsprechen. Auf diese Weise können wir
Werte aus Aufzählungsvarianten extrahieren.</p>
<p>Lass uns als Beispiel eine unserer Aufzählungsvarianten so ändern, dass sie
Daten enthält. Von 1999 bis 2008 prägten die Vereinigten Staaten 25-Cent-Münzen
mit unterschiedlichem Aussehen auf einer Seite für jeden der 50 Staaten. Keine
andere Münze hatte ein Staaten-spezifisches Aussehen, sodass nur 25-Cent-Münzen
diese zusätzliche Eigenschaft haben. Wir können diese Information in unserer
Aufzählung unterbringen, indem wir die Variante <code>Quarter</code> so ändern, dass sie
einen <code>UsState</code>-Wert enthält, wie in Codeblock 6-4 umgesetzt.</p>
<pre><pre class="playpen"><code class="language-rust">enum UsState {
    Alabama,
    Alaska,
    // --abschneiden--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-4: Aufzählung <code>Coin</code>, bei der die Variante
<code>Quarter</code> zusätzlich einen <code>UsState</code>-Wert enthält</span></p>
<p>Stellen wir uns vor, dass ein Freund von uns versucht, 25-Cent-Münzen aller 50
Staaten zu sammeln. Während wir unser Kleingeld nach Münzsorten sortieren,
geben wir auch den Namen des Staates der 25-Cent-Münze aus, sodass es unser
Freund in seine Sammlung aufnehmen kann, falls er es nicht hat. Im
<code>match</code>-Ausdruck für diesen Code fügen wir zum Muster der Variante
<code>Coin::Quarter</code> eine Variable <code>state</code> hinzu. Wenn der Zweig für <code>Coin::Quarter</code>
passt, wird die Variable <code>state</code> an den Wert der Eigenschaft der 25-Cent-Münze
gebunden. Dann können wir <code>state</code> im Code für diesen Zweig etwa so verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)] // um den Staat mit println! ausgeben zu können
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span>fn value_in_cents(coin: Coin) -&gt; u8 {
    match coin {
        Coin::Penny =&gt; 1,
        Coin::Nickel =&gt; 5,
        Coin::Dime =&gt; 10,
        Coin::Quarter(state) =&gt; {
            println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
            25
        }
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    value_in_cents(Coin::Quarter(UsState::Alaska));
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir <code>value_in_cents(Coin::Quarter(UsState::Alaska))</code> aufrufen würden,
hätte <code>coin</code> den Wert <code>Coin::Quarter(UsState::Alaska)</code>. Gleichen wir den Wert
mit jedem der <code>match</code>-Zweige ab, passt keiner von ihnen, bis wir
<code>Coin::Quarter(state)</code> erreichen. An diesem Punkt wird <code>state</code> an den Wert
<code>UsState::Alaska</code> gebunden. Wir können dann diese Bindung im
<code>println!</code>-Ausdruck verwenden und so den inneren Zustandswert aus der
<code>Coin</code>-Aufzählungsvariante für <code>Quarter</code> herausholen.</p>
<h3><a class="header" href="#abgleich-mit-optiont" id="abgleich-mit-optiont">Abgleich mit <code>Option&lt;T&gt;</code></a></h3>
<p>Im vorigen Abschnitt wollten wir den inneren <code>T</code>-Wert aus dem Fall <code>Some</code>
herausholen, als wir <code>Option&lt;T&gt;</code> verwendet haben. Wir können <code>Option&lt;T&gt;</code> ebenso
mit <code>match</code> handhaben, wie wir es mit der Aufzählung <code>Coin</code> getan haben! Statt
Münzen zu vergleichen, werden wir die Varianten von <code>Option&lt;T&gt;</code> vergleichen,
aber die Art und Weise, wie der <code>match</code>-Ausdruck funktioniert, bleibt die
gleiche.</p>
<p>Nehmen wir an, wir wollen eine Funktion schreiben, die eine <code>Option&lt;i32&gt;</code> nimmt
und, falls ein Wert darin enthalten ist, zu diesem Wert 1 addiert. Wenn darin
kein Wert enthalten ist, soll die Funktion den Wert <code>None</code> zurückgeben und
nicht versuchen, irgendwelche Operationen durchzuführen.</p>
<p>Diese Funktion ist dank <code>match</code> sehr einfach zu schreiben und wird wie in
Codeblock 6-5 aussehen.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        None =&gt; None,
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-5: Eine Funktion, die einen <code>match</code>-Ausdruck
auf einer <code>Option&lt;i32&gt;</code> verwendet</span></p>
<p>Lass uns die erste Ausführung von <code>plus_one</code> näher betrachten. Wenn wir
<code>plus_one(five)</code> aufrufen, wird die Variable <code>x</code> im Rumpf von <code>plus_one</code> den
Wert <code>Some(5)</code> haben. Dann vergleichen wir das mit jedem <code>match</code>-Zweig.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Der Wert <code>Some(5)</code> passt nicht zum Muster <code>None</code>, also fahren wir mit dem
nächsten Zweig fort.</p>
<pre><code class="language-rust ignore">Some(i) =&gt; Some(i + 1),
</code></pre>
<p>Passt <code>Some(5)</code> zu <code>Some(i)</code>? Aber ja, das tut es! Wir haben die gleiche
Variante. <code>i</code> bindet den in <code>Some</code> enthaltenen Wert, sodass <code>i</code> den Wert <code>5</code>
annimmt. Dann wird der Code im <code>match</code>-Zweig ausgeführt, also fügen wir 1 zum
Wert von <code>i</code> hinzu und erzeugen einen neuen <code>Some</code>-Wert mit der Summe <code>6</code>
darin.</p>
<p>Betrachten wir nun den zweiten Aufruf von <code>plus_one</code> in Codeblock 6-5, wo <code>x</code>
den Wert <code>None</code> hat. Wir betreten den <code>match</code>-Block und vergleichen mit dem
ersten Zweig.</p>
<pre><code class="language-rust ignore">None =&gt; None,
</code></pre>
<p>Er passt! Es gibt keinen Wert zum Hinzufügen, also stoppt das Programm und gibt
den Wert <code>None</code> auf der rechten Seite von <code>=&gt;</code> zurück. Da der erste Zweig
passt, werden keine anderen Zweige abgeglichen.</p>
<p>Die Kombination von <code>match</code> und Aufzählungen ist in vielen Situationen
nützlich. Du wirst dieses Muster häufig in Rust-Code sehen: <code>match</code> mit einer
Aufzählung, eine Variable an die darin enthaltenen Daten binden und dann
dazugehörenden Code ausführen. Am Anfang ist es etwas knifflig, aber wenn man
sich erst einmal daran gewöhnt hat, wird man sich wünschen, es in allen
Sprachen zu haben. Es ist durchweg ein Benutzerfavorit.</p>
<h3><a class="header" href="#abgleiche-sind-vollständig" id="abgleiche-sind-vollständig">Abgleiche sind vollständig</a></h3>
<p>Es gibt noch einen weiteren Aspekt von <code>match</code>, den wir diskutieren müssen.
Betrachte folgende Version unserer Funktion <code>plus_one</code>, die einen Fehler hat
und sich nicht kompilieren lässt:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        Some(i) =&gt; Some(i + 1),
    }
}

let five = Some(5);
let six = plus_one(five);
let none = plus_one(None);
<span class="boring">}
</span></code></pre></pre>
<p>Wir haben den Fall <code>None</code> nicht behandelt, daher wird dieser Code einen Fehler
verursachen. Glücklicherweise ist es ein Fehler, von dem Rust weiß, wie er
zu lösen ist. Wenn wir versuchen, diesen Code zu kompilieren, werden wir
diese Fehlermeldung bekommen:</p>
<pre><code class="language-console">$ cargo run
   Compiling enums v0.1.0 (file:///projects/enums)
error[E0004]: non-exhaustive patterns: `None` not covered
 --&gt; src/main.rs:3:15
  |
3 |         match x {
  |               ^ pattern `None` not covered
  |
  = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms

error: aborting due to previous error

For more information about this error, try `rustc --explain E0004`.
error: could not compile `enums`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Rust weiß, dass wir nicht alle möglichen Fälle abgedeckt haben, und es weiß
sogar, welches Muster wir vergessen haben! Abgleiche in Rust sind
<em>vollständig</em>: Wir müssen jede letzte Möglichkeit ausschöpfen, damit der Code
gültig ist! Speziell im Fall <code>Option&lt;T&gt;</code> schützt uns Rust davor, den Fall
<code>None</code> zu übersehen, und davon auszugehen, dass wir einen Wert haben, obwohl
vielleicht null vorliegt, und macht so den zuvor diskutierten Milliardenfehler
unmöglich.</p>
<h3><a class="header" href="#der-platzhalter-_" id="der-platzhalter-_">Der Platzhalter <code>_</code></a></h3>
<p>Rust hat auch ein Muster, das wir verwenden können, wenn wir nicht alle möglichen
Werte auflisten wollen. Zum Beispiel kann ein <code>u8</code> gültige Werte von 0 bis 255
haben. Wenn wir uns nur um die Werte 1, 3, 5 und 7 kümmern, wollen wir nicht 0,
2, 4, 6, 8, 9 bis hin zu 255 aufzählen müssen. Zum Glück müssen wir das nicht:
Wir können stattdessen das spezielle Muster <code>_</code> verwenden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let some_u8_value = 0u8;
match some_u8_value {
    1 =&gt; println!(&quot;eins&quot;),
    3 =&gt; println!(&quot;drei&quot;),
    5 =&gt; println!(&quot;fünf&quot;),
    7 =&gt; println!(&quot;sieben&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p>Das Muster <code>_</code> passt zu jedem Wert. Wenn wir es unter unsere anderen Zweige
setzen, wird <code>_</code> auf alle möglichen Fälle passen, die davor nicht angegeben
wurden. <code>()</code> ist nur der leere Wert, so dass im Fall <code>_</code> nichts passieren wird.
Damit können wir sagen, dass wir für alle möglichen Werte, die wir nicht vor
dem Platzhalter <code>_</code> auflisten, nichts tun wollen.</p>
<p>Der <code>match</code>-Ausdruck kann jedoch etwas wortreich sein, wenn wir uns nur um
<em>einen</em> der Fälle kümmern. Für diesen Fall bietet Rust <code>if let</code>.</p>
<p>Mehr über Muster und Abgleich findest du in <a href="ch18-00-patterns.html">Kapitel 18</a>.</p>
<h2><a class="header" href="#prägnanter-kontrollfluss-mit-if-let" id="prägnanter-kontrollfluss-mit-if-let">Prägnanter Kontrollfluss mit <code>if let</code></a></h2>
<p>Mit der Syntax <code>if let</code> kannst du <code>if</code> und <code>let</code> in einer weniger wortreichen
Weise kombinieren, um mit Werten umzugehen, die einem Muster entsprechen,
während der Rest ignoriert wird. Betrachte das Programm in Codeblock 6-6, das
auf einen <code>Option&lt;u8&gt;</code>-Wert passt, aber nur dann Code ausführen soll, wenn der
Wert 3 ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>match some_u8_value {
    Some(3) =&gt; println!(&quot;drei&quot;),
    _ =&gt; (),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 6-6: Eine <code>match</code>-Ausdruck, der nur dann Code
ausführt, wenn der Wert <code>Some(3)</code> ist</span></p>
<p>Wir wollen etwas bei <code>Some(3)</code> machen, aber nichts mit allen anderen
<code>Some&lt;u8&gt;</code>-Werten oder dem Wert <code>None</code>. Um den <code>match</code>-Ausdruck zu
vervollständigen, müssen wir <code>_ =&gt; ()</code> ergänzen. Nachdem wir nur eine Variante
verarbeiten, bedeutet das relativ viel Code, den wir schreiben müssen.</p>
<p>Stattdessen könnten wir dies in kürzerer Form schreiben, indem wir <code>if let</code>
verwenden. Der folgende Code verhält sich genauso wie der <code>match</code>-Ausdruck in
Codeblock 6-6:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">let some_u8_value = Some(0u8);
</span>if let Some(3) = some_u8_value {
    println!(&quot;three&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Syntax <code>if let</code> nimmt ein Muster und einen Ausdruck, getrennt durch ein
Gleichheitszeichen. Sie funktioniert auf gleiche Weise wie bei <code>match</code>, wo der
Ausdruck hinter <code>match</code> angegeben wird und das Muster der erste Zweig ist.</p>
<p>Die Verwendung von <code>if let</code> bedeutet weniger Tipparbeit, weniger Einrückung und
weniger Codeanteil. Du verlierst jedoch die Prüfung auf Vollständigkeit, die
<code>match</code> erzwingt. Die Wahl zwischen <code>match</code> und <code>if let</code> hängt davon ab, was
du in der speziellen Situation machst, und davon, ob ein Gewinn an Prägnanz ein
angemessener Kompromiss für den Verlust einer Prüfung auf Vollständigkeit ist.</p>
<p>Anders gesagt kannst du dir <code>if let</code> als syntaktischen Zucker für einen
<code>match</code>-Ausdruck vorstellen, der Code nur bei Übereinstimmung mit einem Muster
ausführt und alle anderen Werte ignoriert.</p>
<p>Wir können ein <code>else</code> an ein <code>if let</code> anhängen. Der Code-Block, der zum <code>else</code>
gehört, ist der gleiche wie der Code-Block, der zum <code>_</code>-Zweig im
<code>match</code>-Ausdruck gehören würde. Erinnere dich an die Aufzählung <code>Coin</code> in
Codeblock 6-4, wo die Variante <code>Quarter</code> auch einen <code>UsState</code>-Wert enthielt.
Wenn wir alle Nicht-25-Cent-Münzen zählen wollten, während wir die Eigenschaft
der 25-Cent-Münzen ausgeben, könnten wir das mit einem <code>match</code>-Ausdruck wie
diesem tun:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    match coin {
        Coin::Quarter(state) =&gt; println!(&quot;25-Cent-Münze aus {:?}!&quot;, state),
        _ =&gt; count += 1,
    }
<span class="boring">}
</span></code></pre></pre>
<p>Oder wir könnten einen Ausdruck mit <code>if let</code> und <code>else</code> wie diesen verwenden:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">#[derive(Debug)]
</span><span class="boring">enum UsState {
</span><span class="boring">    Alabama,
</span><span class="boring">    Alaska,
</span><span class="boring">    // --abschneiden--
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum Coin {
</span><span class="boring">    Penny,
</span><span class="boring">    Nickel,
</span><span class="boring">    Dime,
</span><span class="boring">    Quarter(UsState),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let coin = Coin::Penny;
</span>    let mut count = 0;
    if let Coin::Quarter(state) = coin {
        println!(&quot;25-Cent-Münze aus {:?}!&quot;, state);
    } else {
        count += 1;
    }
<span class="boring">}
</span></code></pre></pre>
<p>Wenn du eine Situation hast, in der dein Programm über eine Logik verfügt, die
mit einem <code>match</code>-Ausdruck zu wortreich auszudrücken wäre, denke daran, dass
<code>if let</code> ebenfalls in deinem Rust-Werkzeugkasten enthalten ist.</p>
<h2><a class="header" href="#zusammenfassung-2" id="zusammenfassung-2">Zusammenfassung</a></h2>
<p>Wir haben uns damit befasst, wie man Aufzählungen verwendet, um
benutzerdefinierte Typen zu erstellen, die zu einem Satz von Aufzählungswerten
gehören können. Wir haben gezeigt, wie der Typ <code>Option&lt;T&gt;</code> der
Standardbibliothek dir dabei hilft, das Typsystem zu verwenden, um Fehler zu
vermeiden. Wenn Aufzählungswerte Daten enthalten, kannst du diese Werte mit
<code>match</code> oder <code>if let</code> extrahieren und verwenden, je nachdem, wie viele Fälle du
behandeln musst.</p>
<p>Deine Rust-Programme können nun Konzepte in deiner Domäne mit Hilfe von
Strukturen und Aufzählungen ausdrücken. Das Erstellen benutzerdefinierter Typen
zur Verwendung in deiner API gewährleistet Typsicherheit: Der Kompilierer wird
sicherstellen, dass deine Funktionen nur Werte jenes Typs erhalten, den die
Funktion erwartet.</p>
<p>Um deinen Nutzern eine gut organisierte API zur Verfügung zu stellen, die
einfach zu benutzen ist und nur genau das offenbart, was deine Nutzer
benötigen, wenden wir uns nun den Modulen von Rust zu.</p>
<h1><a class="header" href="#wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen" id="wachsende-projekte-verwalten-mit-paketen-packages-kisten-crates-und-modulen">Wachsende Projekte verwalten mit Paketen (packages), Kisten (crates) und Modulen</a></h1>
<p>Wenn du große Programme schreibst, ist es wichtig, deinen Code zu organisieren,
da es unmöglich wird, den Überblick über dein gesamtes Programm im Kopf zu
behalten. Durch Gruppieren verwandter Funktionen und Aufteilen von Code mit
unterschiedlichen Funktionalitäten wirst du klären, wo du Code findest, der
eine bestimmte Funktionalität implementiert, und an welcher Stelle du eine
Funktionalität ändern musst.</p>
<p>Die Programme, die wir bisher geschrieben haben, waren in einem Modul in einer
Datei. Wenn ein Projekt wächst, kannst du den Code organisieren, indem du ihn
in mehrere Module und dann in mehrere Dateien aufteilst. Ein Paket (package)
kann mehrere Binär-Kisten (binary crates) und optional eine Bibliotheks-Kiste
(library crate) enthalten. Wenn ein Paket wächst, kannst du Teile in separate
Kisten extrahieren, die zu externen Abhängigkeiten werden. Dieses Kapitel
behandelt all diese Techniken. Für sehr große Projekte aus einer Reihe von
zusammenhängenden Paketen, die sich gemeinsam weiterentwickeln, stellt Cargo
Arbeitsbereiche zur Verfügung, die wir im Abschnitt
<a href="ch14-03-cargo-workspaces.html">„Cargo-Arbeitsbereiche“</a> in Kapitel 14 behandeln werden.</p>
<p>Zusätzlich zur Gruppierungsfunktionalität ermöglicht die Kapselung von
Implementierungsdetails die Wiederverwendung von Code auf einer höheren Ebene:
Sobald du eine Operation implementiert hast, kann anderer Code diesen Code über
die öffentliche Schnittstelle des Codes aufrufen, ohne zu wissen, wie die
Implementierung funktioniert. Die Art und Weise, wie du Code schreibst,
definiert, welche Teile für anderen Code öffentlich sind und welche Teile
private Implementierungsdetails sind, deren Änderung du dir vorbehältst. Dies
ist eine weitere Möglichkeit, die Menge der Details, die man im Kopf behalten
muss, zu begrenzen.</p>
<p>Ein verwandtes Konzept ist der Gültigkeitsbereich (scope): Der verschachtelte
Kontext, in dem Code geschrieben wird, hat eine Reihe von Namen, die als „im
Gültigkeitsbereich“ (in scope) definiert sind. Beim Lesen, Schreiben und
Kompilieren von Code müssen Programmierer und Kompilierer wissen, ob sich ein
bestimmter Name an einer bestimmten Stelle auf eine Variable, Funktion,
Struktur (struct), Aufzählung (enum), Modul, Konstante oder ein anderes Element
bezieht und was dieses Element bedeutet. Du kannst Gültigkeitsbereiche
erstellen und verändern, welche Namen in oder außerhalb des Gültigkeitsbereichs
liegen. Du kannst nicht zwei Elemente mit gleichem Namen im selben
Gültigkeitsbereich haben; es sind Werkzeuge zur Lösung von Namenskonflikten
vorhanden.</p>
<p>Rust verfügt über eine Reihe von Funktionalitäten, mit denen du die
Organisation deines Codes verwalten kannst, z.B. welche Details offengelegt
werden, welche Details privat sind und welche Namen im jeweiligen
Gültigkeitsbereich deines Programms sind. Zu diesen Funktionalitäten, die
manchmal kollektiv als <em>Modulsystem</em> bezeichnet werden, gehören:</p>
<ul>
<li><strong>Pakete (packages):</strong> Eine Cargo-Funktionalität, mit der du Kisten bauen,
testen und gemeinsam nutzen kannst.</li>
<li><strong>Kisten (crates):</strong> Ein Baum von Modulen, der eine Bibliothek oder ein
ausführbares Programm erzeugt.</li>
<li><strong>Module</strong> und <strong><code>use</code></strong>: Ermöglicht dir, die Organisation, den
Gültigkeitsbereich und den Datenschutz von Pfaden zu steuern.</li>
<li><strong>Pfade:</strong> Eine Möglichkeit, ein Element zu benennen, z.B. eine Struktur,
eine Funktion oder ein Modul.</li>
</ul>
<p>In diesem Kapitel gehen wir auf all diese Funktionalitäten ein, besprechen, wie
sie zusammenwirken, und erklären, wie sie zur Verwaltung der
Gültigkeitsbereiche eingesetzt werden können. Am Ende solltest du ein solides
Verständnis des Modulsystems haben und in der Lage sein, mit den
Gültigkeitsbereichen wie ein Profi zu arbeiten!</p>
<h2><a class="header" href="#pakete-packages-und-kisten-crates" id="pakete-packages-und-kisten-crates">Pakete (packages) und Kisten (crates)</a></h2>
<p>Die ersten Bestandteile des Modulsystems, die wir behandeln werden, sind Pakete
(packages) und Kisten (crates). Eine Kiste ist eine Binärdatei oder eine
Bibliothek. Die <em>Kistenwurzel</em> (crate root) ist eine Quelldatei, bei der der
Rust-Kompilierer anfängt und die das Wurzelmodul deiner Kiste darstellt (Module
werden im Abschnitt <a href="ch07-02-defining-modules-to-control-scope-and-privacy.html">„Mit Modulen den Kontrollumfang und Datenschutz
steuern“</a> ausführlich erklärt). Ein <em>Paket</em> besteht aus einer oder
mehreren Kisten, die eine Reihe von Funktionalitäten bereitstellen. Ein Paket
enthält eine Datei <em>Cargo.toml</em>, die beschreibt, wie man diese Kisten baut.</p>
<p>Mehrere Regeln bestimmen, was ein Paket enthalten kann. Ein Paket darf <em>maximal
eine</em> Bibliothekskiste enthalten, nicht mehr. Sie kann so viele binäre Kisten
enthalten, wie du möchtest, aber sie muss mindestens eine Kiste enthalten
(egal ob Bibliothek oder binär).</p>
<p>Lass uns durchgehen, was passiert, wenn wir ein Paket erstellen. Zuerst geben
wir den Befehl <code>cargo new</code> ein:</p>
<pre><code class="language-console">$ cargo new my-project
     Created binary (application) `my-project` package
$ ls my-project
Cargo.toml
src
$ ls my-project/src
main.rs
</code></pre>
<p>Nachdem wir den Befehl eingegeben haben, erstellte Cargo eine Datei
<em>Cargo.toml</em> und gab uns ein Paket. Wenn man sich den Inhalt von <em>Cargo.toml</em>
ansieht, wird <em>src/main.rs</em> nicht erwähnt, weil Cargo einer Konvention folgt,
dass <em>src/main.rs</em> die Kistenwurzel einer binären Kiste mit dem gleichen Namen
wie das Paket ist. Ebenso weiß Cargo, dass, wenn im Paketverzeichnis
<em>src/lib.rs</em> enthalten ist, das Paket eine Bibliothekskiste mit dem gleichen
Namen wie das Paket enthält und <em>src/lib.rs</em> seine Kistenwurzel ist. Cargo
übergibt die Kistenwurzeldateien an <code>rustc</code>, um die Bibliothek oder Binärdatei
zu bauen.</p>
<p>Hier haben wir ein Paket, das nur <em>src/main.rs</em> enthält, was bedeutet, dass es
nur eine binäre Kiste namens <code>my-project</code> enthält. Wenn ein Paket
<em>src/main.rs</em> und <em>src/lib.rs</em> enthält, hat es zwei Kisten: Eine Bibliothek und
eine Binärdatei, beide mit dem gleichen Namen wie das Paket. Ein Paket kann
mehrere Binär-Kisten haben, indem Dateien im Verzeichnis <em>src/bin</em> abgelegt
werden: Jede Datei wird eine separate Binär-Kiste sein. Eine Kiste fasst
verwandte Funktionalitäten in einen Gültigkeitsbereich zusammen, sodass die
Funktionalität leicht von mehreren Projekten gemeinsam genutzt werden kann. Zum
Beispiel bietet die in <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">Kapitel 2</a> verwendete Kiste <code>rand</code> eine
Funktionalität, die Zufallszahlen erzeugt. Wir können diese Funktionalität in
unseren eigenen Projekten nutzen, indem wir die Kiste <code>rand</code> in den
Gültigkeitsbereich unseres Projekts aufnehmen. Die gesamte Funktionalität, die
von der Kiste <code>rand</code> zur Verfügung gestellt wird, ist über den Namen <code>rand</code> der
Kiste zugänglich.</p>
<p>Das Beibehalten der Funktionalität einer Kiste in ihrem eigenen
Gültigkeitsbereich klärt, ob eine bestimmte Funktionalität in unserer Kiste
oder in der Kiste <code>rand</code> definiert ist, und verhindert potenzielle Konflikte.
Zum Beispiel bietet die Kiste <code>rand</code> ein Merkmal (trait) namens <code>Rng</code>. Wir
können auch eine Struktur (struct) mit dem Namen <code>Rng</code> in unserer eigenen Kiste
definieren. Da die Funktionalität einer Kiste im Namensraum des eigenen
Gültigkeitsbereichs ist, können wir <code>rand</code> als Abhängigkeit hinzufügen, ohne
dadurch den Kompilierer durcheinanderzubringen, worauf sich der Name <code>Rng</code>
bezieht. In unserer Kiste bezieht er sich auf <code>struct Rng</code>, die wir definiert
haben. Wir würden auf das Merkmal <code>Rng</code> aus der Kiste <code>rand</code> mit <code>rand::Rng</code>
zugreifen.</p>
<p>Lass uns weitermachen und über das Modulsystem sprechen!</p>
<h2><a class="header" href="#mit-modulen-den-kontrollumfang-und-datenschutz-steuern" id="mit-modulen-den-kontrollumfang-und-datenschutz-steuern">Mit Modulen den Kontrollumfang und Datenschutz steuern</a></h2>
<p>In diesem Abschnitt werden wir über Module und andere Teile des Modulsystems
sprechen, nämlich <em>Pfade</em>, die es dir erlauben, Elemente zu benennen; das
Schlüsselwort <code>use</code>, das einen Pfad in den Gültigkeitsbereich bringt; und das
Schlüsselwort <code>pub</code>, um Elemente öffentlich zu machen. Wir werden auch das
Schlüsselwort <code>as</code>, externe Pakete und den Stern-Operator (glob operator)
besprechen. Konzentrieren wir uns vorerst auf die Module!</p>
<p><em>Module</em> lassen uns Code innerhalb einer Kiste in Gruppen organisieren, um ihn
lesbar und leicht wiederverwendbar zu machen. Module kontrollieren auch den
<em>Datenschutz</em> (privacy) von Elementen, d.h. ob ein Element von einem externen
Code verwendet werden kann (<em>öffentlich</em>) oder ob es sich um ein internes
Implementierungsdetail handelt und nicht für die externe Verwendung verfügbar
ist (<em>privat</em>).</p>
<p>Als Beispiel schreiben wir eine Bibliothekskiste, die die Funktionalität eines
Restaurants bietet. Wir werden die Signaturen der Funktionen definieren, aber
ihre Rümpfe leer lassen, um uns auf die Organisation des Codes zu
konzentrieren, anstatt tatsächlich ein Restaurant im Code zu implementieren.</p>
<p>Im Gaststättengewerbe werden einige Teile eines Restaurants als <em>Vorderseite
des Hauses</em> und andere als <em>Hinterseite des Hauses</em> bezeichnet. Auf der
Vorderseite des Hauses sind die Kunden; hier setzen Gastgeber ihre Kunden hin,
Kellner nehmen Bestellungen auf und rechnen ab und Barkeeper machen die
Getränke. Auf der Hinterseite des Hauses arbeiten die Küchenchefs und Köche in
der Küche, Geschirrspüler waschen ab und Manager erledigen Verwaltungsarbeiten.</p>
<p>Um unsere Kiste so zu strukturieren, wie ein echtes Restaurant funktioniert,
können wir die Funktionen in verschachtelten Modulen organisieren. Erstelle
eine neue Bibliothek namens <code>restaurant</code>, indem du <code>cargo new --lib restaurant</code>
ausführst; dann schreibe den Code aus Codeblock 7-1 in <em>src/lib.rs</em>, um einige
Module und Funktionssignaturen zu definieren.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}

        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}

        fn serve_order() {}

        fn take_payment() {}
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-1: Ein Modul <code>front_of_house</code>, das andere
Module enthält, die dann Funktionen enthalten</span></p>
<p>Wir definieren ein Modul, indem wir mit dem Schlüsselwort <code>mod</code> beginnen und
dann den Namen des Moduls angeben (in diesem Fall <code>front_of_house</code>) und
geschweifte Klammern um den Rumpf des Moduls setzen. Innerhalb von Modulen
können wir andere Module haben, wie in diesem Fall mit den Modulen <code>hosting</code>
und <code>serving</code>. Module können auch Definitionen für andere Elemente enthalten,
z.B. Strukturen, Aufzählungen, Konstanten, Merkmale oder – wie in
Codeblock 7-1 – Funktionen.</p>
<p>Durch die Verwendung von Modulen können wir verwandte Definitionen gruppieren
und benennen, warum sie verwandt sind. Programmierer, die diesen Code
verwenden, hätten es leichter, die Definitionen zu finden, die sie verwenden
wollten, da sie sich anhand der Gruppen im Code bewegen könnten, anstatt alle
Definitionen durchlesen zu müssen. Programmierer, die diesem Code neue
Funktionen hinzufügen, wüssten, wo sie den Code platzieren müssten, um das
Programm zu organisieren.</p>
<p>Vorhin haben wir erwähnt, dass <em>src/main.rs</em> und <em>src/lib.rs</em> als Kistenwurzel
bezeichnet werden. Der Grund für ihren Namen ist, dass der Inhalt dieser beiden
Dateien ein Modul namens <code>crate</code> an der Wurzel der Modulstruktur der Kiste
bilden, die als <em>Modulbaum</em> bekannt ist.</p>
<p>Codeblock 7-2 zeigt den Modulbaum für die Struktur in Codeblock 7-1.</p>
<pre><code class="language-text">crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
</code></pre>
<p><span class="caption">Codeblock 7-2: Modulbaum für den Code in Codeblock
7-1</span></p>
<p>Dieser Baum zeigt, wie einige der Module ineinander verschachtelt sind (z.B.
ist <code>hosting</code> innerhalb von <code>front_of_house</code>). Der Baum zeigt auch, dass einige
Module <em>Geschwister</em> voneinander sind, was bedeutet, dass sie im selben Modul
definiert sind (<code>hosting</code> und <code>serving</code> sind innerhalb von <code>front_of_house</code>
definiert). Um die Familienmetapher fortzusetzen: Wenn Modul A innerhalb von
Modul B enthalten ist, sagen wir, dass Modul A das <em>Kind</em> (child) von Modul B
ist und dass Modul B das <em>Elter</em> (parent) von Modul A ist. Beachte, dass der
gesamte Modulbaum als Wurzel das implizite Modul namens <code>crate</code> hat.</p>
<p>Der Modulbaum könnte dich an den Verzeichnisbaum des Dateisystems auf deinem
Computer erinnern; dies ist ein sehr treffender Vergleich! Genau wie
Verzeichnisse in einem Dateisystem verwendest du Module, um deinen Code zu
organisieren. Und genau wie Dateien in einem Verzeichnis brauchen wir einen
Weg, unsere Module zu finden.</p>
<h2><a class="header" href="#mit-pfaden-auf-ein-element-im-modulbaum-verweisen" id="mit-pfaden-auf-ein-element-im-modulbaum-verweisen">Mit Pfaden auf ein Element im Modulbaum verweisen</a></h2>
<p>Um Rust zu zeigen, wo ein Element in einem Modulbaum zu finden ist, verwenden
wir einen Pfad, auf gleiche Weise wie beim Navigieren durch ein Dateisystem.
Wenn wir eine Funktion aufrufen wollen, müssen wir ihren Pfad kennen.</p>
<p>Ein Pfad kann zwei Formen annehmen:</p>
<ul>
<li>Ein <em>absoluter Pfad</em> startet bei einer Kistenwurzel, indem ein Kistenname
oder das Literal <code>crate</code> verwendet wird.</li>
<li>Ein <em>relativer Pfad</em> startet beim aktuellen Modul und benutzt <code>self</code>, <code>super</code>
oder einen Bezeichner im aktuellen Modul.</li>
</ul>
<p>Sowohl absolute als auch relative Pfade bestehen aus einem oder mehreren
Bezeichnern, die durch doppelte Doppelpunkte (<code>::</code>) getrennt sind.</p>
<p>Kommen wir auf das Beispiel in Codeblock 7-1 zurück. Wie rufen wir die Funktion
<code>add_to_waitlist</code> auf? Das ist dasselbe wie die Frage, wie der Pfad der
Funktion <code>add_to_waitlist</code> ist. In Codeblock 7-3 haben wir unseren Code etwas
vereinfacht, indem wir einige der Module und Funktionen entfernt haben. Wir
zeigen zwei Möglichkeiten, wie die Funktion <code>add_to_waitlist</code> von einer neuen
Funktion <code>eat_at_restaurant</code> aus aufgerufen werden kann, die in der
Kistenwurzel definiert ist. Die Funktion <code>eat_at_restaurant</code> ist Teil der
öffentlichen Programmierschnittstelle (API) unserer Bibliothekskiste, daher
markieren wir sie mit dem Schlüsselwort <code>pub</code>. Im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html#pfade-mit-dem-schl%C3%BCsselwort-pub-%C3%B6ffnen">„Pfade mit dem
Schlüsselwort <code>pub</code> öffnen“</a> gehen wir näher auf <code>pub</code> ein. Beachte, dass
sich dieses Beispiel noch nicht kompilieren lässt; wir werden gleich erklären,
warum.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // absoluter Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-3: Aufruf der Funktion <code>add_to_waitlist</code>
mittels absoluter und relativer Pfade</span></p>
<p>Beim ersten Aufruf der Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code>
verwenden wir einen absoluten Pfad. Die Funktion <code>add_to_waitlist</code> ist in der
gleichen Kiste definiert wie <code>eat_at_restaurant</code>, daher können wir das
Schlüsselwort <code>crate</code> verwenden, um einen absoluten Pfad zu beginnen.</p>
<p>Nach <code>crate</code> geben wir jedes der aufeinanderfolgenden Module an, bis wir
<code>add_to_waitlist</code> erreichen. Du kannst dir ein Dateisystem mit der gleichen
Struktur vorstellen und wir würden den Pfad
<code>/front_of_house/hosting/add_to_waitlist</code> angeben, um das Programm
<code>add_to_waitlist</code> auszuführen; das Verwenden des Namens <code>crate</code>, um von der
Kistenwurzel aus zu beginnen, ist analog zu <code>/</code>, um vom
Dateisystem-Wurzelverzeichnis in deiner Eingabeaufforderung aus zu beginnen.</p>
<p>Beim zweiten Aufruf von <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> verwenden wir
einen relativen Pfad. Der Pfad beginnt mit <code>front_of_house</code>, dem Namen des
Moduls, das auf der gleichen Ebene des Modulbaums definiert ist wie
<code>eat_at_restaurant</code>. Hier wäre das Dateisystem-Äquivalent die Verwendung des
Pfades <code>front_of_house/hosting/add_to_waitlist</code>. Mit einem Namen zu beginnen
bedeutet, dass der Pfad relativ ist.</p>
<p>Die Überlegung, ob ein relativer oder absoluter Pfad verwendet wird, ist eine
Entscheidung, die du auf Basis deines Projekts treffen wirst. Die Entscheidung
sollte davon abhängen, ob du den Code für die Elementdefinition eher separat
oder zusammen mit dem Code ablegen möchtest, der das Element verwendet. Wenn
wir zum Beispiel das Modul <code>front_of_house</code> und die Funktion
<code>eat_at_restaurant</code> in ein Modul namens <code>customer_experience</code> verschieben,
müssten wir den absoluten Pfad in <code>add_to_waitlist</code> ändern, aber der relative
Pfad wäre immer noch gültig. Wenn wir jedoch die Funktion <code>eat_at_restaurant</code>
in ein separates Modul namens <code>dining</code> verschieben würden, würde der absolute
Pfad beim Aufruf <code>add_to_waitlist</code> gleich bleiben, aber der relative Pfad
müsste aktualisiert werden. Wir bevorzugen die Angabe absoluter Pfade, da es
wahrscheinlicher ist, dass Codedefinitionen und Elementaufrufe unabhängig
voneinander verschoben werden.</p>
<p>Lass uns versuchen, Codeblock 7-3 zu kompilieren, und herausfinden, warum er
sich noch nicht kompilieren lässt! Der Fehler, den wir erhalten, ist in
Codeblock 7-4 zu sehen.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: module `hosting` is private
 --&gt; src/lib.rs:9:28
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                            ^^^^^^^

error[E0603]: module `hosting` is private
  --&gt; src/lib.rs:12:21
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                     ^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">Codeblock 7-4: Kompilierfehler im Code in Codeblock
7-3</span></p>
<p>Die Fehlermeldungen besagen, dass das Modul <code>hosting</code> privat ist. Mit anderen
Worten, wir haben die korrekten Pfade für das Modul <code>hosting</code> und die Funktion
<code>add_to_waitlist</code> angegeben, aber Rust lässt sie uns nicht nutzen, weil es
keinen Zugriff auf die privaten Abschnitte hat.</p>
<p>Module sind nicht nur zum Organisieren deines Codes nützlich. Sie definieren
auch Rusts <em>Datenschutzbegrenzung</em> (privacy boundary): Die Zeile, die die
Implementierungsdetails kapselt, darf externen Code nicht kennen, aufrufen oder
sich auf ihn verlassen. Wenn du also ein Element wie eine Funktion oder
Struktur privat machen willst, lege es in einem Modul ab.</p>
<p>Die Art und Weise, wie der Datenschutz in Rust funktioniert, ist, dass alle
Elemente (Funktionen, Methoden, Strukturen, Aufzählungen, Module und
Konstanten) standardmäßig privat sind. Objekte in einem übergeordneten Modul
können die privaten Objekte in untergeordneten Modulen nicht verwenden, aber
Objekte in untergeordneten Modulen können die Objekte in ihren übergeordneten
Modulen verwenden. Der Grund dafür ist, dass untergeordnete Module ihre
Implementierungsdetails ein- und ausblenden, aber die untergeordneten Module
können den Gültigkeitsbereich sehen, in dem sie definiert sind. Um mit der
Restaurantmetapher fortzufahren, stelle dir die Datenschutzregeln wie das
Backoffice eines Restaurants vor: Was dort drinnen passiert, ist für
Restaurantkunden privat, aber Büroleiter können alles im Restaurant, in dem sie
arbeiten, sehen und tun.</p>
<p>Rust entschied sich dafür, das Modulsystem auf diese Weise funktionieren zu
lassen, sodass das Ausblenden innerer Implementierungsdetails die Vorgabe ist.
Auf diese Weise weißt du, welche Teile des inneren Codes du ändern kannst, ohne
den äußeren Code zu brechen. Aber du kannst innere Teile des Codes von
Kindmodulen für äußere Elternmodule freigeben, indem du das Schlüsselwort <code>pub</code>
verwendest, um ein Element öffentlich zu machen.</p>
<h3><a class="header" href="#pfade-mit-dem-schlüsselwort-pub-öffnen" id="pfade-mit-dem-schlüsselwort-pub-öffnen">Pfade mit dem Schlüsselwort <code>pub</code> öffnen</a></h3>
<p>Kehren wir zum Fehler in Codeblock 7-4 zurück, der uns sagte, das Modul
<code>hosting</code> sei privat. Wir wollen, dass die Funktion <code>eat_at_restaurant</code> im
übergeordneten Modul Zugriff auf die Funktion <code>add_to_waitlist</code> im
untergeordneten Modul hat, also markieren wir das Modul <code>hosting</code> mit dem
Schlüsselwort <code>pub</code>, wie in Codeblock 7-5 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod front_of_house {
    pub mod hosting {
        fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolutet Pfad
    crate::front_of_house::hosting::add_to_waitlist();

    // Relativer Pfad
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-5: Deklarieren des Moduls <code>hosting</code> als
<code>pub</code>, um es von <code>eat_at_restaurant</code> aus zu benutzen</span></p>
<p>Leider führt der Code in Codeblock 7-5 immer noch zu einem Fehler, wie
Codeblock 7-6 zeigt.</p>
<pre><code class="language-console">$ cargo build
   Compiling restaurant v0.1.0 (file:///projects/restaurant)
error[E0603]: function `add_to_waitlist` is private
 --&gt; src/lib.rs:9:37
  |
9 |     crate::front_of_house::hosting::add_to_waitlist();
  |                                     ^^^^^^^^^^^^^^^

error[E0603]: function `add_to_waitlist` is private
  --&gt; src/lib.rs:12:30
   |
12 |     front_of_house::hosting::add_to_waitlist();
   |                              ^^^^^^^^^^^^^^^

error: aborting due to 2 previous errors

For more information about this error, try `rustc --explain E0603`.
error: could not compile `restaurant`.

To learn more, run the command again with --verbose.
</code></pre>
<p><span class="caption">Codeblock 7-6: Kompilierfehler im Code in Codeblock
7-5</span></p>
<p>Was ist passiert? Das Hinzufügen des Schlüsselworts <code>pub</code> vor <code>mod hosting</code>
macht das Modul öffentlich. Wenn wir auf <code>front_of_house</code> zugreifen können,
können wir mit dieser Änderung auch auf <code>hosting</code> zugreifen. Aber die <em>Inhalte</em>
von <code>hosting</code> sind immer noch privat; das Modul öffentlich zu machen, macht
seinen Inhalt nicht öffentlich. Das Schlüsselwort <code>pub</code> in einem Modul lässt
nur Code in seinen Vorgängermodulen auf dieses Modul verweisen.</p>
<p>Die Fehler in Codeblock 7-6 besagen, dass die Funktion <code>add_to_waitlist</code> privat
ist. Die Datenschutzregeln gelten für Strukturen, Aufzählungen, Funktionen und
Methoden sowie für Module.</p>
<p>Lasse uns auch die Funktion <code>add_to_waitlist</code> öffentlich machen, indem wir das
Schlüsselwort <code>pub</code> vor seiner Definition hinzufügen, wie in Codeblock 7-7.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // absoluter Path
    crate::front_of_house::hosting::add_to_waitlist();

    // relativer Path
    front_of_house::hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-7: Das Hinzufügen des Schlüsselworts <code>pub</code> zu
<code>mod hosting</code> und <code>fn add_to_waitlist</code> lässt uns die Funktion in
<code>eat_at_restaurant</code> aufrufen</span></p>
<p>Jetzt kompiliert der Code! Schauen wir uns den absoluten und den relativen Pfad
an und prüfen wir noch einmal, warum das Hinzufügen des Schlüsselwortes <code>pub</code>
uns diese Pfade in <code>add_to_waitlist</code> im Hinblick auf die Datenschutzregeln
verwenden lässt.</p>
<p>Auf dem absoluten Pfad beginnen wir mit <code>crate</code>, der Wurzel des Modulbaums
unserer Kiste. Dann wird das Modul <code>front_of_house</code> in der Kistenwurzel
definiert. Das Modul <code>front_of_house</code> ist nicht öffentlich, aber weil die
<code>eat_at_restaurant</code>-Funktion im gleichen Modul wie <code>front_of_house</code> definiert
ist (d.h. <code>eat_at_restaurant</code> und <code>front_of_house</code> sind Geschwister), können
wir auf <code>front_of_house</code> von <code>eat_at_restaurant</code> aus zugreifen. Als nächstes
wird das Modul <code>hosting</code> mit <code>pub</code> gekennzeichnet. Wir können auf das
übergeordnete Modul von <code>hosting</code> zugreifen, also können wir auf <code>hosting</code>
zugreifen. Schließlich wird die Funktion <code>add_to_waitlist</code> mit <code>pub</code> markiert
und wir können auf ihr Elternmodul zugreifen, sodass dieser Funktionsaufruf
klappt!</p>
<p>Beim relativen Pfad ist die Logik die gleiche wie beim absoluten Pfad, mit
Ausnahme des ersten Schritts: Anstatt von der Kistenwurzel auszugehen, beginnt
der Pfad mit <code>front_of_house</code>. Das Modul <code>front_of_house</code> wird innerhalb
desselben Moduls wie <code>eat_at_restaurant</code> definiert, sodass der relative Pfad
ausgehend vom Modul, in dem <code>eat_at_restaurant</code> definiert ist, funktioniert.
Weil <code>hosting</code> und <code>add_to_waitlist</code> nun mit <code>pub</code> markiert sind, funktioniert
der Rest des Pfades, und dieser Funktionsaufruf ist gültig!</p>
<h3><a class="header" href="#relative-pfade-mit-super-beginnen" id="relative-pfade-mit-super-beginnen">Relative Pfade mit <code>super</code> beginnen</a></h3>
<p>Wir können auch relative Pfade konstruieren, die im Elternmodul beginnen, indem
wir <code>super</code> am Anfang des Pfades verwenden. Das ist so, als würde man einen
Dateisystempfad mit der Syntax <code>..</code> beginnen. Warum sollten wir das tun wollen?</p>
<p>Betrachte den Code in Codeblock 7-8, der die Situation nachbildet, in der ein
Koch eine falsche Bestellung korrigiert und persönlich zum Kunden bringt. Die
Funktion <code>fix_incorrect_order</code> ruft die Funktion <code>serve_order</code> auf, indem sie
den Pfad zu <code>serve_order</code> beginnend mit <code>super</code> angibt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn serve_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::serve_order();
    }

    fn cook_order() {}
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-8: Aufrufen einer Funktion unter Verwendung
eines relativen Pfades, der mit <code>super</code> beginnt</span></p>
<p>Die Funktion <code>fix_incorrect_order</code> befindet sich im Modul <code>back_of_house</code>,
sodass wir <code>super</code> benutzen können, um zum Elternmodul von <code>back_of_house</code> zu
gelangen, was in diesem Fall die Wurzel <code>crate</code> ist. Von dort aus suchen wir
nach <code>serve_order</code> und finden es. Erfolg! Wir denken, dass das Modul
<code>back_of_house</code> und die Funktion <code>serve_order</code> wahrscheinlich in der gleichen
Beziehung zueinander bleiben und zusammenrücken werden, sollten wir uns dazu
entschließen, den Modulbaum der Kiste neu zu organisieren. Deshalb haben wir
<code>super</code> verwendet, sodass wir in Zukunft weniger Codestellen zu aktualisieren
haben, wenn dieser Code in ein anderes Modul verschoben wird.</p>
<h3><a class="header" href="#strukturen-und-aufzählungen-öffentlich-machen" id="strukturen-und-aufzählungen-öffentlich-machen">Strukturen und Aufzählungen öffentlich machen</a></h3>
<p>Wir können <code>pub</code> auch benutzen, um Strukturen und Aufzählungen als öffentlich
zu kennzeichnen, aber es gibt ein paar zusätzliche Details. Wenn wir <code>pub</code> vor
einer Struktur-Definition verwenden, machen wir die Struktur öffentlich, aber
die Felder der Struktur sind immer noch privat. Wir können jedes Feld von Fall
zu Fall öffentlich machen oder auch nicht. In Codeblock 7-9 haben wir eine
öffentliche Struktur <code>back_of_house::Breakfast</code> mit einem öffentlichen Feld
<code>toast</code>, aber einem privaten Feld <code>seasonal_fruit</code> definiert. Dies ist der Fall
in einem Restaurant, in dem der Kunde die Brotsorte auswählen kann, die zu
einer Mahlzeit gehört, aber der Küchenchef entscheidet, welche Früchte die
Mahlzeit begleiten, je nach Saison und Vorrat. Das verfügbare Obst ändert sich
schnell, sodass die Kunden nicht wählen oder gar sehen können, welches Obst sie
bekommen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub struct Breakfast {
        pub toast: String,
        seasonal_fruit: String,
    }

    impl Breakfast {
        pub fn summer(toast: &amp;str) -&gt; Breakfast {
            Breakfast {
                toast: String::from(toast),
                seasonal_fruit: String::from(&quot;Pfirsiche&quot;),
            }
        }
    }
}

pub fn eat_at_restaurant() {
    // Bestelle im Sommer ein Frühstück mit Roggentoast
    let mut meal = back_of_house::Breakfast::summer(&quot;Roggen&quot;);
    // Ändere unsere Meinung darüber, welche Brotsorte wir gerne hätten
    meal.toast = String::from(&quot;Weizen&quot;);
    println!(&quot;Ich möchte {}-Toast&quot;, meal.toast);

    // Die nächste Zeile lässt sich nicht kompilieren, wenn wir sie nicht
    // auskommentieren; wir dürfen die Früchte der Saison, die wir mit der
    // Mahlzeit bekommen, weder sehen noch verändern.
    // meal.seasonal_fruit = String::from(&quot;Heidelbeeren&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-9: Eine Struktur mit öffentlichen und
privaten Felder</span></p>
<p>Da das Feld <code>toast</code> in der Struktur <code>back_of_house::Breakfast</code> öffentlich ist,
können wir in <code>eat_at_restaurant</code> in das Feld <code>toast</code> schreiben und lesen,
indem wir die Punktnotation verwenden. Beachte, dass wir das Feld
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht verwenden können, weil
<code>seasonal_fruit</code> privat ist. Versuche, die Kommentarzeichen in der Zeile, die
den Feldwert <code>seasonal_fruit</code> modifiziert, zu entfernen, um zu sehen, welchen
Fehler du erhältst!</p>
<p>Beachte auch, dass, weil <code>back_of_house::Breakfast</code> ein privates Feld hat, die
Struktur eine öffentliche Funktion (hier haben wir sie <code>summer</code> genannt) zum
Erzeugen einer Instanz von <code>Breakfast</code> bereitstellen muss. Wenn <code>Breakfast</code>
keine solche Funktion hätte, könnten wir keine Instanz von <code>Breakfast</code> in
<code>eat_at_restaurant</code> erzeugen, weil wir den Wert des privaten Feldes
<code>seasonal_fruit</code> in <code>eat_at_restaurant</code> nicht setzen könnten.</p>
<p>Wenn wir dagegen eine Aufzählung veröffentlichen, dann sind alle ihre
Varianten öffentlich. Wir brauchen nur das Schlüsselwort <code>pub</code> vor dem
Schlüsselwort <code>enum</code>, wie in Codeblock 7-10 gezeigt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>mod back_of_house {
    pub enum Appetizer {
        Soup,
        Salad,
    }
}

pub fn eat_at_restaurant() {
    let order1 = back_of_house::Appetizer::Soup;
    let order2 = back_of_house::Appetizer::Salad;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-10: Kennzeichnen einer Aufzählung als
öffentlich macht alle ihre Varianten öffentlich</span></p>
<p>Da wir die Aufzählung <code>Appetizer</code> öffentlich gemacht haben, können wir die
Varianten <code>Soup</code> und <code>Salad</code> in <code>eat_at_restaurant</code> verwenden. Aufzählungen
wären ohne öffentliche Varianten nicht sehr nützlich; es wäre ärgerlich, alle
Aufzählungs-Varianten stets mit <code>pub</code> annotieren zu müssen, daher sind die
Aufzählungs-Varianten standardmäßig öffentlich. Strukturen sind auch ohne
öffentliche Felder nützlich, daher folgen Strukturfelder standardmäßig der
allgemeinen Regel, dass alles privat ist, es sei denn, es wird mit <code>pub</code>
kommentiert.</p>
<p>Es gibt noch eine weitere Situation mit <code>pub</code>, die wir noch nicht behandelt
haben, und das ist unser letztes Modulsystem-Feature: Das Schlüsselwort <code>use</code>.
Zuerst werden wir <code>use</code> an sich behandeln, und dann zeigen wir, wie man <code>pub</code>
und <code>use</code> kombiniert.</p>
<h2><a class="header" href="#pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use" id="pfade-in-den-gültigkeitsbereich-bringen-mit-dem-schlüsselwort-use">Pfade in den Gültigkeitsbereich bringen mit dem Schlüsselwort <code>use</code></a></h2>
<p>Es mag den Anschein haben, als seien die Pfade, die wir bisher geschrieben
haben, um Funktionen aufzurufen, unangenehm lang und wiederholend. Zum Beispiel
mussten wir in Codeblock 7-7, unabhängig davon, ob wir den absoluten oder
relativen Pfad zur Funktion <code>add_to_waitlist</code> wählten, bei jedem Aufruf von
<code>add_to_waitlist</code> auch <code>front_of_house</code> und <code>hosting</code> angeben. Glücklicherweise
gibt es einen Weg, diesen Vorgang zu vereinfachen. Wir können einen Pfad mit
dem Schlüsselwort <code>use</code> einmalig in einen Gültigkeitsbereich bringen und dann
die Elemente in diesem Pfad so aufrufen, als ob es sich um lokale Elemente
handelt. In Codeblock 7-11 bringen wir das Modul
<code>crate::front_of_house::hosting</code> in den Gültigkeitsbereich der Funktion
<code>eat_at_restaurant</code>, sodass wir nur noch <code>hosting::add_to_waitlist</code> angeben
müssen, um die Funktion <code>add_to_waitlist</code> in <code>eat_at_restaurant</code> aufzurufen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-11: Ein Modul mit <code>use</code> in den
Gültigkeitsbereich bringen</span></p>
<p>Das Angeben von <code>use</code> und einem Pfad in einem Gültigkeitsbereich ist ähnlich
dem Erstellen eines symbolischen Links im Dateisystem. Durch Hinzufügen von
<code>use crate::front_of_house::hosting</code> in der Kistenwurzel ist <code>hosting</code> nun ein
gültiger Name in diesem Gültigkeitsbereich, so als wäre das Modul <code>hosting</code> in
der Kistenwurzel definiert worden. Pfade, die mit <code>use</code> in den
Gültigkeitsbereich gebracht werden, überprüfen wie alle anderen Pfade auch die
Privatsphäre.</p>
<p>Du kannst ein Element auch mit <code>use</code> und einem relativen Pfad in den
Gültigkeitsbereich bringen. In Codeblock 7-12 wird gezeigt, wie ein relativer
Pfad angegeben werden kann, um dasselbe Verhalten wie in Codeblock 7-11 zu
erzielen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use self::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-12: Ein Modul mit <code>use</code> und einem relativen
Pfad in den Gültigkeitsbereich bringen</span></p>
<h3><a class="header" href="#idiomatische-use-pfade-erstellen" id="idiomatische-use-pfade-erstellen">Idiomatische <code>use</code>-Pfade erstellen</a></h3>
<p>In Codeblock 7-11 hast du dich vielleicht gefragt, warum wir <code>use crate::front_of_house::hosting</code> angegeben und dann <code>hosting::add_to_waitlist</code>
in <code>eat_at_restaurant</code> aufgerufen haben, anstatt den <code>use</code>-Pfad bis hin zur
Funktion <code>add_to_waitlist</code> anzugeben, um dasselbe Ergebnis zu erzielen wie in
Codeblock 7-13.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting::add_to_waitlist;

pub fn eat_at_restaurant() {
    add_to_waitlist();
    add_to_waitlist();
    add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-13: Die Funktion <code>add_to_waitlist</code> mit <code>use</code>
in den Gültigkeitsbereich bringen ist nicht idiomatisch.</span></p>
<p>Obwohl sowohl Codeblock 7-11 als auch Codeblock 7-13 die gleiche Aufgabe
erfüllen, ist Codeblock 7-11 der idiomatische Weg, eine Funktion mit <code>use</code> in
den Gültigkeitsbereich zu bringen. Wenn wir das Elternmodul der Funktion mit
<code>use</code> in den Gültigkeitsbereich bringen, sodass wir das Elternmodul beim Aufruf
der Funktion angeben müssen, wird klar, dass die Funktion nicht lokal definiert
ist, während gleichzeitig die Wiederholung des vollständigen Pfades minimiert
wird. Im Code in Codeblock 7-13 ist unklar, wo <code>add_to_waitlist</code> definiert ist.</p>
<p>Wenn andererseits Strukturen, Aufzählungen und andere Elemente mit <code>use</code>
eingebracht werden, ist es idiomatisch, den vollständigen Pfad anzugeben.
Codeblock 7-14 zeigt den idiomatischen Weg, die Struktur <code>HashMap</code> der
Standardbibliothek in den Gültigkeitsbereich einer binären Kiste zu bringen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
</code></pre></pre>
<p><span class="caption">Codeblock 7-14: <code>HashMap</code> auf idiomatische Weise in den
Gültigkeitsbereich bringen</span></p>
<p>Es gibt keinen triftigen Grund für dieses Idiom: Es ist einfach eine
Konvention, die entstanden ist, und die Leute haben sich daran gewöhnt,
Rust-Code auf diese Weise zu lesen und zu schreiben.</p>
<p>Die Ausnahme von diesem Idiom ist, wenn wir zwei gleichnamige Elemente mit
<code>use</code> in den Gültigkeitsbereich bringen, denn das lässt Rust nicht zu. In
Codeblock 7-15 wird gezeigt, wie zwei <code>Result</code>-Typen mit gleichem Namen, aber
unterschiedlichen Elternmodulen in den Gültigkeitsbereich gebracht werden und
wie auf sie verwiesen werden kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt;
use std::io;

fn function1() -&gt; fmt::Result {
    // --abschneiden--
    Ok(())
}

fn function2() -&gt; io::Result&lt;()&gt; {
    // --abschneiden--
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-15: Um zwei Typen mit dem gleichen Namen in
denselben Gültigkeitsbereich zu bringen, müssen ihre übergeordneten Module
angegeben werden.</span></p>
<p>Wie du sehen kannst, unterscheidet die Verwendung der übergeordneten Module die
beiden <code>Result</code>-Typen. Wenn wir stattdessen <code>use std::fmt::Result</code> und
<code>use std::io::Result</code> angeben würden, hätten wir zwei <code>Result</code>-Typen im selben
Gültigkeitsbereich und Rust wüsste nicht, welchen wir beim Verwenden von
<code>Result</code> meinten.</p>
<h3><a class="header" href="#mit-dem-schlüsselwort-as-neue-namen-vergeben" id="mit-dem-schlüsselwort-as-neue-namen-vergeben">Mit dem Schlüsselwort <code>as</code> neue Namen vergeben</a></h3>
<p>Es gibt eine andere Lösung für das Problem, zwei Typen desselben Namens mit
<code>use</code> in den gleichen Gültigkeitsbereich zu bringen: Hinter dem Pfad können wir
<code>as</code> und einen neuen lokalen Namen oder Alias für den Typ angeben. Codeblock
7-16 zeigt eine weitere Möglichkeit, den Code in Codeblock 7-15 zu schreiben,
indem einer der beiden <code>Result</code>-Typen mittels <code>as</code> umbenannt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -&gt; Result {
    // --abschneiden--
    Ok(())
}

fn function2() -&gt; IoResult&lt;()&gt; {
    // --abschneiden--
    Ok(())
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-16: Umbenennen eines Typs, wenn er mit dem
Schlüsselwort <code>as</code> in den Gültigkeitsbereich gebracht wird</span></p>
<p>In der zweiten <code>use</code>-Anweisung wählten wir den neuen Namen <code>IoResult</code> für den
Typ <code>std::io::result</code>, der nicht im Konflikt zum ebenfalls von uns in den
Gültigkeitsbereich gebrachten <code>Result</code> aus <code>std::fmt</code> steht. Codeblock 7-15
und Codeblock 7-16 gelten als idiomatisch, die Wahl liegt also bei dir!</p>
<h3><a class="header" href="#rück-exportieren-von-namen-mit-pub-use" id="rück-exportieren-von-namen-mit-pub-use">Rück-Exportieren von Namen mit <code>pub use</code></a></h3>
<p>Wenn wir einen Namen mit dem Schlüsselwort <code>use</code> in den Gültigkeitsbereich
bringen, ist der im neuen Gültigkeitsbereich verfügbare Name privat. Damit der
Code, der unseren Code aufruft, auf diesen Namen verweisen kann, als wäre er im
Gültigkeitsbereich dieses Codes definiert worden, können wir <code>pub</code> und <code>use</code>
kombinieren. Diese Technik wird <em>Rück-Exportieren</em> (re-exporting) genannt, weil
wir ein Element in den Gültigkeitsbereich bringen, dieses Element aber auch
anderen zur Verfügung stellen, um es in ihren Gültigkeitsbereich zu bringen.</p>
<p>Codeblock 7-17 zeigt den Code in Codeblock 7-11, wobei <code>use</code> im Wurzelmodul in
<code>pub use</code> geändert wurde.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-17: Bereitstellen eines Namens für externen
Code zum Verwenden in einem neuen Gültigkeitsbereich mit <code>pub use</code></span></p>
<p>Durch Verwenden von <code>pub use</code> kann jetzt externer Code die Funktion
<code>add_to_waitlist</code> unter Verwendung von <code>hosting::add_to_waitlist</code> aufrufen.
Hätten wir nicht <code>pub use</code> angegeben, könnte die Funktion <code>eat_at_restaurant</code>
in ihrem Gültigkeitsbereich <code>hosting::add_to_waitlist</code> aufrufen, aber externer
Code könnte diesen neuen Pfad nicht nutzen.</p>
<p>Der Rück-Export ist nützlich, wenn sich die interne Struktur deines Codes von
dem unterscheidet, wie Programmierer, die deinen Code
aufrufen, über die Domäne denken würden. In der Restaurantmetapher denken die
Betreiber des Restaurants zum Beispiel an die „Vorderseite des Hauses“ und die
„Rückseite des Hauses“. Mit <code>pub use</code> können wir unseren Code mit einer
Struktur schreiben, aber eine andere Struktur veröffentlichen. Auf diese Weise
ist unsere Bibliothek für Programmierer, die an der Bibliothek arbeiten, und
Programmierer, die die Bibliothek aufrufen, gut organisiert.</p>
<h3><a class="header" href="#verwenden-externer-pakete" id="verwenden-externer-pakete">Verwenden externer Pakete</a></h3>
<p>In Kapitel 2 programmierten wir ein Ratespielprojekt, das ein externes Paket
namens <code>rand</code> benutzte, um Zufallszahlen zu generieren. Um <code>rand</code> in unserem
Projekt zu verwenden, fügten wir diese Zeile zu <em>Cargo.toml</em> hinzu:</p>
<p><span class="filename">Dateiname: Cargo.toml</span></p>
<pre><code class="language-toml">[dependencies]
rand = &quot;0.5.5&quot;
</code></pre>
<p>Das Hinzufügen von <code>rand</code> als Abhängigkeit in <em>Cargo.toml</em> weist Cargo an, das
Paket <code>rand</code> und alle Abhängigkeiten von <a href="https://crates.io/">crates.io</a>
herunterzuladen und <code>rand</code> für unser Projekt verfügbar zu machen.</p>
<p>Um dann Definitionen von <code>rand</code> in den Gültigkeitsbereich unseres Pakets
aufzunehmen, fügten wir eine Zeile mit <code>use</code> hinzu, die mit dem Kistennamen
<code>rand</code> begann, und listeten die Elemente auf, die wir in den Gültigkeitsbereich
aufnehmen wollten. Erinnere dich, dass wir im Abschnitt <a href="ch02-00-guessing-game-tutorial.html#generating-a-random-number">„Generierung einer
Zufallszahl“</a> in Kapitel 2 das Merkmal <code>Rng</code> in den Gültigkeitsbereich
gebracht und die Funktion <code>rand::thread_rng</code> aufgerufen haben:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">use std::io;
</span>use rand::Rng;

fn main() {
<span class="boring">    println!(&quot;Rate die Zahl!&quot;);
</span><span class="boring">
</span>    let secret_number = rand::thread_rng().gen_range(1, 101);
<span class="boring">
</span><span class="boring">    println!(&quot;Die geheime Zahl ist: {}&quot;, secret_number);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Bitte gib deine Vermutung ein.&quot;);
</span><span class="boring">
</span><span class="boring">    let mut guess = String::new();
</span><span class="boring">
</span><span class="boring">    io::stdin()
</span><span class="boring">        .read_line(&amp;mut guess)
</span><span class="boring">        .expect(&quot;Fehler beim Lesen einer Zeile&quot;);
</span><span class="boring">
</span><span class="boring">    println!(&quot;Du hast geraten: {}&quot;, guess);
</span>}
</code></pre></pre>
<p>Mitglieder der Rust-Gemeinschaft haben viele Pakete unter
<a href="https://crates.io/">crates.io</a> zur Verfügung gestellt und wenn du eines davon
in dein Paket aufnimmst, sind die gleichen Schritte erforderlich: Liste sie
in der Datei <em>Cargo.toml</em> deines Pakets auf und verwende <code>use</code>, um Elemente aus
ihren Kisten in den Gültigkeitsbereich zu bringen.</p>
<p>Beachte, dass die Standardbibliothek (<code>std</code>) ebenfalls eine Kiste ist, die
nicht zu unserem Paket gehört. Da die Standardbibliothek mit der Sprache Rust
ausgeliefert wird, brauchen wir <em>Cargo.toml</em> nicht zu ändern, um <code>std</code>
einzubinden. Aber wir müssen <code>use</code> verwenden, um Elemente von dort in den
Gültigkeitsbereich unseres Pakets zu bringen. Zum Beispiel würden wir für
<code>HashMap</code> diese Zeile verwenden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;
<span class="boring">}
</span></code></pre></pre>
<p>Dies ist ein absoluter Pfad, der mit <code>std</code>, dem Namen der
Standard-Bibliothekskiste, beginnt.</p>
<h3><a class="header" href="#verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen" id="verschachtelte-pfade-verwenden-um-lange-use-listen-zu-vereinfachen">Verschachtelte Pfade verwenden, um lange <code>use</code>-Listen zu vereinfachen</a></h3>
<p>Wenn wir mehrere in der gleichen Kiste oder im gleichen Modul definierte
Elemente verwenden, kann das Auflisten jedes Elements in einer eigenen Zeile
viel vertikalen Platz in unseren Dateien einnehmen. Zum Beispiel bringen diese
beiden <code>use</code>-Anweisungen, die wir im Ratespiel in Codeblock 2-4 hatten,
Elemente aus <code>std</code> in den Gültigkeitsbereich:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::cmp::Ordering;
use std::io;
<span class="boring">}
</span></code></pre></pre>
<p>Stattdessen können wir verschachtelte Pfade verwenden, um die gleichen Elemente
in einer Zeile in den Gültigkeitsbereich zu bringen. Wir tun dies, indem wir
den gemeinsamen Teil des Pfades angeben, gefolgt von zwei Doppelpunkten und
dann geschweiften Klammern um Liste der Pfadteile, die sich unterscheiden, wie
in Codeblock 7-18 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::{cmp::Ordering, io};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-18: Angeben eines verschachtelten Pfades, um
mehrere Elemente mit demselben Präfix in den Gültigkeitsbereich zu
bringen</span></p>
<p>In größeren Programmen kann das Einbeziehen vieler Elemente aus derselben Kiste
oder demselben Modul in den Gültigkeitsbereich durch verschachtelte Pfade die
Anzahl der separaten <code>use</code>-Anweisungen um ein Vielfaches reduzieren!</p>
<p>Wir können einen verschachtelten Pfad auf jeder Ebene in einem Pfad verwenden,
was nützlich ist, wenn zwei <code>use</code>-Anweisungen kombiniert werden, die sich einen
Teilpfad teilen. Beispielsweise zeigt Codeblock 7-19 zwei <code>use</code>-Anweisungen:
Eine, die <code>std::io</code> in den Gültigkeitsbereich bringt, und eine, die
<code>std::io::Write</code> in den Gültigkeitsbereich bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io;
use std::io::Write;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-19: Zwei <code>use</code>-Anweisungen, bei denen eine
ein Teilpfad der anderen ist</span></p>
<p>Der gemeinsame Teil dieser beiden Pfade ist <code>std::io</code> und das ist der
vollständige erste Pfad. Um diese beiden Pfade zu einer einzigen
<code>use</code>-Anweisung zu verschmelzen, können wir <code>self</code> im verschachtelten Pfad
verwenden, wie in Codeblock 7-20 gezeigt wird.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::io::{self, Write};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 7-20: Zusammenfassen der Pfade aus Codeblock
7-19 zu einer <code>use</code>-Anweisung</span></p>
<p>Diese Zeile bringt <code>std::io</code> und <code>std::io::Write</code> in den Gültigkeitsbereich.</p>
<h3><a class="header" href="#der-stern-operator-glob" id="der-stern-operator-glob">Der Stern-Operator (glob)</a></h3>
<p>Wenn wir <em>alle</em> öffentlichen Elemente, die in einem Pfad definiert sind, in den
Gültigkeitsbereich bringen wollen, können wir diesen Pfad gefolgt von <code>*</code>, dem
Stern-Operator, angeben:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::*;
<span class="boring">}
</span></code></pre></pre>
<p>Diese <code>use</code>-Anweisung bringt alle öffentlichen Elemente, die in
<code>std::collections</code> definiert sind, in den aktuellen Gültigkeitsbereich. Sei
vorsichtig beim Verwenden des Stern-Operators! Er kann es schwieriger machen,
zu erkennen, welche Namen in den Gültigkeitsbereich fallen und wo ein in deinem
Programm verwendeter Name definiert wurde.</p>
<p>Der Stern-Operator wird oft beim Testen verwendet, um alles, was getestet wird,
in das Modul <code>tests</code> zu bringen. Wir werden darüber im Abschnitt <a href="ch11-01-writing-tests.html">„Tests
schreiben“</a> in Kapitel 11 sprechen. Der Stern-Operator wird
manchmal auch als Teil des Präludiumsmusters (prelude pattern) verwendet: Siehe
<a href="https://doc.rust-lang.org/std/prelude/index.html#other-preludes">Standardbibliotheksdokumentation</a> für weitere Informationen
zu diesem Muster.</p>
<h2><a class="header" href="#module-in-verschiedene-dateien-aufteilen" id="module-in-verschiedene-dateien-aufteilen">Module in verschiedene Dateien aufteilen</a></h2>
<p>Bisher haben alle Beispiele in diesem Kapitel mehrere Module in einer Datei
definiert. Wenn Module groß werden, solltest du ihre Definitionen in eine
separate Datei verschieben, um die Navigation im Code zu erleichtern.</p>
<p>Beginnen wir beispielsweise mit dem Code in Codeblock 7-17 und verschieben das
Modul <code>front_of_house</code> in seine eigene Datei <em>src/front_of_house.rs</em>, indem wir
die Kistenwurzeldatei so ändern, dass sie den in Codeblock 7-21 gezeigten Code
enthält. In diesem Fall ist die Kistenwurzeldatei <em>src/lib.rs</em>, aber dieses
Vorgehensweise funktioniert auch mit binären Kisten, deren Kistenwurzeldatei
<em>src/main.rs</em> ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><code class="language-rust ignore">mod front_of_house;

pub use crate::front_of_house::hosting;

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
    hosting::add_to_waitlist();
}
</code></pre>
<p><span class="caption">Codeblock 7-21: Deklarieren des Moduls <code>front_of_house</code>,
dessen Rumpf sich in <em>src/front_of_house.rs</em> befinden wird</span></p>
<p>Und <em>src/front_of_house.rs</em> erhält die Definitionen aus dem Modulrumpf von
<code>front_of_house</code>, wie in Codeblock 7-22 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting {
    pub fn add_to_waitlist() {}
}
</code></pre>
<p><span class="caption">Codeblock 7-22: Definitionen innerhalb des Moduls
<code>front_of_house</code> in <em>src/front_of_house.rs</em></span></p>
<p>Das Verwenden eines Semikolons nach <code>mod front_of_house</code> anstelle eines Blocks
weist Rust an, den Inhalt des Moduls aus einer anderen Datei mit dem gleichen
Namen wie das Modul zu laden. Um mit unserem Beispiel fortzufahren und das
Modul <code>hosting</code> ebenfalls in seine eigene Datei zu extrahieren, ändern wir
<em>src/front_of_house.rs</em> so, dass es nur die Deklaration des Moduls <code>hosting</code>
enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house.rs</span></p>
<pre><code class="language-rust ignore">pub mod hosting;
</code></pre>
<p>Dann erstellen wir ein Verzeichnis <em>src/front_of_house</em> und eine Datei
<em>src/front_of_house/hosting.rs</em>, die die im Modul <code>hosting</code> vorgenommenen
Definitionen enthält:</p>
<p><span class="filename">Dateiname: src/front_of_house/hosting.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add_to_waitlist() {}
<span class="boring">}
</span></code></pre></pre>
<p>Der Modulbaum bleibt derselbe und die Funktionsaufrufe in <code>eat_at_restaurant</code>
funktionieren ohne jede Änderung, auch wenn sich die Definitionen in
verschiedenen Dateien befinden. Mit dieser Technik kannst du Module in neue
Dateien verschieben, wenn diese größer werden.</p>
<p>Beachte, dass sich die Anweisung <code>pub use crate::front_of_house::hosting</code> in
<em>src/lib.rs</em> ebenfalls nicht geändert hat und dass <code>use</code> keinen Einfluss darauf
hat, welche Dateien als Teil der Kiste kompiliert werden. Das Schlüsselwort
<code>mod</code> deklariert Module und Rust sucht in einer Datei mit dem Modulnamen nach
dem Code, der zu diesem Modul gehört.</p>
<h2><a class="header" href="#zusammenfassung-3" id="zusammenfassung-3">Zusammenfassung</a></h2>
<p>Mit Rust kannst du ein Paket in mehrere Kisten und eine Kiste in Module
aufteilen, sodass du auf in einem Modul definierte Elemente aus einem anderen
Modul verweisen kannst. Du kannst dies tun, indem du absolute oder relative
Pfade angibst. Diese Pfade können mit einer <code>use</code>-Anweisung in den
Gültigkeitsbereich gebracht werden, sodass du einen kürzeren Pfad für mehrere
Verwendungen des Elements in diesem Geltungsbereich angeben kannst. Der
Modulcode ist standardmäßig privat, aber du kannst Definitionen öffentlich
machen, indem du das Schlüsselwort <code>pub</code> angibst.</p>
<p>Im nächsten Kapitel werden wir uns einige Kollektionsdatenstrukturen in der
Standardbibliothek ansehen, die du in deinem ordentlich organisierten Code
verwenden kannst.</p>
<h1><a class="header" href="#allgemeine-kollektionen" id="allgemeine-kollektionen">Allgemeine Kollektionen</a></h1>
<p>Die Standardbibliothek von Rust enthält eine Reihe sehr nützlicher
Datenstrukturen, die <em>Kollektionen</em> (collections) genannt werden. Die meisten
anderen Datentypen repräsentieren einen bestimmten Wert, aber Kollektionen
können mehrere Werte enthalten. Im Gegensatz zu den eingebauten Array- und
Tupel-Typen werden die Daten, auf die diese Kollektionen zeigen, im dynamischen
Speicher abgelegt, was bedeutet, dass die Datenmenge zur Kompilierzeit nicht
bekannt sein muss und während der Programmausführung wachsen oder schrumpfen
kann. Jede Kollektionsart hat unterschiedliche Fähigkeiten und Kosten, und die
Auswahl einer für deine aktuelle Situation geeigneten Kollektion ist eine
Fähigkeit, die du im Laufe der Zeit entwickeln wirst. In diesem Kapitel
besprechen wir drei Kollektionen, die sehr häufig in Rust-Programmen verwendet
werden:</p>
<ul>
<li>Ein <em>Vektor</em> erlaubt es dir, eine variable Anzahl von Werten nebeneinander zu
speichern.</li>
<li>Eine <em>Zeichenkette</em> ist eine Kollektion von Zeichen. Wir haben den Typ
<code>String</code> bereits kennengelernt, aber in diesem Kapitel werden wir ausführlich
darauf eingehen.</li>
<li>Eine <em>Hashtabelle</em> (hash map) erlaubt es dir, einen Wert mit einem
bestimmten Schlüssel zu assoziieren. Es ist eine spezielle Implementierung
der allgemeineren Datenstruktur, die <em>assoziatives Datenfeld</em> (map) genannt
wird.</li>
</ul>
<p>Informationen über weitere Kollektionsarten, die von der Standardbibliothek
bereitgestellt werden, findest du in <a href="https://doc.rust-lang.org/std/collections/index.html">der Dokumentation</a>.</p>
<p>Wir werden erörtern, wie Vektoren, Zeichenketten und Hashtabellen erstellt und
aktualisiert werden und was jede einzelne besonders macht.</p>
<h2><a class="header" href="#wertlisten-in-vektoren-ablegen" id="wertlisten-in-vektoren-ablegen">Wertlisten in Vektoren ablegen</a></h2>
<p>Der erste Kollektionstyp, den wir betrachten werden, ist <code>Vec&lt;T&gt;</code>, auch bekannt
als <em>Vektor</em>. Vektoren ermöglichen es dir, mehr als einen Wert in einer
einzigen Datenstruktur zu speichern and alle Werte nebeneinander im Speicher
abzulegen. Vektoren können nur Werte desselben Typs speichern. Sie sind nützlich,
wenn du eine Liste von Einträgen hast, z.B. die Textzeilen einer Datei oder die
Preise der Artikel in einem Einkaufswagen.</p>
<h3><a class="header" href="#erstellen-eines-neuen-vektors" id="erstellen-eines-neuen-vektors">Erstellen eines neuen Vektors</a></h3>
<p>Um einen neuen, leeren Vektor zu erstellen, können wir die Funktion <code>Vec::new</code>
aufrufen, wie in Codeblock 8-1 gezeigt.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v: Vec&lt;i32&gt; = Vec::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-1: Erstellen eines neuen, leeren Vektors zur
Aufnahme von Werten des Typs <code>i32</code></span></p>
<p>Beachte, dass wir hier eine Typ-Annotation hinzugefügt haben. Da wir keine
Werte in diesen Vektor einfügen, weiß Rust nicht, welche Art von Elementen wir
zu speichern beabsichtigen. Dies ist ein wichtiger Punkt. Vektoren werden mit
Hilfe generischer Typen implementiert; wie du eigene generische Typen verwenden
kannst, wird in Kapitel 10 behandelt. Für den Moment sollst du wissen, dass der
von der Standardbibliothek bereitgestellte Typ <code>Vec&lt;T&gt;</code> jeden Typ enthalten
kann, und wenn ein bestimmter Vektor einen bestimmten Typ enthält, wird der Typ
in spitzen Klammern angegeben. In Codeblock 8-1 haben wir Rust gesagt, dass der
Vektor <code>Vec&lt;T&gt;</code> in <code>v</code> Elemente des Typs <code>i32</code> enthalten wird.</p>
<p>In realistischerem Code kann Rust oft auf den Typ des Wertes schließen, den du
nach dem Einfügen von Werten speichern möchtest, sodass du diese Art der
Annotation nur selten verwenden musst. Häufiger kommt es vor, einen <code>Vec&lt;T&gt;</code> zu
erstellen, der Anfangswerte hat, und Rust stellt der Einfachheit halber das
Makro <code>vec!</code> zur Verfügung. Das Makro erstellt einen neuen Vektor, der die von
dir angegebenen Werte enthält. Codeblock 8-2 erzeugt einen neuen <code>Vec&lt;i32&gt;</code>,
der die Werte <code>1</code>, <code>2</code> und <code>3</code> enthält. Als Integer-Typ wird <code>i32</code> verwendet,
weil das der Standard-Integer-Typ ist, wie wir im Abschnitt
<a href="ch03-02-data-types.html#data-types">„Datentypen“</a> in Kapitel 3 besprochen haben.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-2: Erstellen eines neuen Vektors mit
Werten</span></p>
<p>Da wir initiale <code>i32</code>-Werte angegeben haben, kann Rust daraus schließen, dass
<code>v</code> den Typ <code>Vec&lt;i32&gt;</code> hat, und die Typ-Annotation ist nicht notwendig. Als
Nächstes werden wir uns ansehen, wie man einen Vektor modifiziert.</p>
<h3><a class="header" href="#aktualisieren-eines-vektors" id="aktualisieren-eines-vektors">Aktualisieren eines Vektors</a></h3>
<p>Um einen Vektor zu erstellen und ihm dann Elemente hinzuzufügen, können wir die
Methode <code>push</code> verwenden, wie in Codeblock 8-3 zu sehen ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = Vec::new();

v.push(5);
v.push(6);
v.push(7);
v.push(8);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-3: Verwenden der Methode <code>push</code> zum
Hinzufügen von Werten zu einem Vektor</span></p>
<p>Wie bei jeder Variablen müssen wir, wenn wir ihren Wert ändern wollen, sie mit
dem Schlüsselwort <code>mut</code> als veränderlich markieren, wie in Kapitel 3
besprochen. Die Zahlen, die wir darin platzieren, sind alle vom Typ <code>i32</code>, und
Rust leitet dies aus den Daten ab, sodass wir die Annotation <code>Vec&lt;i32&gt;</code> nicht
benötigen.</p>
<h3><a class="header" href="#beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt" id="beim-aufräumen-eines-vektors-werden-seine-elemente-aufgeräumt">Beim Aufräumen eines Vektors werden seine Elemente aufgeräumt</a></h3>
<p>Wie bei jeder anderen Struktur wird ein Vektor freigegeben, wenn er den
Gültigkeitsbereich verlässt, wie in Codeblock 8-4 kommentiert wird.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>{
    let v = vec![1, 2, 3, 4];

    // mache etwas mit v
} // &lt;- v verlässt den Gültigkeitsbereich und wird hier freigegeben
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-4: Zeigt, wo der Vektor und seine Elemente
aufgeräumt werden</span></p>
<p>Wenn der Vektor aufgeräumt wird, wird auch sein gesamter Inhalt aufgeräumt,
d.h. die ganzen Zahlen, die er enthält, werden beseitigt. Dies mag recht
einfach erscheinen, kann aber etwas komplizierter werden, wenn du anfängst,
Referenzen auf Elemente des Vektors einzuführen. Lass uns das als Nächstes
angehen!</p>
<h3><a class="header" href="#elemente-aus-vektoren-lesen" id="elemente-aus-vektoren-lesen">Elemente aus Vektoren lesen</a></h3>
<p>Da du jetzt weißt, wie man Vektoren erstellt, aktualisiert und aufräumt, ist es
ein guter nächster Schritt zu wissen, wie man ihre Inhalte ausliest. Es gibt
zwei Möglichkeiten, einen in einem Vektor gespeicherten Wert zu referenzieren. 
In den Beispielen haben wir zur besseren Lesbarkeit die Werttypen, die von den
Funktionen zurückgegeben werden, mit angegeben.</p>
<p>Codeblock 8-5 zeigt beide Zugriffsmethoden auf einen Wert in einem Vektor,
mittels Indexierungssyntax und die Methode <code>get</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let third: &amp;i32 = &amp;v[2];
println!(&quot;Das dritte Element ist {}&quot;, third);

match v.get(2) {
    Some(third) =&gt; println!(&quot;Das dritte Element ist {}&quot;, third),
    None =&gt; println!(&quot;Es gibt kein drittes Element.&quot;),
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-5: Verwenden der Indexierungssyntax und der
Methode <code>get</code> für den Zugriff auf ein Element in einem Vektor</span></p>
<p>Beachte hier zwei Details. Erstens verwenden wir den Indexwert <code>2</code>, um das
dritte Element zu erhalten: Vektoren werden mit Zahlen indiziert, beginnend bei
null. Zweitens gibt es zwei Möglichkeiten, das dritte Element zu erhalten:
Entweder durch Verwendung von <code>&amp;</code> und <code>[]</code>, was eine Referenz ergibt, oder
durch die Methode <code>get</code> mit dem Index als Argument, was eine <code>Option&lt;&amp;T&gt;</code>
ergibt.</p>
<p>Rust hat zwei Möglichkeiten, ein Element zu referenzieren, sodass du bestimmen
kannst, wie sich das Programm verhalten soll, wenn du versuchst, einen
Indexwert zu verwenden, für den der Vektor kein Element enthält. Als Beispiel
wollen wir sehen, was ein Programm tut, wenn wir bei einem Vektor mit fünf
Elementen versuchen, auf ein Element mit Index 100 zuzugreifen, wie in
Codeblock 8-6 zu sehen ist.</p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![1, 2, 3, 4, 5];

let does_not_exist = &amp;v[100];
let does_not_exist = v.get(100);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-6: Versuch, auf das Element mit Index 100 in
einem Vektor zuzugreifen, der fünf Elemente enthält</span></p>
<p>Wenn wir diesen Code ausführen, wird die Variante <code>[]</code> das Programm abbrechen
lassen, weil es auf ein nicht existierendes Element verweist. Diese Methode
wird vorzugsweise verwendet, wenn du dein Programm abstürzen lassen möchtest,
wenn versucht wird, auf ein Element hinter dem Ende des Vektors zuzugreifen.</p>
<p>Wenn der Methode <code>get</code> ein Index außerhalb des Vektors übergeben wird, gibt sie
<code>None</code> zurück, ohne abzubrechen. Du würdest diese Methode verwenden, wenn der
Zugriff auf ein Element außerhalb des Bereichs des Vektors unter normalen
Umständen gelegentlich vorkommt. Dein Code wird dann eine Logik haben, die mit
<code>Some(&amp;element)</code> und <code>None</code> umgehen kann, wie in Kapitel 6 besprochen. Der
Index könnte zum Beispiel von einer Person stammen, die eine Zahl eingibt. Wenn
sie versehentlich eine zu große Zahl eingibt und das Programm einen <code>None</code>-Wert
erhält, kannst du dem Benutzer mitteilen, wie viele Elemente sich aktuell im
Vektor befinden und ihm eine weitere Chance geben, einen gültigen Wert
einzugeben. Das wäre benutzerfreundlicher, als das Programm wegen eines
Tippfehlers abstürzen zu lassen!</p>
<p>Wenn das Programm über eine gültige Referenz verfügt, stellt der
Ausleihenprüfer mittels Eigentümerschafts- und Ausleihregeln (siehe Kapitel 4)
sicher, dass diese Referenz und alle anderen Referenzen auf den Inhalt des
Vektors gültig bleiben. Erinnere dich an die Regel, die besagt, dass du keine
veränderlichen und unveränderlichen Referenzen im gleichen Gültigkeitsbereich
haben kannst. Diese Regel trifft in Codeblock 8-7 zu, wo wir eine
unveränderliche Referenz auf das erste Element in einem Vektor halten und
versuchen, am Ende ein Element hinzuzufügen, was nicht funktionieren wird.</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5];

let first = &amp;v[0];

v.push(6);

println!(&quot;Das erste Element ist: {}&quot;, first);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-7: Versuch, ein Element zu einem Vektor
hinzuzufügen, während eine Referenz auf ein Element gehalten wird</span></p>
<p>Das Kompilieren dieses Codes führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable
 --&gt; src/main.rs:6:5
  |
4 |     let first = &amp;v[0];
  |                  - immutable borrow occurs here
5 | 
6 |     v.push(6);
  |     ^^^^^^^^^ mutable borrow occurs here
7 | 
8 |     println!(&quot;Das erste Element ist: {}&quot;, first);
  |                                           ----- immutable borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0502`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Code in Codeblock 8-7 sieht so aus, als könnte er funktionieren: Warum
sollte sich eine Referenz auf das erste Element darum kümmern, was sich am
Ende des Vektors ändert? Dieser Fehler ist in der Funktionsweise von Vektoren
begründet: Das Hinzufügen eines neuen Elements am Ende des Vektors könnte die
Allokation neuen Speichers und das Kopieren der alten Elemente an die neue
Stelle erfordern, wenn nicht genügend Platz vorhanden ist, um alle Elemente
nebeneinander an der aktuellen Stelle des Vektors zu platzieren. In diesem Fall
würde die Referenz auf das erste Element auf einen freigegebenen Speicherplatz
verweisen. Die Ausleihregeln verhindern, dass Programme in diese Situation
geraten.</p>
<blockquote>
<p>Anmerkung: Weitere Einzelheiten zu den Implementierungsdetails des Typs
<code>Vec&lt;T&gt;</code> findest du in <a href="https://doc.rust-lang.org/nomicon/vec.html">„Das Rustonomicon“</a>.</p>
</blockquote>
<h3><a class="header" href="#iterieren-über-die-werte-in-einem-vektor" id="iterieren-über-die-werte-in-einem-vektor">Iterieren über die Werte in einem Vektor</a></h3>
<p>Wenn wir auf die Elemente eines Vektors der Reihe nach zugreifen wollen, können
wir über alle Elemente iterieren, anstatt Indizes zu verwenden, um auf jeweils
ein Element zur gleichen Zeit zuzugreifen. Codeblock 8-8 zeigt, wie man eine
<code>for</code>-Schleife verwendet, um unveränderliche Referenzen auf die Elemente eines
Vektors von <code>i32</code>-Werten zu erhalten und diese auszugeben.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let v = vec![100, 32, 57];
for i in &amp;v {
    println!(&quot;{}&quot;, i);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-8: Ausgeben aller Elemente eines Vektors
durch Iterieren über die Elemente mittels <code>for</code>-Schleife</span></p>
<p>Wir können auch über veränderliche Referenzen der Elemente eines veränderlichen
Vektors iterieren, um Änderungen an allen Elementen vorzunehmen. Die
<code>for</code>-Schleife in Codeblock 8-9 addiert zu jedem Element <code>50</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut v = vec![100, 32, 57];
for i in &amp;mut v {
    *i += 50;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-9: Iterieren über veränderliche Referenzen
der Elemente eines Vektors</span></p>
<p>Um den Wert, auf den sich die veränderliche Referenz bezieht, zu ändern, müssen
wir den Dereferenzierungsoperator (<code>*</code>) verwenden, um an den Wert in <code>i</code> zu
kommen, bevor wir den Operator <code>+=</code> verwenden können. Wir werden mehr über den
Dereferenzierungsoperator im Abschnitt <a href="ch15-02-deref.html#following-the-pointer-to-the-value-with-the-dereference-operator">„Dem Zeiger zum Wert folgen mit dem
Dereferenzierungsoperator“</a> in Kapitel 15 sprechen.</p>
<h3><a class="header" href="#verwenden-einer-aufzählung-zum-speichern-mehrerer-typen" id="verwenden-einer-aufzählung-zum-speichern-mehrerer-typen">Verwenden einer Aufzählung zum Speichern mehrerer Typen</a></h3>
<p>Zu Beginn dieses Kapitels haben wir gesagt, dass Vektoren nur Werte desselben
Typs speichern können. Das kann unbequem sein; es gibt definitiv
Anwendungsfälle, in denen es notwendig ist, eine Liste von Einträgen
unterschiedlicher Typen zu speichern. Glücklicherweise werden die Varianten
einer Aufzählung unter dem gleichen Aufzählungstyp definiert. Wenn wir also
Elemente eines anderen Typs in einem Vektor speichern wollen, können wir eine
Aufzählung definieren und verwenden! Angenommen, wir möchten Werte aus einer
Zeile einer Tabellenkalkulationstabelle erhalten, in der einige Spalten der
Zeile ganze Zahlen, Fließkommazahlen und Zeichenketten enthalten.  Wir können
eine Aufzählung definieren, deren Varianten die verschiedenen Werttypen
enthalten, und dann werden alle Aufzählungsvarianten als derselbe Typ
angesehen: Der Typ der Aufzählung. Dann können wir einen Vektor erstellen, der
diese Aufzählung und damit letztlich verschiedene Typen enthält. Wir haben dies
in Codeblock 8-10 demonstriert.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum SpreadsheetCell {
    Int(i32),
    Float(f64),
    Text(String),
}

let row = vec![
    SpreadsheetCell::Int(3),
    SpreadsheetCell::Text(String::from(&quot;blau&quot;)),
    SpreadsheetCell::Float(10.12),
];
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-10: Definieren eines <code>enum</code>, um Werte
verschiedener Typen in einem Vektor zu speichern</span></p>
<p>Rust muss wissen, welche Typen zur Kompilierzeit im Vektor enthalten sein
werden, damit es genau weiß, wie viel Speicherplatz im dynamischen Speicher
benötigt wird, um alle Elemente zu speichern. Ein zweiter Vorteil ist, dass wir
explizit festlegen können, welche Typen in diesem Vektor erlaubt sind. Wenn
Rust einen Vektor mit beliebigen Typen zuließe, bestünde die Möglichkeit, dass
einer oder mehrere Typen Fehler bei den an den Elementen des Vektors
durchgeführten Operationen verursachen würden. Das Verwenden einer Aufzählung
zusammen mit einem <code>match</code>-Ausdruck bedeutet, dass Rust zur Kompilierzeit
sicherstellt, dass jeder mögliche Fall behandelt wird, wie in Kapitel 6
besprochen.</p>
<p>Wenn du ein Programm schreibst und nicht weißt, welche Typen das Programm zur
Laufzeit in einen Vektor speichern wird, funktioniert der Aufzählungsansatz
nicht. Stattdessen kannst du ein Merkmalsobjekt (trait object) verwenden, das
wir in Kapitel 17 behandeln werden.</p>
<p>Nachdem wir nun einige der gängigsten Methoden zur Verwendung von Vektoren
besprochen haben, solltest du dir unbedingt die API-Dokumentation zu den vielen
nützlichen Methoden ansehen, die die Standardbibliothek für <code>Vec&lt;T&gt;</code> mitbringt. 
Zum Beispiel gibt es zusätzlich zu <code>push</code> die Methode <code>pop</code>, die das letzte
Element entfernt und zurückgibt. Lass uns zum nächsten Kollektionstyp
übergehen: <code>String</code></p>
<h2><a class="header" href="#utf-8-kodierten-text-in-zeichenketten-strings-ablegen" id="utf-8-kodierten-text-in-zeichenketten-strings-ablegen">UTF-8-kodierten Text in Zeichenketten (strings) ablegen</a></h2>
<p>Wir haben in Kapitel 4 über Zeichenketten (strings) gesprochen, aber wir werden
uns jetzt eingehender damit befassen. Neue Rust-Entwickler haben gewöhnlich aus
einer Kombination von drei Gründen Probleme mit Zeichenketten: Rusts Neigung,
mögliche Fehler aufzudecken, Zeichenketten als eine kompliziertere
Datenstruktur, als viele Programmierer ihnen zugestehen, und UTF-8. Diese
Faktoren kombinieren sich in einer Weise, die schwierig erscheinen kann, wenn
man von anderen Programmiersprachen kommt.</p>
<p>Es ist hilfreich, Zeichenketten im Kontext von Kollektionen zu diskutieren, da
Zeichenketten als Byte-Kollektion implementiert sind, sowie einige Methoden,
die nützliche Funktionalitäten bieten, wenn diese Bytes als Text interpretiert
werden. In diesem Abschnitt werden wir über <code>String</code>-Operationen sprechen, die
jeder Kollektionstyp hat, wie das Erstellen, Aktualisieren und Lesen. Wir
werden auch die Art und Weise besprechen, in der sich <code>String</code> von den anderen
Kollektionen unterscheidet, nämlich warum die Indexierung bei einem <code>String</code>
kompliziert ist, weil Menschen und Computer <code>String</code>-Daten unterschiedlich
interpretieren.</p>
<h3><a class="header" href="#was-ist-eine-zeichenkette" id="was-ist-eine-zeichenkette">Was ist eine Zeichenkette?</a></h3>
<p>Zuerst werden wir definieren, was wir mit dem Begriff <em>Zeichenkette</em> (string)
meinen. Rust hat nur einen einzigen Zeichenkettentyp in der Kernsprache,
nämlich den Zeichenkettenanteilstyp <code>str</code>, der üblicherweise in seiner
Ausleihenform <code>&amp;str</code> zu sehen ist. In Kapitel 4 sprachen wir über
<em>Zeichenkettenanteilstypen</em> (string slices), die Referenzen auf einige
UTF-8-kodierte Zeichenkettendaten sind, die anderswo gespeichert sind.
Zeichenkettenliterale werden beispielsweise in der Binärdatei des Programms
gespeichert und sind daher Zeichenkettenanteilstypen.</p>
<p>Der Typ <code>String</code>, der von Rusts Standardbibliothek zur Verfügung gestellt wird
und nicht in die Kernsprache kodiert ist, ist ein größenänderbarer,
veränderlicher, aneigenbarer, UTF-8-kodierter Zeichenkettentyp. Wenn
Rust-Entwickler von Zeichenketten in Rust sprechen, meinen sie normalerweise
den Typ <code>String</code> sowie den Zeichenkettenanteilstyp <code>&amp;str</code>, nicht nur einen
dieser Typen. Obwohl es in diesem Abschnitt weitgehend um <code>String</code> geht, werden
beide Typen in Rusts Standardbibliothek stark verwendet, und sowohl <code>String</code>
als auch Zeichenkettenanteilstypen sind UTF-8-kodiert.</p>
<p>Die Standardbibliothek von Rust enthält auch eine Reihe anderer
Zeichenkettentypen wie <code>OsString</code>, <code>OsStr</code>, <code>CString</code> und <code>CStr</code>.
Bibliothekskisten (library crates) können noch weitere Möglichkeiten zum
Speichern von Zeichenkettendaten bieten. Fällt dir auf, dass diese Namen alle
auf <code>String</code> oder <code>Str</code> enden? Sie beziehen sich auf aneigenbare und
ausgeliehene Varianten, genau wie die Typen <code>String</code> und <code>str</code>, die du zuvor
gesehen hast. Diese Zeichenkettentypen können z.B. Text in verschiedenen
Kodierungen speichern oder unterschiedliche Speicherdarstellungen haben. Diese
anderen Zeichenkettentypen werden in diesem Kapitel nicht besprochen; in ihrer
API-Dokumentation erfährst du mehr darüber, wie sie zu verwenden sind und wozu
jeder einzelne geeignet ist.</p>
<h3><a class="header" href="#erstellen-einer-neuen-zeichenkette" id="erstellen-einer-neuen-zeichenkette">Erstellen einer neuen Zeichenkette</a></h3>
<p>Viele Operationen, die für <code>Vec&lt;T&gt;</code> verfügbar sind, sind auch für <code>String</code>
vorhanden, beginnend mit der Funktion <code>new</code> zum Erstellen einer Zeichenkette,
wie in Codeblock 8-11 zu sehen ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::new();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-11: Erstellen einer neuen, leeren
Zeichenkette</span></p>
<p>Diese Zeile erzeugt eine neue, leere Zeichenkette namens <code>s</code>, in die wir dann
Daten aufnehmen können. Oft werden wir einige initiale Daten haben, mit denen
wir die Zeichenkette füllen wollen. Dazu verwenden wir die Methode <code>to_string</code>,
die für jeden Typ verfügbar ist, der das Merkmal <code>Display</code> implementiert, wie
es bei Zeichenkettenliteralen der Fall ist. Codeblock 8-12 zeigt zwei
Beispiele.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let data = &quot;initialer Inhalt&quot;;

let s = data.to_string();

// die Methode funktioniert auch direkt für ein Literal:
let s = &quot;initialer Inhalt&quot;.to_string();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-12: Verwenden der Methode <code>to_string</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Dieser Code erzeugt eine Zeichenkette mit dem Inhalt <code>initialer Inhalt</code>.</p>
<p>Wir können auch die Funktion <code>String::from</code> verwenden, um einen <code>String</code> aus
einem Zeichenkettenliteral zu erzeugen. Der Code in Codeblock 8-13 ist
äquivalent zum Code in Codeblock 8-12, der <code>to_string</code> verwendet.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = String::from(&quot;initialer Inhalt&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-13: Verwenden der Funktion <code>String::from</code> zum
Erzeugen eines <code>String</code> aus einem Zeichenkettenliteral</span></p>
<p>Da Zeichenketten für so viele Dinge verwendet werden, können wir viele
verschiedene generische Programmierschnittstellen (APIs) für Zeichenketten
verwenden, was uns viele Möglichkeiten bietet. Einige von ihnen können
überflüssig erscheinen, aber sie alle haben ihren Platz! In diesem Fall machen
<code>String::from</code> und <code>to_string</code> dasselbe, also ist die Wahl eine Frage des
Stils.</p>
<p>Denke daran, dass Zeichenketten UTF-8-kodiert sind, sodass sie alle
ordnungsgemäß kodierten Daten aufnehmen können, wie in Codeblock 8-14 gezeigt.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;السلام عليكم&quot;);
let hello = String::from(&quot;Dobrý den&quot;);
let hello = String::from(&quot;Hallo&quot;);
let hello = String::from(&quot;Hello&quot;);
let hello = String::from(&quot;שָׁלוֹם&quot;);
let hello = String::from(&quot;नमस्ते&quot;);
let hello = String::from(&quot;こんにちは&quot;);
let hello = String::from(&quot;안녕하세요&quot;);
let hello = String::from(&quot;你好&quot;);
let hello = String::from(&quot;Olá&quot;);
let hello = String::from(&quot;Здравствуйте&quot;);
let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-14: Speichern von Begrüßungstexten in
verschiedenen Sprachen in Zeichenketten</span></p>
<p>All dies sind gültige <code>String</code>-Werte.</p>
<h3><a class="header" href="#aktualisieren-einer-zeichenkette" id="aktualisieren-einer-zeichenkette">Aktualisieren einer Zeichenkette</a></h3>
<p>Ein <code>String</code> kann an Größe zunehmen und sein Inhalt kann sich ändern, genau wie
der Inhalt eines <code>Vec&lt;T&gt;</code>, wenn du mehr Daten hineinschiebst. Darüber hinaus
kannst du bequem den Operator <code>+</code> oder das Makro <code>format!</code> verwenden, um
<code>String</code>-Werte aneinanderzuhängen.</p>
<h4><a class="header" href="#anhängen-an-eine-zeichenkette-mit-push_str-und-push" id="anhängen-an-eine-zeichenkette-mit-push_str-und-push">Anhängen an eine Zeichenkette mit <code>push_str</code> und <code>push</code></a></h4>
<p>Wir können einen <code>String</code> wachsen lassen, indem wir die Methode <code>push_str</code>
verwenden, um einen Zeichenkettenanteilstyp anzuhängen, wie in Codeblock 8-15
zu sehen ist.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;foo&quot;);
s.push_str(&quot;bar&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-15: Anhängen eines Zeichenkettenanteilstyps
an einen <code>String</code> mit der Methode <code>push_str</code></span></p>
<p>Nach diesen beiden Zeilen enthält <code>s</code> den Wert <code>foobar</code>. Die Methode <code>push_str</code>
nimmt einen Zeichenkettenanteilstyp, weil wir nicht unbedingt die
Eigentümerschaft des Parameters übernehmen wollen. Zum Beispiel zeigt der Code
in Codeblock 8-16, dass es bedauerlich wäre, wenn wir nicht in der Lage wären,
<code>s2</code> zu verwenden, nachdem wir seinen Inhalt an <code>s1</code> angehängt haben.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s1 = String::from(&quot;foo&quot;);
let s2 = &quot;bar&quot;;
s1.push_str(s2);
println!(&quot;s2 ist {}&quot;, s2);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-16: Verwenden eines Zeichenkettenanteilstyps
nach dem Anhängen seines Inhalts an eine Zeichenkette</span></p>
<p>Wenn die Methode <code>push_str</code> die Eigentümerschaft von <code>s2</code> übernehmen würde,
könnten wir ihren Wert nicht in der letzten Zeile ausgeben. Dieser Code
funktioniert jedoch wie erwartet!</p>
<p>Die Methode <code>push</code> nimmt ein einzelnes Zeichen als Parameter und fügt es dem
<code>String</code> hinzu. Codeblock 8-17 zeigt Code, der den Buchstaben <code>l</code> mit der
Methode <code>push</code> zu einem <code>String</code> hinzufügt.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let mut s = String::from(&quot;lo&quot;);
s.push('l');
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-17: Hinzufügen eines Zeichens zu einem
<code>String</code>-Wert mit <code>push</code></span></p>
<p>Als Ergebnis dieses Codes wird <code>s</code> den Wert <code>lol</code> enthalten.</p>
<h4><a class="header" href="#aneinanderhängen-mit-dem-operator--und-dem-makro-format" id="aneinanderhängen-mit-dem-operator--und-dem-makro-format">Aneinanderhängen mit dem Operator <code>+</code> und dem Makro <code>format!</code></a></h4>
<p>Häufig möchtest du zwei vorhandene Zeichenketten kombinieren. Eine Möglichkeit
ist, den Operator <code>+</code> zu verwenden, wie in Codeblock 8-18 gezeigt.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo &quot;);
let s2 = String::from(&quot;Welt!&quot;);
let s3 = s1 + &amp;s2; // Beachte, s1 wurde hierher verschoben und
                   // kann nicht mehr verwendet werden
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-18: Verwenden des Operators <code>+</code>, um zwei
Zeichenketten zu einer neuen zu kombinieren</span></p>
<p>Die Zeichenkette <code>s3</code> wird als Ergebnis dieses Codes <code>Hallo Welt!</code> enthalten.
Der Grund, warum <code>s1</code> nach der Addition nicht mehr gültig ist und warum wir
eine Referenz auf <code>s2</code> verwendet haben, hat mit der Signatur der Methode zu
tun, die aufgerufen wird, wenn wir den Operator <code>+</code> verwenden. Der Operator <code>+</code>
benutzt die Methode <code>add</code>, deren Signatur ungefähr so aussieht:</p>
<pre><code class="language-rust ignore">fn add(self, s: &amp;str) -&gt; String {
</code></pre>
<p>Dies ist nicht die exakte Signatur aus der Standardbibliothek: In der
Standardbibliothek wird <code>add</code> mittels generischer Datentypen definiert. Hier
sehen wir uns die Signatur von <code>add</code> mit konkreten Typen an, die die
generischen Typen ersetzen; das passiert, wenn wir diese Methode mit
<code>String</code>-Werten aufrufen. Wir werden generische Datentypen in Kapitel 10
besprechen. Diese Signatur gibt uns den entscheidenden Hinweis, um die
kniffligen Stellen des Operators <code>+</code> zu verstehen.</p>
<p>Erstens hat <code>s2</code> ein <code>&amp;</code>, was bedeutet, dass wir aufgrund des Parameters <code>s</code> in
der Funktion <code>add</code> eine <em>Referenz</em> der zweiten Zeichenkette an die erste
Zeichenkette anhängen: Wir können nur einen <code>&amp;str</code> zu einem <code>String</code>
hinzufügen; wir können nicht zwei <code>String</code>-Werte miteinander addieren. Aber
warte – der Typ von <code>&amp;s2</code> ist <code>&amp;String</code>, nicht <code>&amp;str</code>, wie im zweiten
Parameter von <code>add</code> spezifiziert. Warum kompiliert also Codeblock 8-18?</p>
<p>Der Grund, warum wir <code>&amp;s2</code> im Aufruf von <code>add</code> verwenden können, ist, dass der
Kompilierer das Argument <code>&amp;String</code> in einen <code>&amp;str</code> umwandeln (coerce) kann.
Wenn wir die Methode <code>add</code> aufrufen, benutzt Rust eine <em>automatische
Umwandlung</em> (deref coercion), die hier <code>&amp;s2</code> in <code>&amp;s2[...]</code> umwandelt. Auf die
automatische Umwandlung werden wir in Kapitel 15 tiefer eingehen. Da <code>add</code>
nicht die Eigentümerschaft des Parameters <code>s</code> übernimmt, ist <code>s2</code> auch nach
dieser Operation immer noch ein gültiger <code>String</code>.</p>
<p>Zweitens können wir in der Signatur sehen, dass <code>add</code> die Eigentümerschaft von
<code>self</code> übernimmt, weil <code>self</code> <em>kein</em> <code>&amp;</code> hat. Das bedeutet, dass <code>s1</code> in
Codeblock 8-18 in den Aufruf von <code>add</code> verschoben wird und danach nicht mehr
gültig ist. Obwohl also <code>let s3 = s1 + &amp;s2;</code> so aussieht, als ob beide
Zeichenketten kopiert und eine neue erzeugt wird, übernimmt diese Anweisung
tatsächlich die Eigentümerschaft von <code>s1</code>, hängt eine Kopie des Inhalts von
<code>s2</code> an und gibt dann die Eigentümerschaft des Ergebnisses zurück. In anderen
Worten sieht es so aus, als würde es viele Kopien erstellen, das ist aber nicht
so; die Implementierung ist effizienter als Kopieren.</p>
<p>Wenn wir mehrere Zeichenketten aneinanderhängen wollen, wird das Verhalten des
Operators <code>+</code> unhandlich:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = s1 + &quot;-&quot; + &amp;s2 + &quot;-&quot; + &amp;s3;
<span class="boring">}
</span></code></pre></pre>
<p>An diesem Punkt wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Bei all den Zeichen <code>+</code>
und <code>&quot;</code> ist es schwer zu erkennen, was vor sich geht. Für kompliziertere
String-Kombinationen können wir das Makro <code>format!</code> verwenden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;tic&quot;);
let s2 = String::from(&quot;tac&quot;);
let s3 = String::from(&quot;toe&quot;);

let s = format!(&quot;{}-{}-{}&quot;, s1, s2, s3);
<span class="boring">}
</span></code></pre></pre>
<p>Auch bei diesem Code wird <code>s</code> den Wert <code>tic-tac-toe</code> haben. Das Makro <code>format!</code>
arbeitet auf die gleiche Weise wie <code>println!</code>, aber anstatt das Ergebnis auf
den Bildschirm auszugeben, gibt es einen <code>String</code> mit dem Inhalt zurück. Die
Codevariante, die <code>format!</code> verwendet, ist viel leichter zu lesen und übernimmt
keine Eigentümerschaft seiner Parameter.</p>
<h3><a class="header" href="#indexierung-von-zeichenketten" id="indexierung-von-zeichenketten">Indexierung von Zeichenketten</a></h3>
<p>In vielen anderen Programmiersprachen ist das Zugreifen auf einzelne Zeichen in
einer Zeichenkette mittels Index eine gültige und gängige Operation. Wenn du
jedoch in Rust versuchst, mittels Indexierungssyntax auf Teile einer
Zeichenkette zuzugreifen, wirst du einen Fehler erhalten. Betrachte den
ungültigen Code in Codeblock 8-19.</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s1 = String::from(&quot;Hallo&quot;);
let h = s1[0];


<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-19: Versuch, die Indexierungssyntax bei einer
Zeichenkette zu verwenden</span></p>
<p>Dieser Code führt zu folgendem Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
error[E0277]: the type `std::string::String` cannot be indexed by `{integer}`
 --&gt; src/main.rs:3:13
  |
3 |     let h = s1[0];
  |             ^^^^^ `std::string::String` cannot be indexed by `{integer}`
  |
  = help: the trait `std::ops::Index&lt;{integer}&gt;` is not implemented for `std::string::String`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `collections`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Fehlermeldung und der Hinweis erzählen die Geschichte: Zeichenketten in
Rust unterstützen keine Indexierung. Aber warum nicht? Um diese Frage zu
beantworten, müssen wir uns ansehen, wie Rust Zeichenketten im Speicher ablegt.</p>
<h4><a class="header" href="#interne-darstellung" id="interne-darstellung">Interne Darstellung</a></h4>
<p>Ein <code>String</code> ist eine Hülle um einen <code>Vec&lt;u8&gt;</code>. Sehen wir uns einige unserer
korrekt kodierten UTF-8-Beispielzeichenketten aus Codeblock 8-14 an. Zuerst
diese:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Hola&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>In diesem Fall wird <code>hello.len()</code> gleich 4 sein, was bedeutet, dass der Vektor,
der die Zeichenkette „Hola“ speichert, 4 Bytes lang ist. Jeder dieser
Buchstaben benötigt 1 Byte in UTF-8-Kodierung. Aber was ist mit der folgenden
Zeile? (Beachte, dass diese Zeichenkette mit dem kyrillischen Großbuchstaben
„Ze“ beginnt, nicht mit der arabischen Zahl 3.)</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = String::from(&quot;Здравствуйте&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>Auf die Frage, wie lang die Zeichenkette ist, könnte man sagen: 12. Die Antwort
von Rust lautet jedoch 24: Das ist die Anzahl der Bytes, die benötigt wird, um
„Здравствуйте“ in UTF-8 zu kodieren, da jeder Unicode-Skalarwert in dieser
Zeichenkette 2 Bytes Speicherplatz benötigt. Daher wird ein Index auf die Bytes
der Zeichenkette nicht immer mit einem gültigen Unicode-Skalarwert korrelieren.
Um das zu erläutern, betrachte diesen ungültigen Rust-Code:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;
let answer = &amp;hello[0];


<span class="boring">}
</span></code></pre></pre>
<p>Was sollte der Wert von<code>answer</code> sein? Sollte es <code>З</code> sein, der erste Buchstabe?
In der UTF-8-Kodierung von <code>З</code> ist das erste Byte <code>208</code> und das zweite <code>151</code>,
sodass <code>answer</code> eigentlich <code>208</code> sein müsste, aber <code>208</code> ist kein eigenständig
gültiges Zeichen. Die Rückgabe von <code>208</code> ist wahrscheinlich nicht das, was ein
Nutzer wünschen würde, wenn er nach dem ersten Buchstaben dieser Zeichenkette
fragte; das sind jedoch die einzigen Daten, die Rust beim Byte-Index 0 hat.
Nutzer wollen im Allgemeinen nicht, dass der Byte-Wert zurückgegeben wird,
selbst wenn die Zeichenkette nur lateinische Buchstaben enthält: Wenn
<code>&amp;&quot;hallo&quot;[0]</code> gültiger Code wäre, der den Byte-Wert zurückgibt, würde er <code>104</code>
zurückgeben, nicht <code>h</code>. Um zu vermeiden, dass ein unerwarteter Wert
zurückgegeben und Fehler verursacht werden, die nicht sofort entdeckt werden,
kompiliert Rust diesen Code überhaupt nicht und verhindert Missverständnisse
schon früh im Entwicklungsprozess.</p>
<h4><a class="header" href="#bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje" id="bytes-skalare-werte-und-graphemgruppen-grapheme-clusters-oje">Bytes, skalare Werte und Graphemgruppen (grapheme clusters)! Oje!</a></h4>
<p>Ein weiterer Punkt bei UTF-8 ist, dass es eigentlich drei relevante
Möglichkeiten gibt, Zeichenketten aus Rusts Perspektive zu betrachten: Als
Bytes, als skalare Werte und als Graphemgruppen (das, was wir am ehesten als
<em>Buchstaben</em> bezeichnen würden).</p>
<p>Wenn wir uns das in der Devanagari-Schrift geschriebene Hindi-Wort „नमस्ते“
ansehen, wird es als ein Vektor von <code>u8</code>-Werten gespeichert, der wie folgt
aussieht:</p>
<pre><code class="language-text">[224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164,
224, 165, 135]
</code></pre>
<p>Das sind 18 Bytes, so wie ein Computer diese Daten letztendlich speichert. Wenn
wir sie als Unicode-Skalarwerte betrachten, also als das, was der Typ <code>char</code> in
Rust ist, sehen diese Bytes wie folgt aus:</p>
<pre><code class="language-text">['न', 'म', 'स', '्', 'त', 'े']
</code></pre>
<p>Es gibt hier sechs <code>char</code>-Werte, aber der vierte und der sechste sind keine
Buchstaben: Sie sind diakritische Zeichen, die für sich allein genommen keinen
Sinn ergeben. Wenn wir sie schließlich als Graphemgruppen betrachten, erhalten
wir das, was eine Person die vier Buchstaben nennen würde, aus denen das
Hindi-Wort besteht:</p>
<pre><code class="language-text">[&quot;न&quot;, &quot;म&quot;, &quot;स्&quot;, &quot;ते&quot;]
</code></pre>
<p>Rust bietet verschiedene Möglichkeiten zur Interpretation von rohen
Zeichenkettendaten, die von Computern gespeichert werden, sodass jedes Programm
die Interpretation wählen kann, die es benötigt, unabhängig davon, in welcher
menschlichen Sprache die Daten vorliegen. Ein letzter Grund, warum Rust uns
nicht erlaubt, eine Zeichenkette zu indexieren, um ein Zeichen zu erhalten,
ist, dass von Indexoperationen erwartet wird, dass sie immer in konstanter Zeit
(O(1)) erfolgen. Es ist jedoch nicht möglich, diese Zeitgarantie bei einem
<code>String</code> einzuhalten, da Rust den Inhalt von Anfang an bis zum Index durchgehen
müsste, um festzustellen, wie viele gültige Zeichen es gibt.</p>
<h3><a class="header" href="#anteilige-zeichenketten" id="anteilige-zeichenketten">Anteilige Zeichenketten</a></h3>
<p>Die Indexierung einer Zeichenkette ist oft eine schlechte Idee, weil nicht klar
ist, was der Rückgabetyp der Zeichenketten-Indexoperation sein soll: Ein
Byte-Wert, ein Zeichen, eine Graphemgruppe oder ein Zeichenkettenanteilstyp.
Daher bittet dich Rust, konkretere Angaben zu machen, wenn du wirklich Indexes
zum Erstellen von Zeichenkettenanteilstypen verwenden musst. Um bei der
Indexierung spezifischer zu sein und anzugeben, dass du einen
Zeichenkettenanteilstyp wünschst, kannst du statt der Indexierung mit <code>[]</code> mit
einer einzigen Nummer <code>[]</code> mit einem Bereich verwenden, um einen
Zeichenkettenanteilstyp zu erstellen, der bestimmte Bytes enthält:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let hello = &quot;Здравствуйте&quot;;

let s = &amp;hello[0..4];
<span class="boring">}
</span></code></pre></pre>
<p>Hier wird <code>s</code> ein <code>&amp;str</code> sein, das die ersten 4 Bytes der Zeichenkette enthält.
Vorhin haben wir bereits erwähnt, dass jedes dieser Zeichen 2 Bytes lang ist,
was bedeutet, dass <code>s</code> gleich <code>Зд</code> ist. Was würde passieren, wenn wir
<code>&amp;hello[0..1]</code> benutzen würden? Die Antwort: Rust würde das Programm zur
Laufzeit abbrechen, genauso als wenn mit einem ungültigen Index auf einen
Vektor zugegriffen würde:</p>
<pre><code class="language-console">$ cargo run
   Compiling collections v0.1.0 (file:///projects/collections)
    Finished dev [unoptimized + debuginfo] target(s) in 0.43s
     Running `target/debug/collections`
thread 'main' panicked at 'byte index 1 is not a char boundary; it is inside 'З' (bytes 0..2) of `Здравствуйте`', src/libcore/str/mod.rs:2069:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Bei der Verwendung von Bereichen zum Erstellen von Zeichenkettenanteilstypen
ist Vorsicht geboten, da dies zum Absturz deines Programms führen kann.</p>
<h3><a class="header" href="#methoden-zum-iterieren-über-zeichenketten" id="methoden-zum-iterieren-über-zeichenketten">Methoden zum Iterieren über Zeichenketten</a></h3>
<p>Glücklicherweise kannst du auf andere Weise auf Elemente in einer Zeichenkette
zugreifen.</p>
<p>Wenn du Operationen mit einzelnen Unicode-Skalarwerten durchführen musst,
verwende am besten die Methode <code>chars</code>. Der Aufruf von <code>chars</code> auf „नमस्ते“
trennt sechs Werte vom Typ <code>char</code> heraus und gibt sie zurück, und du kannst
über das Ergebnis iterieren, um auf jedes Element zuzugreifen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for c in &quot;नमस्ते&quot;.chars() {
    println!(&quot;{}&quot;, c);
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code wird folgendes ausgeben:</p>
<pre><code class="language-text">न
म
स
्
त
े
</code></pre>
<p>Die Methode <code>bytes</code> gibt jedes rohe Byte zurück, das für deinen
Verwendungszweck benötigt wird:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>for b in &quot;नमस्ते&quot;.bytes() {
    println!(&quot;{}&quot;, b);
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code gibt die 18 Bytes aus, aus denen diese Zeichenkette besteht:</p>
<pre><code class="language-text">224
164
// --abschneiden--
165
135
</code></pre>
<p>Aber denke daran, dass gültige Unicode-Skalarwerte aus mehr als 1 Byte bestehen
können.</p>
<p>Graphemgruppen aus Zeichenketten auszulesen ist komplex, daher wird diese
Funktionalität nicht von der Standardbibliothek bereitgestellt. Kisten (crates)
sind unter <a href="https://crates.io/">crates.io</a> verfügbar, falls du diese
Funktionalität benötigst.</p>
<h3><a class="header" href="#zeichenketten-sind-nicht-so-einfach" id="zeichenketten-sind-nicht-so-einfach">Zeichenketten sind nicht so einfach</a></h3>
<p>Zusammenfassend kann man sagen, dass Zeichenketten kompliziert sind.
Verschiedene Programmiersprachen treffen unterschiedliche Entscheidungen
darüber, wie diese Komplexität dem Programmierer angezeigt wird. Rust hat sich
dafür entschieden, den korrekten Umgang mit Zeichenkettendaten zum
Standardverhalten für alle Rust-Programme zu machen, was bedeutet, dass
Programmierer sich im Vorfeld mehr Gedanken über den Umgang mit UTF-8-Daten
machen müssen. Dieser Zielkonflikt macht die Komplexität von Zeichenketten
größer als in anderen Programmiersprachen, aber er verhindert, dass du später
in deinem Entwicklungslebenszyklus mit Fehlern umgehen musst, wenn
Nicht-ASCII-Zeichen vorkommen.</p>
<p>Lass uns zu etwas weniger Kompliziertem übergehen: Hashtabellen!</p>
<h2><a class="header" href="#schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen" id="schlüssel-mit-zugehörigen-werten-in-hashtabellen-ablegen">Schlüssel mit zugehörigen Werten in Hashtabellen ablegen</a></h2>
<p>Die letzte unserer allgemeinen Kollektionen ist die <em>Hashtabelle</em> (hash map).
Der Typ <code>HashMap&lt;K, V&gt;</code> speichert eine Zuordnung von Schlüsseln vom Typ <code>K</code> zu
Werten vom Typ <code>V</code>. Er tut dies über eine <em>Hashfunktion</em> (hash function), die
bestimmt, wie er diese Schlüssel und Werte im Speicher ablegt. Viele
Programmiersprachen unterstützen diese Art Datenstruktur, aber sie verwenden
oft einen anderen Namen, z.B. Hash, Abbildung (map), Objekt, Hashtabelle (hash
table), Wörterbuch (dictionary) oder assoziatives Array (associative array), um
nur einige zu nennen. Hashtabellen sind nützlich, wenn du Daten nicht wie bei
Vektoren über einen Index nachschlagen willst, sondern über einen Schlüssel,
der ein beliebiger Typ sein kann. Beispielsweise könntest du in einem Spiel den
Spielstand jedes Teams in einer Hashtabelle vermerken, in der die Schlüssel den
Teamnamen und die Werte den Spielstand des jeweiligen Teams darstellen. Wenn du
den Namen eines Teams angibst, kannst du seine Punktzahl abrufen.</p>
<p>In diesem Abschnitt gehen wir die grundlegende Programmierschnittstelle (API)
von Hashtabellen durch, aber viele weitere Leckerbissen verbergen sich in den
Funktionen, die in der Standardbibliothek für <code>HashMap&lt;K, V&gt;</code> definiert sind.
Weitere Informationen findest du wie immer in der
Standardbibliotheksdokumentation.</p>
<h3><a class="header" href="#erstellen-einer-neuen-hashtabelle" id="erstellen-einer-neuen-hashtabelle">Erstellen einer neuen Hashtabelle</a></h3>
<p>Du kannst eine leere Hashtabelle mit <code>new</code> erstellen und Elemente mit <code>insert</code>
hinzufügen. In Codeblock 8-20 verfolgen wir die Ergebnisse zweier Mannschaften
mit den Namen Blau und Gelb. Das Team Blau startet mit 10 Punkten, das Team
Gelb mit 50 Punkten.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Gelb&quot;), 50);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-20: Erstellen einer neuen Hashtabelle und
Einfügen einiger Schlüssel und Werte</span></p>
<p>Beachte, dass wir zuerst mit <code>use</code> die <code>HashMap</code> aus dem Kollektionsteil der
Standardbibliothek einbinden müssen. Von unseren drei allgemeinen Kollektionen
wird diese am seltensten verwendet, sodass sie nicht zu den Funktionalitäten
gehört, die automatisch in den Gültigkeitsbereich aufgenommen werden.
Hashtabellen werden auch weniger von der Standardbibliothek unterstützt; es
gibt zum Beispiel kein eingebautes Makro, um sie zu erzeugen.</p>
<p>Genau wie Vektoren speichern Hashtabellen ihre Daten im dynamischen Speicher. 
Obige <code>HashMap</code> hat Schlüssel vom Typ <code>String</code> und Werte vom Typ <code>i32</code>.
Hashtabellen sind wie Vektoren homogen: Alle Schlüssel müssen den gleichen Typ
haben und alle Werte müssen den gleichen Typ haben.</p>
<p>Eine andere Möglichkeit, eine Hashtabelle zu erstellen, besteht im Verwenden
von Iteratoren und der Methode <code>collect</code> für einen Vektor von Tupeln, wobei
jedes Tupel aus einem Schlüssel und seinem Wert besteht. Auf Iteratoren und die
dazu gehörenden Methoden werden wir im Abschnitt <a href="ch13-02-iterators.html">„Eine Reihe von Elementen
verarbeiten mit Iteratoren“</a> in Kapitel 13 ausführlicher eingehen.
Die Methode <code>collect</code> sammelt Daten für zahlreiche Kollektionstypen,
einschließlich <code>HashMap</code>. Wenn wir z.B. die Teamnamen und Anfangsspielstände in
zwei getrennten Vektoren hätten, könnten wir die Methode <code>zip</code> verwenden, um
einen Vektor von Tupeln zu erstellen, in dem „Blau“ mit 10 gepaart ist, und so
weiter. Dann könnten wir die Methode <code>collect</code> verwenden, um diesen Vektor von
Tupeln in eine Hashtabelle umzuwandeln, wie in Codeblock 8-21 gezeigt wird.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let teams = vec![String::from(&quot;Blau&quot;), String::from(&quot;Gelb&quot;)];
let initial_scores = vec![10, 50];

let mut scores: HashMap&lt;_, _&gt; =
    teams.into_iter().zip(initial_scores.into_iter()).collect();
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-21: Erstellen einer Hashtabelle aus einer
Liste von Teams und einer Liste von Spielständen</span></p>
<p>Die Typannotation <code>HashMap&lt;_, _&gt;</code> wird hier benötigt, weil <code>collect</code>
verschiedene Datenstrukturen als Rückgabetyp unterstützt und Rust nicht weiß,
welche du willst, es sei denn, du gibst sie an. Für die Typparameter der
Schlüssel- und Werttypen geben wir jedoch Unterstriche an, Rust kann anhand der
Datentypen in den Vektoren auf die Typen schließen, die die Hashtabelle
enthält. In Codeblock 8-21 wird der Schlüsseltyp <code>String</code> und der Werttyp <code>i32</code>
sein, genau wie die Typen in Codeblock 8-20.</p>
<h3><a class="header" href="#hashtabellen-und-eigentümerschaft" id="hashtabellen-und-eigentümerschaft">Hashtabellen und Eigentümerschaft</a></h3>
<p>Bei Typen wie <code>i32</code>, die das Merkmal <code>Copy</code> implementieren, werden die Werte in
die Hashtabelle kopiert. Bei aneigenbaren Werten wie <code>String</code> werden die Werte
verschoben und die Hashtabelle ist Eigentümer dieser Werte, wie in Codeblock
8-22 gezeigt wird.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let field_name = String::from(&quot;Lieblingsfarbe&quot;);
let field_value = String::from(&quot;Blau&quot;);

let mut map = HashMap::new();
map.insert(field_name, field_value);
// field_name und field_value sind zu diesem Zeitpunkt ungültig.
// Versuche, sie zu benutzen und beobachte, welchen Kompilierfehler du erhältst!
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-22: Zeigt, dass Schlüssel und Werte nach dem
Aufruf von <code>insert</code> Eigentum der Hashtabelle sind</span></p>
<p>Wir können die Variablen <code>field_name</code> und <code>field_value</code> nicht mehr verwenden,
nachdem sie mit dem Aufruf von <code>insert</code> in die Hashtabelle verschoben wurden.</p>
<p>Wenn wir Referenzen auf Werte in die Hashtabelle einfügen, werden die Werte
nicht in die Hashtabelle verschoben. Die Werte, auf die die Referenzen zeigen,
müssen mindestens so lange gültig sein, wie die Hashtabelle gültig ist. Wir
werden mehr über diese Fragen im Abschnitt <a href="ch10-03-lifetime-syntax.html#validating-references-with-lifetimes">„Referenzen validieren mit
Lebensdauern“</a> in Kapitel 10 sprechen.</p>
<h3><a class="header" href="#zugreifen-auf-werte-in-einer-hashtabelle" id="zugreifen-auf-werte-in-einer-hashtabelle">Zugreifen auf Werte in einer Hashtabelle</a></h3>
<p>Wir können einen Wert aus der Hashtabelle herausholen, indem wir die Methode
<code>get</code> mit ihrem Schlüssel aufrufen, wie in Codeblock 8-23 gezeigt.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Geld&quot;), 50);

let team_name = String::from(&quot;Blau&quot;);
let score = scores.get(&amp;team_name);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-23: Zugreifen auf den Spielstand von Team
Blau in der Hashtabelle</span></p>
<p>Hier wird <code>score</code> den Wert haben, der mit Team Blau assoziiert ist, und das
Ergebnis wird <code>Some(&amp;10)</code> sein. Das Ergebnis ist in <code>Some</code> eingepackt, weil
<code>get</code> eine <code>Option&lt;&amp;V&gt;</code> zurückgibt; wenn es keinen Wert für diesen Schlüssel in
der Hashtabelle gibt, gibt <code>get</code> den Wert <code>None</code> zurück. Das Programm muss die
<code>Option</code> auf eine Weise behandeln, die wir in Kapitel 6 besprochen haben.</p>
<p>Wir können über jedes Schlüssel-Wert-Paar in einer Hashtabelle auf ähnliche
Weise iterieren wie bei Vektoren, indem wir eine <code>for</code>-Schleife verwenden:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Gelb&quot;), 50);

for (key, value) in &amp;scores {
    println!(&quot;{}: {}&quot;, key, value);
}
<span class="boring">}
</span></code></pre></pre>
<p>Dieser Code gibt alle Paare in einer beliebigen Reihenfolge aus:</p>
<pre><code class="language-text">Gelb: 50
Blau: 10
</code></pre>
<h3><a class="header" href="#aktualisieren-einer-hashtabelle" id="aktualisieren-einer-hashtabelle">Aktualisieren einer Hashtabelle</a></h3>
<p>Obwohl die Anzahl der Schlüssel und Werte wachsen kann, kann jedem Schlüssel
jeweils nur ein Wert zugeordnet werden. Wenn du die Daten in einer Hashtabelle
ändern willst, musst du entscheiden, wie der Fall zu behandeln ist, wenn einem
Schlüssel bereits ein Wert zugewiesen wurde. Du kannst den alten Wert durch den
neuen ersetzen und dabei den alten Wert völlig außer Acht lassen. Du kannst den
alten Wert behalten und den neuen Wert ignorieren und nur dann den neuen Wert
hinzufügen, wenn der Schlüssel noch <em>keinen</em> zugewiesenen Wert hat. Oder du
kannst den alten und neuen Wert kombinieren. Schauen wir uns an, wie diese
Varianten jeweils funktionieren!</p>
<h4><a class="header" href="#Überschreiben-eines-wertes" id="Überschreiben-eines-wertes">Überschreiben eines Wertes</a></h4>
<p>Wenn wir einen Schlüssel und einen Wert in eine Hashtabelle einfügen und dann
denselben Schlüssel mit einem anderen Wert einfügen, wird der mit diesem
Schlüssel assoziierte Wert ersetzt. Auch wenn der Code in Codeblock 8-24
zweimal <code>insert</code> aufruft, wird die Hashtabelle nur ein Schlüssel-Wert-Paar
enthalten, weil wir beide Male einen Wert für den Schlüssel des Teams Blau
einfügen.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();

scores.insert(String::from(&quot;Blau&quot;), 10);
scores.insert(String::from(&quot;Blau&quot;), 25);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-24: Ersetzen eines gespeicherten Wertes für
einen bestimmten Schlüssel</span></p>
<p>Dieser Code wird <code>{&quot;Blau&quot;: 25}</code> ausgeben. Der ursprüngliche Wert <code>10</code> wurde
überschrieben.</p>
<h4><a class="header" href="#nur-einen-wert-einfügen-wenn-der-schlüssel-keinen-wert-hat" id="nur-einen-wert-einfügen-wenn-der-schlüssel-keinen-wert-hat">Nur einen Wert einfügen, wenn der Schlüssel keinen Wert hat</a></h4>
<p>Es kommt oft vor, dass man zunächst prüfen will, ob ein bestimmter Schlüssel
einen Wert hat, und wenn dies nicht der Fall ist, einen Wert für ihn einzufügt.
Hashtabellen haben dafür eine spezielle Programmierschnittstelle (API) namens
<code>entry</code>, die den Schlüssel, den du prüfen willst, als Parameter nimmt. Der
Rückgabewert der Methode <code>entry</code> ist eine Aufzählung (enum) namens <code>Entry</code>, die
einen Wert repräsentiert, der existieren könnte oder auch nicht. Nehmen wir an,
wir wollen prüfen, ob der Schlüssel für das Team Gelb einen Wert hat. Wenn das
nicht der Fall ist, wollen wir den Wert 50 einfügen, und dasselbe gilt für das
Team Blau. Bei Verwendung von <code>entry</code> sieht der Code wie Codeblock 8-25 aus.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let mut scores = HashMap::new();
scores.insert(String::from(&quot;Blau&quot;), 10);

scores.entry(String::from(&quot;Gelb&quot;)).or_insert(50);
scores.entry(String::from(&quot;Blau&quot;)).or_insert(50);

println!(&quot;{:?}&quot;, scores);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-25: Verwenden der Methode <code>entry</code> zum
Einfügen, nur wenn der Schlüssel nicht bereits einen Wert hat</span></p>
<p>Die Methode <code>or_insert</code> von <code>Entry</code> ist so definiert, dass sie eine
veränderliche Referenz auf den Wert des entsprechenden <code>Entry</code>-Schlüssels
zurückgibt, wenn dieser Schlüssel existiert, andernfalls fügt sie den Parameter
als neuen Wert für diesen Schlüssel ein und gibt eine veränderliche Referenz
auf den neuen Wert zurück. Diese Technik ist viel sauberer, als die Logik
selbst zu schreiben, und sie harmoniert besser mit dem Ausleihenprüfer.</p>
<p>Der Code in Codeblock 8-25 gibt <code>{&quot;Gelb&quot;: 50, &quot;Blau&quot;: 10}</code> aus. Beim ersten
Aufruf von <code>entry</code> wird der Schlüssel von Team Gelb mit dem Wert 50 eingefügt,
da das Team Gelb noch keinen Wert hat. Der zweite Aufruf von <code>entry</code> wird die
Hashtabelle nicht verändern, da das Team Blau bereits den Wert 10 hat.</p>
<h4><a class="header" href="#aktualisieren-eines-wertes-auf-basis-des-alten-wertes" id="aktualisieren-eines-wertes-auf-basis-des-alten-wertes">Aktualisieren eines Wertes auf Basis des alten Wertes</a></h4>
<p>Ein weiterer gängiger Anwendungsfall für Hashtabellen besteht darin, den Wert
eines Schlüssels nachzuschlagen und ihn dann auf Basis des alten Wertes zu
aktualisieren. Beispielsweise zeigt Codeblock 8-26 einen Code, der zählt, wie
oft jedes Wort in einem Text vorkommt. Wir verwenden eine Hashtabelle mit den
Wörtern als Schlüssel und inkrementieren den Wert, um nachzuvollziehen, wie oft
wir dieses Wort schon gesehen haben. Wenn es das erste Mal ist, dass wir ein
Wort sehen, fügen wir zuerst den Wert 0 ein.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::collections::HashMap;

let text = &quot;Hallo Welt wunderbare Welt&quot;;

let mut map = HashMap::new();

for word in text.split_whitespace() {
    let count = map.entry(word).or_insert(0);
    *count += 1;
}

println!(&quot;{:?}&quot;, map);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 8-26: Zählen des Vorkommens von Wörtern mit
Hilfe einer Hashtabelle, die Wörter speichert und zählt</span></p>
<p>Dieser Code wird <code>{&quot;Welt&quot;: 2, &quot;wunderbare&quot;: 1, &quot;Hallo&quot;: 1}</code> ausgeben. Die
Methode <code>or_insert</code> gibt tatsächlich eine veränderliche Referenz (<code>&amp;mut V</code>) auf
den Wert für diesen Schlüssel zurück. Hier speichern wir diese veränderliche
Referenz in der Variablen <code>count</code>. Um diesen Wert zuzuweisen, müssen wir also
zuerst <code>count</code> mittels Sternoperator (<code>*</code>) dereferenzieren. Die veränderliche
Referenz verlässt den Gültigkeitsbereich am Ende der <code>for</code>-Schleife, sodass all
diese Änderungen sicher sind und von den Ausleihregeln erlaubt werden.</p>
<h3><a class="header" href="#hash-funktionen" id="hash-funktionen">Hash-Funktionen</a></h3>
<p>Standardmäßig verwendet <code>HashMap</code> eine „kryptographisch starke“<sup class="footnote-reference"><a href="#siphash">1</a></sup>
Hash-Funktion, die gegen Denial-of-Service (DoS)-Attacken robust ist. Dies ist
nicht der schnellste verfügbare Hashing-Algorithmus, aber der Kompromiss
zugunsten einer höheren Sicherheit gegenüber einer geringeren Performanz ist es
Wert. Wenn du eine Performanzanalyse deines Codes machst und feststellst, dass
die Standard-Hash-Funktion für deine Zwecke zu langsam ist, kannst du zu einer
anderen Funktion wechseln, indem du eine andere Hash-Funktion angibst. Eine
Hash-Funktion ist ein Typ, der das Merkmal <code>BuildHasher</code> implementiert. Wir
werden in Kapitel 10 über Merkmale und ihre Implementierung sprechen. Du musst
nicht unbedingt deine eigene Hash-Funktion von Grund auf implementieren;
<a href="https://crates.io/">crates.io</a> verfügt über Bibliotheken, die von anderen
Rust-Nutzern bereitgestellt werden und viele gängige Hash-Funktionen
implementieren.</p>
<div class="footnote-definition" id="siphash"><sup class="footnote-definition-label">1</sup>
<p><a href="https://www.131002.net/siphash/siphash.pdf">https://www.131002.net/siphash/siphash.pdf</a></p>
</div>
<h2><a class="header" href="#zusammenfassung-4" id="zusammenfassung-4">Zusammenfassung</a></h2>
<p>Vektoren, Zeichenketten und Hashtabellen bieten eine große Menge an
Funktionalität, die in Programmen benötigt wird, wenn du Daten speichern,
darauf zugreifen und sie verändern willst. Hier sind einige Übungen, für deren
Lösung du jetzt gerüstet sein solltest:</p>
<ul>
<li>Verwende bei einer Liste von ganzen Zahlen einen Vektor und gib den
Mittelwert (Durchschnittswert), den Median (wenn sortiert, den Wert in der
Mitte) und den Modus (den Wert, der am häufigsten vorkommt; eine Hashtabelle
ist hier hilfreich) der Liste zurück.</li>
<li>Wandle Zeichenketten in Schweinelatein (pig latin) um. Der erste Konsonant
jedes Wortes wird an das Ende des Wortes verschoben und „ay“ angehängt,
sodass „zuerst“ zu „uerst-zay“ wird. Bei Wörtern, die mit einem Vokal
beginnen, wird stattdessen „hay“ an das Ende angefügt („ansehen“ wird zu
„ansehen-hay“). Beachte die Details zur UTF-8-Kodierung!</li>
<li>Erstelle mit Hilfe einer Hashtabelle und Vektoren eine Textschnittstelle, die
es einem Benutzer ermöglicht, Mitarbeiternamen zu einer Abteilung in einem
Unternehmen hinzuzufügen. Zum Beispiel „Sally zur Technik hinzufügen“ oder
„Amir zum Vertrieb hinzufügen“. Lass den Benutzer dann eine alphabetisch
sortierte Liste aller Personen in einer Abteilung oder aller Personen in der
Firma nach Abteilung ausgeben.</li>
</ul>
<p>Die API-Dokumentation der Standard-Bibliothek beschreibt Methoden für Vektoren,
Zeichenketten und Hashtabellen, die für diese Übungen hilfreich sind!</p>
<p>Wir steigen in komplexere Programme ein, in denen Operationen fehlschlagen
können, daher ist es ein perfekter Zeitpunkt, auf die Fehlerbehandlung
einzugehen. Das werden wir als nächstes tun!</p>
<h1><a class="header" href="#fehlerbehandlung" id="fehlerbehandlung">Fehlerbehandlung</a></h1>
<p>Rusts Engagement für Zuverlässigkeit erstreckt sich auch auf die
Fehlerbehandlung. Fehler sind Gegebenheiten in Software, deshalb enthält Rust
eine Reihe von Funktionalitäten zur Behandlung von Situationen, in denen etwas
schiefgeht. In vielen Fällen verlangt Rust von dir, dass du die Möglichkeit
eines Fehlers anerkennst und Vorkehrungen ergreifst, damit dein Code kompiliert
werden kann. Diese Anforderung macht dein Programm robuster, da sichergestellt
wird, dass du Fehler entdeckst und diese angemessen behandelst, bevor dein Code
in Produktion gebracht wird!</p>
<p>Rust gruppiert Fehler in zwei Hauptkategorien: <em>Behebbare</em> (recoverable) und
<em>nicht behebbare</em> (unrecoverable) Fehler. Bei einem behebbaren Fehler, z.B.
„Datei nicht gefunden“, ist es sinnvoll, das Problem dem Benutzer zu melden und
den Vorgang erneut zu versuchen. Nicht behebbare Fehler sind immer Symptome von
Programmierfehlern, z.B. der Versuch, auf eine Stelle jenseits des Endes eines
Arrays zuzugreifen.</p>
<p>Die meisten Sprachen unterscheiden nicht zwischen diesen beiden Fehlerarten und
behandeln beide auf die gleiche Weise, indem sie Mechanismen wie die
Ausnahmebehandlung verwenden. Rust hat keine Ausnahmebehandlung. Stattdessen
hat es den Typ <code>Result&lt;T, E&gt;</code> für behebbare Fehler und das Makro <code>panic!</code>, das
die Ausführung stoppt, wenn das Programm auf einen nicht behebbaren Fehler
stößt. Dieses Kapitel behandelt zuerst das Aufrufen von <code>panic!</code> und spricht
dann über die Rückgabe von <code>Result&lt;T, E&gt;</code>-Werten. Darüber hinaus werden wir
Überlegungen anstellen, wann wir besser versuchen sollten, uns von einem Fehler
zu erholen, und wann die Ausführung zu stoppen.</p>
<h2><a class="header" href="#nicht-behebbare-fehler-mit-panic" id="nicht-behebbare-fehler-mit-panic">Nicht behebbare Fehler mit <code>panic!</code></a></h2>
<p>Manchmal passieren schlimme Dinge in deinem Code und du kannst nichts dagegen
tun. Für diese Fälle hat Rust das Makro <code>panic!</code>. Wenn das Makro <code>panic!</code>
ausgeführt wird, wird dein Programm eine Fehlermeldung ausgeben, den
Stapelspeicher abwickeln und aufräumen und sich dann beenden. Dies tritt am
häufigsten dann auf, wenn ein Fehler irgendeiner Art entdeckt wurde und dem
Programmierer nicht klar ist, wie er mit dem Fehler umgehen soll.</p>
<blockquote>
<h3><a class="header" href="#auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion" id="auflösen-des-stapelspeichers-oder-abbrechen-als-fehlerreaktion">Auflösen des Stapelspeichers oder Abbrechen als Fehlerreaktion</a></h3>
<p>Wenn ein Programmabbruch auftritt, beginnt das Programm standardmäßig mit dem
<em>Abwickeln</em>, was bedeutet, dass Rust den Stapelspeicher wieder nach oben geht
und die Daten von jeder Funktion, auf die es trifft, bereinigt. Aber dieses
Zurückgehen und Aufräumen ist eine Menge Arbeit. Die Alternative ist der
sofortige <em>Abbruch</em> (abort), der das Programm ohne aufzuräumen beendet. Der
Speicher, den das Programm benutzt hat, muss dann vom Betriebssystem
aufgeräumt werden. Wenn du in deinem Projekt die resultierende Binärdatei so
klein wie möglich machen willst, kannst du für ein vorzeitiges Programmende
vom Abwickeln zum sofortigen Abbrechen umschalten, indem du <code>panic = 'abort'</code>
in den entsprechenden <code>[profile]</code>-Abschnitten in deiner <em>Cargo.toml</em>-Datei
hinzufügst. Wenn du beispielsweise im Freigabemodus (release mode) im
Fehlerfall sofort abbrechen möchtest, füge dies hinzu:</p>
<pre><code class="language-toml">[profile.release]
panic = 'abort'
</code></pre>
</blockquote>
<p>Versuchen wir <code>panic!</code> in einem einfachen Programm aufzurufen:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    panic!(&quot;abstürzen und verbrennen&quot;);
}
</code></pre></pre>
<p>Wenn du das Programm ausführst, wirst du in etwa das hier sehen:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.25s
     Running `target/debug/panic`
thread 'main' panicked at 'abstürzen und verbrennen', src/main.rs:2:5
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Der Aufruf von <code>panic!</code> verursacht die in den letzten beiden Zeilen enthaltene
Fehlermeldung. Die erste Zeile zeigt unsere Fehlermeldung und die Position in
unserem Quellcode, an der der Fehler aufgetreten ist: <em>src/main.rs:2:5</em> gibt
an, dass es sich um die zweite Zeile und dem fünften Zeichen in unserer Datei
<em>src/main.rs</em> handelt.</p>
<p>In diesem Fall ist die angegebene Zeile Teil unseres Codes und wenn wir uns
diese Zeile ansehen, sehen wir den Makroaufruf <code>panic!</code>. In anderen Fällen
könnte der Aufruf von <code>panic!</code> in Code erfolgen, den unser Code aufruft, und
der Dateiname und die Zeilennummer in der Fehlermeldung gehören zu Code von
jemand anderen, der das Makro <code>panic!</code> aufruft, nicht zu unserem Code, der
schließlich zum Aufruf von <code>panic!</code> geführt hat. Wir können die Aufrufhistorie
(backtrace) der Funktionen, von der der <code>panic!</code>-Aufruf kam, nutzen, um den
Codeteil zu ermitteln, der das Problem verursacht. Im Folgenden sehen wir uns
genauer an, was eine Aufrufhistorie ist.</p>
<h3><a class="header" href="#verwenden-einer-panic-aufrufhistorie" id="verwenden-einer-panic-aufrufhistorie">Verwenden einer <code>panic!</code>-Aufrufhistorie</a></h3>
<p>Sehen wir uns ein weiteres Beispiel an, bei dem der <code>panic!</code>-Aufruf von einer
Bibliothek kommt, weil wir einen Fehler in unserem Code haben, anstatt das
Makro direkt aufzurufen. Codeblock 9-1 enthält einen Code, der versucht, auf
ein Element per Index in einem Vektor zuzugreifen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic panics">fn main() {
    let v = vec![1, 2, 3];

    v[99];
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-1: Versuch, auf ein Element jenseits des
Endes eines Vektors zuzugreifen, was einen Aufruf von <code>panic!</code> auslöst</span></p>
<p>Hier versuchen wir, auf das 100. Element unseres Vektors zuzugreifen (das bei Index 99
liegt, weil die Indexierung bei Null beginnt), der aber nur 3 Elemente hat. In dieser
Situation wird Rust das Programm abbrechen. Das Verwenden von <code>[]</code> soll ein Element
zurückgeben, aber wenn du einen ungültigen Index übergibst, gibt es kein Element, das
Rust hier korrekterweise zurückgeben könnte.</p>
<p>In C ist der Versuch, über das Ende einer Datenstruktur hinaus zu lesen, ein
undefiniertes Verhalten. Möglicherweise erhältst du den Wert im Speicher an der
der Datenstruktur entsprechenden Stelle, selbst wenn der Speicher nicht zu
dieser Struktur gehört. Dies wird als <em>Hinauslesen über den Puffer</em> (buffer
overread) bezeichnet und kann zu Sicherheitslücken führen, wenn ein Angreifer
in der Lage ist, den Index so zu manipulieren, dass er unerlaubterweise Daten
lesen kann, die nach der Datenstruktur gespeichert sind.</p>
<p>Um dein Programm vor dieser Art Verwundbarkeit zu schützen, wird Rust beim
Versuch, ein Element an einem Index zu lesen, der nicht existiert, die
Ausführung stoppen und die Fortsetzung verweigern. Versuchen wir es und sehen,
was passiert:</p>
<pre><code class="language-console">$ cargo run
   Compiling panic v0.1.0 (file:///projects/panic)
    Finished dev [unoptimized + debuginfo] target(s) in 0.27s
     Running `target/debug/panic`
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Dieser Fehler weist auf eine Datei hin, die wir nicht geschrieben haben:
<em>libcore/slice/mod.rs</em>. Das ist die Implementierung von <code>slice</code> im
Rust-Quellcode. Der Code, der ausgeführt wird, wenn wir <code>[]</code> auf unserem Vektor
<code>v</code> anwenden, befindet sich in <em>libcore/slice/mod.rs</em>, und das ist der Ort, an
dem <code>panic!</code> tatsächlich aufgerufen wird.</p>
<p>Die nächste Hinweiszeile sagt uns, dass wir die Umgebungsvariable
<code>RUST_BACKTRACE</code> setzen können, um eine Aufrufhistorie zur Fehlerursache zu
erhalten. Eine <em>Aufrufhistorie</em> ist eine Liste aller Funktionen, die aufgerufen
wurden, um an diesen Punkt zu gelangen. Aufrufhistorien in Rust funktionieren
wie in anderen Sprachen: Der Schlüssel zum Lesen der Aufrufhistorie liegt
darin, diese von oben beginnend zu lesen, bis du von dir geschriebene Dateien
siehst. Das ist die Stelle, an der das Problem entstanden ist. Die Zeilen
darüber sind Code, den dein Code aufgerufen hat; die Zeilen darunter sind Code,
der deinen Code aufgerufen hat. Diese Zeilen können Kern-Rust-Code,
Standard-Bibliothekscode oder Kisten (crates), die du verwendest, sein. Lass
uns versuchen, eine Aufrufhistorie zu erhalten, indem wir die Umgebungsvariable
<code>RUST_BACKTRACE</code> auf einen beliebigen Wert außer 0 setzen. Codeblock 9-2 zeigt
eine Ausgabe, wie du sie in etwa sehen wirst.</p>
<pre><code class="language-console">$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at 'index out of bounds: the len is 3 but the index is 99', /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806:10
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /Users/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:84
   3: &lt;std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display&gt;::fmt
             at src/libstd/sys_common/backtrace.rs:61
   4: core::fmt::ArgumentV1::show_usize
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1426
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:65
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:50
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:193
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:210
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:471
  11: rust_begin_unwind
             at src/libstd/panicking.rs:375
  12: core::panicking::panic_fmt
             at src/libcore/panicking.rs:84
  13: core::panicking::panic_bounds_check
             at src/libcore/panicking.rs:62
  14: &lt;usize as core::slice::SliceIndex&lt;[T]&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2806
  15: core::slice::&lt;impl core::ops::index::Index&lt;I&gt; for [T]&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libcore/slice/mod.rs:2657
  16: &lt;alloc::vec::Vec&lt;T&gt; as core::ops::index::Index&lt;I&gt;&gt;::index
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/liballoc/vec.rs:1871
  17: panic::main
             at src/main.rs:4
  18: std::rt::lang_start::{{closure}}
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  19: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:52
  20: std::panicking::try::do_call
             at src/libstd/panicking.rs:292
  21: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:78
  22: std::panicking::try
             at src/libstd/panicking.rs:270
  23: std::panic::catch_unwind
             at src/libstd/panic.rs:394
  24: std::rt::lang_start_internal
             at src/libstd/rt.rs:51
  25: std::rt::lang_start
             at /rustc/5e1a799842ba6ed4a57e91f7ab9435947482f7d8/src/libstd/rt.rs:67
  26: panic::main
</code></pre>
<p><span class="caption">Codeblock 9-2: Aufrufhistorie, erzeugt durch einen Aufruf
von <code>panic!</code>, wenn die Umgebungsvariable <code>RUST_BACKTRACE</code> gesetzt ist</span></p>
<p>Das ist eine lange Ausgabe! Die genaue Ausgabe kann je nach Betriebssystem und
Rust-Version unterschiedlich sein. Um Aufrufhistorien mit diesen Informationen
zu erhalten, müssen Fehlersuchinfos (debug symbols) aktiviert sein.
Fehlersuchinfos sind standardmäßig aktiviert, wenn du <code>cargo build</code> oder
<code>cargo run</code> ohne Flag <code>--release</code> verwendest, wie wir es hier haben.</p>
<p>In der Ausgabe in Codeblock 9-2 zeigt Zeile 17 der Aufrufhistorie auf die Zeile
in unserem Projekt, die das Problem verursacht: Zeile 4 in <em>src/main.rs</em>. Wenn
wir nicht wollen, dass unser Programm abbricht, sollten wir bei der ersten
Zeile, die auf eine von uns geschriebenen Datei verweist, mit der Untersuchung
beginnen. In Codeblock 9-1, wo wir absichtlich Code geschrieben haben, der das
Programm abbricht, um zu demonstrieren, wie man Aufrufhistorien liest, lässt
sich der Abbruch beheben, indem kein Element mit Index 99 von einem Vektor mit
nur 3 Elementen gelesen wird. Wenn dein Code in Zukunft abbricht, musst du
herausfinden, bei welcher Aktion der Code mit welchen Werten abbricht und was
der Code stattdessen tun sollte.</p>
<p>In Abschnitt <a href="ch09-03-to-panic-or-not-to-panic.html#to-panic-or-not-to-panic">„Wann <code>panic!</code> verwenden und wann
nicht?“</a> später in diesem Kapitel kommen wir noch
einmal auf <code>panic!</code> zurück und wann wir <code>panic!</code> verwenden sollten und wann
nicht, um Fehlerfälle zu behandeln. Als Nächstes schauen wir uns an, wie man
sich mit <code>Result</code> von einem Fehler erholt.</p>
<h2><a class="header" href="#behebbare-fehler-mit-result" id="behebbare-fehler-mit-result">Behebbare Fehler mit <code>Result</code></a></h2>
<p>Die meisten Fehler sind nicht so schwerwiegend, dass das Programm ganz
abgebrochen werden müsste. Manchmal, wenn eine Funktion fehlschlägt, hat das
einen Grund, den man leicht erkennen und darauf reagieren kann. Wenn du
beispielsweise versuchst, eine Datei zu öffnen, und dieser Vorgang schlägt
fehl, weil die Datei nicht existiert, könntest du die Datei erstellen, anstatt
den Vorgang zu beenden.</p>
<p>Erinnere dich an <a href="ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type">„Potentielles Fehlverhalten mit dem Typ <code>Result</code>
behandeln“</a> in Kapitel 2, das die Aufzählung <code>Result</code> mit zwei
Varianten <code>Ok</code> und <code>Err</code> definiert, wie nachfolgend zu sehen ist:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code> und <code>E</code> sind generische Typparameter: Wir werden generische Datentypen in
Kapitel 10 ausführlicher besprechen. Was du jetzt wissen musst, ist, dass <code>T</code>
den Typ des Wertes darstellt, der im Erfolgsfall innerhalb der <code>Ok</code>-Variante
zurückgegeben wird, und <code>E</code> den Typ des Fehlers, der im Fehlerfall innerhalb
der <code>Err</code>-Variante zurückgegeben wird. Da <code>Result</code> diese generischen
Typparameter hat, können wir den <code>Result</code>-Typ und die Funktionen, die die
Standardbibliothek darauf definiert hat, in vielen verschiedenen Situationen
verwenden, in denen der Erfolgswert und der Fehlerwert, den wir zurückgeben
wollen, unterschiedlich sein können.</p>
<p>Rufen wir eine Funktion auf, die einen <code>Result</code>-Wert zurückgibt, weil die
Funktion fehlschlagen könnte. In Codeblock 9-3 versuchen wir, eine Datei zu
öffnen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;);
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-3: Eine Datei öffnen</span></p>
<p>Woher wissen wir, dass <code>File::open</code> ein <code>Result</code> zurückgibt? Wir könnten uns
die <a href="https://doc.rust-lang.org/std/index.html">Standard-Bibliotheks-API-Dokumentation</a> ansehen oder wir
könnten den Compiler fragen! Wenn wir <code>f</code> eine Typ-Annotation geben, von der
wir wissen, dass sie <em>nicht</em> der Rückgabetyp der Funktion ist, und dann
versuchen, den Code zu kompilieren, wird der Kompilierer uns sagen, dass die
Typen nicht übereinstimmen. Die Fehlermeldung sagt uns dann, welchen Typ <code>f</code>
tatsächlich hat. Versuchen wir es! Wir wissen, dass der Rückgabetyp von
<code>File::open</code> nicht vom Typ <code>u32</code> ist, also lass uns die Anweisung <code>let f</code> wie
folgt ändern:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile"><span class="boring">use std::fs::File;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let f: u32 = File::open(&quot;hello.txt&quot;);



<span class="boring">}
</span></code></pre></pre>
<p>Der Versuch, zu kompilieren, liefert uns nun folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0308]: mismatched types
 --&gt; src/main.rs:4:18
  |
4 |     let f: u32 = File::open(&quot;hallo.txt&quot;);
  |            ---   ^^^^^^^^^^^^^^^^^^^^^^^ expected `u32`, found enum `std::result::Result`
  |            |
  |            expected due to this
  |
  = note: expected type `u32`
             found enum `std::result::Result&lt;std::fs::File, std::io::Error&gt;`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dies sagt uns, dass die Funktion <code>File::open</code> den Rückgabetyp <code>Result&lt;T, E&gt;</code>
hat. Der generische Parameter <code>T</code> wurde hier mit dem Typ des Erfolgswertes
<code>std::fs::File</code>, der eine Dateiressource (file handle) ist, gefüllt. Der Typ
<code>E</code> für den Fehlerwert ist <code>std::io::Error</code>.</p>
<p>Dieser Rückgabetyp bedeutet, dass der Aufruf von <code>File::open</code> erfolgreich sein
könnte und eine Dateiressource zurückgibt, aus der wir lesen oder in die wir
schreiben können. Der Funktionsaufruf kann auch fehlschlagen: Zum Beispiel
könnte die Datei nicht existieren oder wir haben möglicherweise keine
Zugriffsberechtigung für die Datei. Die Funktion <code>File::open</code> muss eine
Möglichkeit haben, uns zu sagen, ob sie erfolgreich war oder fehlgeschlagen
ist, und uns gleichzeitig entweder die Dateiressource oder die
Fehlerinformationen liefern. Diese Informationen sind genau das, was die
Aufzählung <code>Result</code> übermittelt.</p>
<p>Falls <code>File::open</code> erfolgreich ist, wird der Wert der Variable <code>f</code> eine Instanz
von <code>Ok</code> sein, die eine Dateiressource enthält. Im Fehlerfall ist der Wert von
<code>f</code> eine Instanz von <code>Err</code>, die mehr Informationen über die Art des
aufgetretenen Fehlers enthält.</p>
<p>Wir müssen den Code in Codeblock 9-3 ergänzen, um abhängig vom Rückgabewert von
<code>File::open</code> unterschiedliche Aktionen durchzuführen. Codeblock 9-4 zeigt eine
Möglichkeit, <code>Result</code> mit Hilfe eines grundlegenden Werkzeugs, dem Ausdruck
<code>match</code>, den wir in Kapitel 6 besprochen haben, zu behandeln.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, error),
    };
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-4: Verwenden eines <code>match</code>-Ausdrucks zum
Behandeln der <code>Result</code>-Varianten, die zurückgegeben werden könnten</span></p>
<p>Beachte, dass die Aufzählung <code>Result</code> und ihre Varianten automatisch im
Gültigkeitsbereich verfügbar sind, genau wie bei der Aufzählung <code>Option</code>,
sodass wir in den <code>match</code>-Zweigen nicht mehr <code>Result::</code> vor den Varianten <code>Ok</code>
und <code>Err</code> angeben müssen.</p>
<p>Hier sagen wir Rust, dass wir, wenn das Ergebnis <code>Ok</code> ist, den inneren Wert
<code>file</code> aus der <code>Ok</code>-Variante zurückgeben, und dann weisen wir diese
Dateiressource der Variablen <code>f</code> zu. Nach dem <code>match</code> können wir die
Dateiressource zum Lesen und Schreiben verwenden.</p>
<p>Der andere Zweig von <code>match</code> behandelt den Fall, dass wir einen <code>Err</code>-Wert von
<code>File::open</code> erhalten. In diesem Beispiel haben wir uns dafür entschieden, das
Makro <code>panic!</code> aufzurufen. Wenn es keine Datei namens <em>hallo.txt</em> in unserem
aktuellen Verzeichnis gibt und wir diesen Code ausführen, sehen wir die
folgende Ausgabe des Makros <code>panic!</code>:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
    Finished dev [unoptimized + debuginfo] target(s) in 0.73s
     Running `target/debug/error-handling`
thread 'main' panicked at 'Problem opening the file: Os { code: 2, kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:8:23
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
</code></pre>
<p>Wie üblich sagt uns diese Ausgabe genau, was schiefgelaufen ist.</p>
<h3><a class="header" href="#abgleich-verschiedener-fehler" id="abgleich-verschiedener-fehler">Abgleich verschiedener Fehler</a></h3>
<p>Der Code in Codeblock 9-4 wird abbrechen, egal aus welchem Grund <code>File::open</code>
fehlschlug. Was wir stattdessen tun wollen, ist, bei verschiedenen
Fehlerursachen unterschiedliche Maßnahmen zu ergreifen: Wenn <code>File::open</code>
fehlgeschlagen ist, weil die Datei nicht existiert, wollen wir die Datei
erstellen und die Dateiressource der neuen Datei zurückgeben. Wenn <code>File::open</code>
aus irgendeinem anderen Grund fehlschlug, z.B. weil wir keine Berechtigung zum
Öffnen der Datei hatten, wollen wir immer noch, dass der Code abbricht, so wie
es in Codeblock 9-4 der Fall war. Schau dir Codeblock 9-5 an, der zusätzlich
einen inneren <code>match</code>-Ausdruck hat.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;);

    let f = match f {
        Ok(file) =&gt; file,
        Err(error) =&gt; match error.kind() {
            ErrorKind::NotFound =&gt; match File::create(&quot;hallo.txt&quot;) {
                Ok(fc) =&gt; fc,
                Err(e) =&gt; panic!(&quot;Problem beim Erstellen der Datei: {:?}&quot;, e),
            },
            other_error =&gt; {
                panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, other_error)
            }
        },
    };
}
</code></pre></pre>
<p><span class="caption">Codeblock 9-5: Unterschiedliche Arten von Fehlern auf
unterschiedliche Weise behandeln</span></p>
<p>Der Typ des Wertes, den <code>File::open</code> innerhalb der Variante <code>Err</code> zurückgibt,
ist <code>io::Error</code>, eine Struktur (struct), die von der Standardbibliothek zur
Verfügung gestellt wird. Diese Struktur hat eine Methode <code>kind</code>, die wir
aufrufen können, um einen <code>io::ErrorKind</code>-Wert zu erhalten. Die Aufzählung
<code>io::ErrorKind</code> wird von der Standardbibliothek zur Verfügung gestellt und
enthält Varianten, die die verschiedenen Fehlerarten repräsentieren, die bei
einer <code>io</code>-Operation auftreten können. Die Variante, die wir verwenden wollen,
ist <code>ErrorKind::NotFound</code>, was bedeutet, dass die Datei, die wir zu öffnen
versuchen, noch nicht existiert. Wir werten also <code>f</code> aus, als auch
<code>error.kind()</code>.</p>
<p>Die Bedingung, die wir beim inneren Abgleich überprüfen wollen, ist, ob der von
<code>error.kind()</code> zurückgegebene Wert die Variante <code>NotFound</code> der Aufzählung
<code>ErrorKind</code> ist. Wenn das der Fall ist, versuchen wir, die Datei mit
<code>File::create</code> zu erstellen. Da <code>File::create</code> aber auch scheitern könnte,
brauchen wir einen zweiten Zweig im inneren <code>match</code>-Ausdruck. Wenn die Datei
nicht erstellt werden kann, wird eine andere Fehlermeldung ausgegeben. Der
zweite Zweig des äußeren <code>match</code> bleibt gleich, sodass das Programm bei jedem
Fehler außer dem Fehler der fehlenden Datei abbricht.</p>
<p>Das sind viele <code>match</code>! Der Ausdruck <code>match</code> ist sehr nützlich, aber auch sehr
primitiv. In Kapitel 13 erfährst du etwas über Funktionsabschlüsse (closures);
der Typ <code>Result&lt;T, E&gt;</code> hat viele Methoden, die einen Funktionsabschluss
akzeptieren und mittels <code>match</code>-Ausdrücke implementiert sind. Das Verwenden
dieser Methoden wird deinen Code prägnanter machen. Ein erfahrenerer
Rust-Entwickler könnte diesen Code anstelle von Codeblock 9-5 schreiben:</p>
<pre><pre class="playpen"><code class="language-rust">use std::fs::File;
use std::io::ErrorKind;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;).unwrap_or_else(|error| {
        if error.kind() == ErrorKind::NotFound {
            File::create(&quot;hallo.txt&quot;).unwrap_or_else(|error| {
                panic!(&quot;Problem beim Erstellen der Datei: {:?}&quot;, error);
            })
        } else {
            panic!(&quot;Problem beim Öffnen der Datei: {:?}&quot;, error);
        }
    });
}
</code></pre></pre>
<p>Obwohl dieser Code dasselbe Verhalten wie Codeblock 9-5 aufweist, enthält er
keine <code>match</code>-Ausdrücke und ist einfacher zu lesen. Kehre zu diesem Beispiel
zurück, nachdem du Kapitel 13 gelesen hast, und schlage die Methode
<code>unwrap_or_else</code> in der Standardbibliotheksdokumentation nach. Viele weitere
dieser Methoden können große, verschachtelte <code>match</code>-Ausdrücke vermeiden, wenn
du mit Fehlern zu tun hast.</p>
<h3><a class="header" href="#abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect" id="abkürzungen-zum-abbrechen-im-fehlerfall-unwrap-und-expect">Abkürzungen zum Abbrechen im Fehlerfall: <code>unwrap</code> und <code>expect</code></a></h3>
<p>Das Verwenden von <code>match</code> funktioniert gut genug, aber es kann etwas wortreich
sein und vermittelt das Vorhaben nicht immer gut. Der Typ <code>Result&lt;T, E&gt;</code> bietet
viele Hilfsmethoden, um verschiedene Aufgaben zu erledigen. Eine dieser
Methoden, genannt <code>unwrap</code>, ist eine Abkürzungsmethode, die genauso
implementiert ist wie der Ausdruck <code>match</code>, den wir in Codeblock 9-4
geschrieben haben. Wenn der <code>Result</code>-Wert die Variante <code>Ok</code> ist, gibt <code>unwrap</code>
den Wert innerhalb <code>Ok</code> zurück. Wenn <code>Result</code> die Variante <code>Err</code> ist, ruft
<code>unwrap</code> das Makro <code>panic!</code> für uns auf. Hier ist ein Beispiel für <code>unwrap</code> in
Aktion:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;).unwrap();
}
</code></pre></pre>
<p>Wenn wir diesen Code ohne eine Datei <em>hallo.txt</em> ausführen, werden wir die
Fehlermeldung des <code>panic!</code>-Aufrufs sehen, den die Methode <code>unwrap</code> macht:</p>
<pre><code class="language-text">thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: &quot;No such file or directory&quot; } }',
src/libcore/result.rs:906:4
</code></pre>
<p>Des Weiteren gibt es die Methode <code>expect</code>, die ähnlich wie <code>unwrap</code>
funktioniert und uns zusätzlich die <code>panic!</code>-Fehlermeldung angeben lässt. Das
Verwenden von <code>expect</code> anstelle von <code>unwrap</code> und das Angeben guter
Fehlermeldungen kann deine Absicht vermitteln und das Aufspüren der
Fehlerursache erleichtern. Die Syntax von <code>expect</code> sieht wie folgt aus:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;).expect(&quot;Problem beim Öffnen von hallo.txt&quot;);
}
</code></pre></pre>
<p>Wir benutzen <code>expect</code> auf die gleiche Weise wie <code>unwrap</code>: Um die Dateiressource
zurückzugeben oder das Makro <code>panic!</code> aufzurufen. Die Fehlermeldung, die
<code>expect</code> beim Aufruf von <code>panic!</code> mitgibt, wird als Parameter an <code>expect</code>
übergeben, anstelle der standardmäßigen <code>panic!</code>-Nachricht, die <code>unwrap</code>
verwendet. So sieht sie aus:</p>
<pre><code class="language-text">thread 'main' panicked at 'Problem beim Öffnen von hallo.txt: Os { code: 2,
kind: NotFound, message: &quot;No such file or directory&quot; }', src/main.rs:4:13
</code></pre>
<p>Da diese Fehlermeldung mit dem von uns angegebenen Text <code>Problem beim Öffnen von hallo.txt</code> beginnt, ist es einfacher herauszufinden, woher diese
Fehlermeldung im Code kommt. Wenn wir <code>unwrap</code> an mehreren Stellen verwenden,
kann es länger dauern, genau herauszufinden, welches <code>unwrap</code> zum
Programmabbruch geführt hat, weil alle <code>unwrap</code>-Aufrufe die gleiche Nachricht
ausgeben.</p>
<h3><a class="header" href="#fehler-weitergeben" id="fehler-weitergeben">Fehler weitergeben</a></h3>
<p>Wenn du eine Funktion schreibst, deren Implementierung etwas aufruft, das
fehlschlagen könnte, kannst du, anstatt den Fehler innerhalb dieser Funktion
zu behandeln, den Fehler an den aufrufenden Code zurückgeben, damit dieser
entscheiden kann, was zu tun ist. Dies wird als <em>Weitergeben</em> (propagating) des
Fehlers bezeichnet und gibt dem aufrufenden Code mehr Kontrolle, wo mehr
Informationen und Logik zur Fehlerbehandlung vorhanden sein könnte, als im
Kontext deines Codes zur Verfügung steht.</p>
<p>Beispielsweise zeigt Codeblock 9-6 eine Funktion, die einen Benutzernamen aus
einer Datei liest. Wenn die Datei nicht existiert oder nicht gelesen werden
kann, gibt diese Funktion den Fehler an den Code zurück, der diese Funktion
aufgerufen hat.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let f = File::open(&quot;hallo.txt&quot;);

    let mut f = match f {
        Ok(file) =&gt; file,
        Err(e) =&gt; return Err(e),
    };

    let mut s = String::new();

    match f.read_to_string(&amp;mut s) {
        Ok(_) =&gt; Ok(s),
        Err(e) =&gt; Err(e),
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-6: Eine Funktion, die mit <code>match</code> Fehler an
den aufrufenden Code zurückgibt</span></p>
<p>Diese Funktion kann auf eine viel kürzere Art und Weise geschrieben werden,
aber wir wollen für den Anfang viel davon manuell zu machen, um die
Fehlerbehandlung zu erkunden; am Ende werden wir den kürzeren Weg zeigen. Sehen
wir uns zunächst den Rückgabetyp der Funktion an: <code>Result&lt;String, io::Error&gt;</code>.
Das bedeutet, dass die Funktion einen Wert vom Typ <code>Result&lt;T, E&gt;</code> zurückgibt,
wobei der generische Typ <code>T</code> mit dem konkreten Typ <code>String</code> und der generische
Typ <code>E</code> mit dem konkreten Typ <code>io::Fehler</code> gefüllt wurde. Wenn diese Funktion
erfolgreich ist, erhält der aufrufende Code einen <code>Ok</code>-Wert, der einen <code>String</code>
enthält – den Benutzernamen, den diese Funktion aus der Datei liest. Wenn
diese Funktion auf Probleme stößt, erhält der aufrufende Code einen <code>Err</code>-Wert,
der eine Instanz von <code>io::Error</code> enthält, mit weiteren Informationen darüber,
was die Probleme waren. Wir wählten <code>io::Error</code> als Rückgabetyp dieser
Funktion, weil dies zufällig der Typ des Fehlerwertes ist, der von beiden
Operationen zurückgegeben wird, die wir im Funktionsrumpf aufrufen und
fehlschlagen könnten: Die Funktion <code>File::open</code> und die Methode
<code>read_to_string</code>.</p>
<p>Der Funktionsrumpf beginnt mit dem Aufruf der Funktion <code>File::open</code>. Dann
behandeln wir den <code>Result</code>-Wert, der von <code>match</code> zurückgegeben wird, auf
ähnliche Weise wie bei <code>match</code> in Codeblock 9-4, allerdings anstatt <code>panic!</code> im
<code>Err</code>-Fall aufzurufen, beenden wir die Funktion vorzeitig und übergeben den
Fehlerwert von <code>File::open</code> als Fehlerwert dieser Funktion an den aufrufenden
Code. Wenn <code>File::open</code> erfolgreich ist, speichern wir die Dateiressource in
der Variable <code>f</code> und fahren fort.</p>
<p>Dann erstellen wir einen neuen <code>String</code> in der Variable <code>s</code> und rufen die
Methode <code>read_to_string</code> auf der Dateiressource in <code>f</code> auf, um den Inhalt der
Datei in <code>s</code> einzulesen. Die Methode <code>read_to_string</code> gibt ebenfalls ein
<code>Result</code> zurück, weil sie fehlschlagen könnte, obwohl <code>File::open</code> erfolgreich
war. Wir brauchen also ein weiteres <code>match</code>, um dieses <code>Result</code> zu verarbeiten:
Wenn <code>read_to_string</code> erfolgreich ist, dann war unsere Funktion erfolgreich und
wir geben den Benutzernamen aus der Datei zurück, die jetzt in <code>s</code> innerhalb
<code>Ok</code> enthalten ist. Wenn <code>read_to_string</code> fehlschlägt, geben wir den Fehlerwert
auf die gleiche Weise zurück, wie wir den Fehlerwert in <code>match</code> zurückgegeben
haben, das den Rückgabewert von <code>File::open</code> behandelt hat. Wir brauchen jedoch
nicht ausdrücklich <code>return</code> anzugeben, weil dies der letzte Ausdruck in der
Funktion ist.</p>
<p>Der Code, der diesen Code aufruft, wird dann damit zurechtkommen, entweder
einen <code>Ok</code>-Wert zu erhalten, der einen Benutzernamen enthält, oder einen
<code>Err</code>-Wert, der einen <code>io::Error</code> enthält. Wir wissen nicht, was der Aufrufcode
mit diesen Werten machen wird. Wenn der aufrufende Code einen <code>Err</code>-Wert
erhält, könnte er <code>panic!</code> aufrufen und das Programm zum Absturz bringen, einen
Standardbenutzernamen verwenden oder den Benutzernamen von irgendwo anders als
z.B. einer Datei nachschlagen. Wir haben nicht genug Informationen darüber, was
der aufrufende Code tatsächlich versucht, also propagieren wir alle Erfolgs-
und Fehlerinformationen nach oben, damit sie angemessen behandelt werden.
Dieses Muster der Fehlerweitergabe ist in Rust so verbreitet, dass Rust den
Fragezeichen-Operator <code>?</code> bereitstellt, um dies zu erleichtern.</p>
<h4><a class="header" href="#abkürzung-zum-weitergeben-von-fehlern-der-operator-" id="abkürzung-zum-weitergeben-von-fehlern-der-operator-">Abkürzung zum Weitergeben von Fehlern: Der Operator <code>?</code></a></h4>
<p>Codeblock 9-7 zeigt eine Implementierung von <code>read_username_from_file</code>, die
dasselbe Verhalten wie in Codeblock 9-6 hat, aber diese Implementierung
verwendet den <code>?</code>-Operator.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut f = File::open(&quot;hallo.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-7: Eine Funktion, die Fehler an den
aufrufenden Code zurückgibt, indem sie den <code>?</code>-Operator verwendet</span></p>
<p>Das <code>?</code> hinter dem <code>Result</code>-Wert bewirkt fast das gleiche wie die
<code>match</code>-Ausdrücke, die wir zum Behandeln der <code>Result</code>-Werte in Codeblock 9-6
definiert haben. Wenn der Wert von <code>Result</code> ein <code>Ok</code> ist, wird der Wert
innerhalb <code>Ok</code> zurückgegeben und das Programm fortgesetzt. Wenn der Wert ein
<code>Err</code> ist, wird er als Funktionsergebnis zurückgegeben, als ob wir das
Schlüsselwort <code>return</code> verwendet hätten.</p>
<p>Es gibt einen Unterschied zwischen dem, was der <code>match</code>-Ausdruck aus Codeblock
9-6 tut, und dem, was der <code>?</code>-Operator tut: Fehlerwerte, bei denen der
<code>?</code>-Operator aufgerufen wird, durchlaufen die Funktion <code>from</code>, die im Merkmal
<code>From</code> der Standardbibliothek definiert ist und die zur Konvertierung von
Fehlern eines Typs in einen anderen verwendet wird. Wenn der <code>?</code>-Operator die
Funktion <code>from</code> aufruft, wird der empfangene Fehlertyp in den Fehlertyp
umgewandelt, der als Rückgabetyp der aktuellen Funktion definiert ist. Das ist
hilfreich, wenn eine Funktion einen einzigen Fehlertyp zurückgibt, um alle
möglichen Fehlerarten einer Funktion darzustellen, auch wenn Teile aus vielen
verschiedenen Gründen versagen könnten. Solange jeder Fehlertyp die Funktion
<code>from</code> implementiert, um festzulegen, wie er sich selbst in den
zurückzugebenden Fehlertyp konvertieren soll, kümmert sich der <code>?</code>-Operator
automatisch um die Konvertierung.</p>
<p>Im Zusammenhang mit Codeblock 9-7 gibt das <code>?</code> am Ende des Aufrufs von
<code>File::open</code> den Wert innerhalb eines <code>Ok</code> an die Variable <code>f</code> zurück. Wenn ein
Fehler auftritt, beendet der Operator vorzeitig die gesamte Funktion und gibt
dem aufrufenden Code einen <code>Err</code>-Wert zurück. Dasselbe gilt für das <code>?</code> am Ende
des <code>read_to_string</code>-Aufrufs.</p>
<p>Der <code>?</code>-Operator eliminiert viel umständlichen Code und macht die
Implementierung dieser Funktion einfacher. Wir können diesen Code sogar noch
weiter verkürzen, indem wir die Methodenaufrufe unmittelbar nach dem <code>?</code>
verketten, wie in Codeblock 9-8 zu sehen ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fs::File;
use std::io;
use std::io::Read;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    let mut s = String::new();

    File::open(&quot;hallo.txt&quot;)?.read_to_string(&amp;mut s)?;

    Ok(s)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-8: Verketten von Methodenaufrufen nach dem
<code>?</code>-Operator</span></p>
<p>Wir haben das Erstellen des neuen <code>String</code> in <code>s</code> an den Anfang der Funktion
verlegt; dieser Teil hat sich nicht geändert. Anstatt eine Variable <code>f</code> zu
erzeugen, haben wir den Aufruf von <code>read_to_string</code> direkt an das Ergebnis von
<code>File::open(&quot;hallo.txt&quot;)?</code> gehängt. Wir haben immer noch ein <code>?</code> am Ende des
Aufrufs von <code>read_to_string</code>, und wir geben immer noch einen <code>Ok</code>-Wert zurück,
der den Benutzernamen in <code>s</code> enthält, wenn sowohl <code>File::open</code> als auch
<code>read_to_string</code> erfolgreich sind, anstatt Fehler zurückzugeben. Die
Funktionalität ist wieder die gleiche wie in Codeblock 9-6 und Codeblock 9-7;
das ist nur eine andere, ergonomischere Schreibweise.</p>
<p>Wenn wir schon von verschiedenen Schreibweisen dieser Funktion sprechen, zeigt
Codeblock 9-9, dass es einen Weg gibt, diese Funktion noch kürzer zu machen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fs;
use std::io;

fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
    fs::read_to_string(&quot;hello.txt&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-9: Verwenden von <code>fs::read_to_string</code>,
anstatt die Datei zu öffnen und dann zu lesen</span></p>
<p>Das Einlesen einer Datei in eine Zeichenkette ist eine ziemlich häufig
benötigte Operation, daher bringt Rust die praktische Funktion
<code>fs::read_to_string</code> mit, die die Datei öffnet, einen neuen <code>String</code> erzeugt,
den Inhalt der Datei einliest, den Inhalt in den <code>String</code> einfügt und ihn
zurückgibt. Natürlich gibt uns die Verwendung von <code>fs::read_to_string</code> nicht
die Möglichkeit, die ganze Fehlerbehandlung zu erklären, also haben wir es
zuerst auf dem längeren Weg gemacht.</p>
<h4><a class="header" href="#der--operator-kann-in-funktionen-verwendet-werden-die-result-zurückgeben" id="der--operator-kann-in-funktionen-verwendet-werden-die-result-zurückgeben">Der <code>?</code>-Operator kann in Funktionen verwendet werden, die <code>Result</code> zurückgeben</a></h4>
<p>Der <code>?</code>-Operator kann in Funktionen verwendet werden, die den Rückgabetyp
<code>Result</code> haben, weil er so definiert ist, dass er auf die gleiche Weise
arbeitet wie der <code>match</code>-Ausdruck, den wir in Codeblock 9-6 definiert haben. 
Der Teil von <code>match</code>, der den Rückgabetyp <code>Result</code> erfordert, ist
<code>return Err(e)</code>, daher kann der Rückgabetyp der Funktion <code>Result</code> sein, um mit
<code>return</code> kompatibel zu sein.</p>
<p>Schauen wir uns an, was passiert, wenn wir den <code>?</code>-Operator in der Funktion
<code>main</code> verwenden, die, wie du dich erinnern wirst, den Rückgabetyp <code>()</code> hat:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">use std::fs::File;

fn main() {
    let f = File::open(&quot;hallo.txt&quot;)?;
}
</code></pre></pre>
<p>Wenn wir diesen Code kompilieren, erhalten wir folgende Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling error-handling v0.1.0 (file:///projects/error-handling)
error[E0277]: the `?` operator can only be used in a function that returns `Result` or `Option` (or another type that implements `std::ops::Try`)
 --&gt; src/main.rs:4:13
  |
3 | / fn main() {
4 | |     let f = File::open(&quot;hallo.txt&quot;)?;
  | |             ^^^^^^^^^^^^^^^^^^^^^^^^ cannot use the `?` operator in a function that returns `()`
5 | | }
  | |_- this function should return `Result` or `Option` to accept `?`
  |
  = help: the trait `std::ops::Try` is not implemented for `()`
  = note: required by `std::ops::Try::from_error`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0277`.
error: could not compile `error-handling`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Dieser Fehler weist darauf hin, dass wir den <code>?</code>-Operator nur in einer Funktion
verwenden dürfen, die <code>Result</code> oder <code>Option</code> oder einen anderen Typ, der
<code>std::ops::Try</code> implementiert, zurückgibt. Wenn du Code in einer Funktion
schreibst, die keinen dieser Typen zurückgibt, und du <code>?</code> verwenden willst,
wenn du andere Funktionen mit dem Rückgabetyp <code>Result&lt;T, E&gt;</code> aufrufst, hast du
zwei Möglichkeiten, dieses Problem zu lösen. Eine Technik besteht darin, den
Rückgabetyp deiner Funktion in <code>Result&lt;T, E&gt;</code> zu ändern, wenn dem nichts
entgegensteht. Die andere Technik besteht darin, <code>match</code> oder eine der Methoden
von <code>Result&lt;T, E&gt;</code> zu verwenden, um das <code>Result&lt;T, E&gt;</code> in geeigneter Weise zu
behandeln.</p>
<p>Die Funktion <code>main</code> ist etwas Besonderes und es gibt Einschränkungen
hinsichtlich ihres Rückgabetyps. Ein gültiger Rückgabetyp für main ist <code>()</code> und
bequemerweise auch <code>Result&lt;T, E&gt;</code>, wie hier zu sehen ist:</p>
<pre><pre class="playpen"><code class="language-rust should_panic">use std::error::Error;
use std::fs::File;

fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    let f = File::open(&quot;hallo.txt&quot;)?;

    Ok(())
}
</code></pre></pre>
<p>Der Typ <code>Box&lt;dyn Error&gt;</code> wird als Markmalsobjekt (trait object) bezeichnet,
über das wir im Abschnitt <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">„Merkmalsobjekte (trait objects) die Werte
unterschiedlicher Typen erlauben“</a> in Kapitel 17 sprechen
werden. Vorerst kannst du <code>Box&lt;dyn Fehler&gt;</code> als „eine beliebige Fehlerart“
ansehen. Das Verwenden von <code>?</code> in einer <code>main</code>-Funktion mit diesem Rückgabetyp
ist erlaubt.</p>
<p>Nachdem wir nun die Einzelheiten des Aufrufs von <code>panic!</code> und der Rückgabe von
<code>Result</code> besprochen haben, wollen wir zum Thema zurückkehren, wie wir
entscheiden können, was in welchen Fällen angemessen ist.</p>
<h2><a class="header" href="#wann-panic-aufrufen-und-wann-nicht" id="wann-panic-aufrufen-und-wann-nicht">Wann <code>panic!</code> aufrufen und wann nicht?</a></h2>
<p>Wie entscheidest du also, wann du <code>panic!</code> aufrufen und wann <code>Result</code>
zurückgeben sollst? Wenn Code abbricht, gibt es keine Möglichkeit sich vom
Fehler zu erholen. Du könntest <code>panic!</code> in jeder Fehlersituation anrufen,
unabhängig davon, ob es eine Möglichkeit zur Fehlerbehebung gibt oder nicht,
aber dann triffst du die Entscheidung für den Code, der deinen Code aufruft,
dass eine Situation nicht rettbar ist. Wenn du dich dafür entscheidest, einen
<code>Result</code>-Wert zurückzugeben, überlässt du dem aufrufenden Code die
Wahlmöglichkeit, anstatt die Entscheidung für ihn zu treffen. Der aufrufende
Code könnte sich dafür entscheiden, sich vom Fehler auf eine angemessene Weise
zu erholen, oder er könnte sich dafür entscheiden, dass ein <code>Err</code>-Wert in
diesem Fall nicht behebbar ist und <code>panic!</code> aufrufen, und so deinen behebbaren
Fehler in einen nicht behebbaren verwandeln. Daher ist die Rückgabe von
<code>Result</code> eine gute Standardwahl, wenn du eine Funktion definierst, die
fehlschlagen könnte.</p>
<p>In seltenen Situationen ist es besser, Code zu schreiben, der das Programm
abbricht, anstatt ein <code>Result</code> zurückzugeben. Lass uns untersuchen, warum es
bei Beispielen, Code-Prototypen und Tests angebracht ist, das Programm
abzubrechen. Dann werden wir Situationen besprechen, in denen der Kompilierer
nicht feststellen kann, dass ein Fehler unmöglich ist, du als Mensch aber
schon. Das Kapitel schließt mit einigen allgemeinen Richtlinien zur
Entscheidung, ob in Bibliothekscode ein Programm abgebrochen werden soll.</p>
<h3><a class="header" href="#beispiele-code-prototypen-und-tests" id="beispiele-code-prototypen-und-tests">Beispiele, Code-Prototypen und Tests</a></h3>
<p>Wenn du ein Beispiel schreibst, um ein Konzept zu veranschaulichen, kann ein
robuster Fehlerbehandlungscode das Beispiel unklarer machen. In Beispielen wird
davon ausgegangen, dass der Aufruf einer Methode wie <code>unwrap</code>, die das Programm
abbrechen könnte, als Platzhalter für die Art und Weise gedacht ist, wie deine
Anwendung mit Fehlern umgehen soll, die je nachdem, was der Rest deines Codes
tut, unterschiedlich sein können.</p>
<p>In ähnlicher Weise sind die Methoden <code>unwrap</code> und <code>expect</code> bei Prototypen sehr
praktisch, wenn du noch nicht entscheiden willst, wie mit Fehlern umzugehen
ist. Du hinterlässt klare Markierungen in deinem Code für später, wenn du dein
Programm robuster machst.</p>
<p>Wenn ein Methodenaufruf in einem Test fehlschlägt, würdest du wollen, dass der
gesamte Test fehlschlägt, auch wenn diese Methode nicht die zu testende
Funktionalität ist. Da ein Test mit <code>panic!</code> als fehlgeschlagen markiert wird,
ist der Aufruf von <code>unwrap</code> und <code>expect</code> genau das, was passieren sollte.</p>
<h3><a class="header" href="#fälle-in-denen-du-mehr-informationen-als-der-kompilierer-hast" id="fälle-in-denen-du-mehr-informationen-als-der-kompilierer-hast">Fälle, in denen du mehr Informationen als der Kompilierer hast</a></h3>
<p>Es wäre auch angemessen, <code>unwrap</code> aufzurufen, wenn du eine andere Logik hast,
die sicherstellt, dass <code>Result</code> einen <code>Ok</code>-Wert hat, aber die Logik kann vom
Kompilierer nicht verstanden werden. Du wirst immer noch ein <code>Result</code> haben,
mit dem du umgehen musst: Welche Operation auch immer du aufrufst, es besteht
immer noch die Möglichkeit, dass sie im Allgemeinen scheitert, auch wenn es in
deiner speziellen Situation logischerweise unmöglich ist. Wenn du durch
manuelle Codeinspektion sicherstellen kannst, dass du niemals eine
<code>Err</code>-Variante haben wirst, ist es vollkommen akzeptabel, <code>unwrap</code> aufzurufen.
Hier ist ein Beispiel:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::net::IpAddr;

let home: IpAddr = &quot;127.0.0.1&quot;.parse().unwrap();
<span class="boring">}
</span></code></pre></pre>
<p>Wir erstellen eine <code>IpAddr</code>-Instanz, indem wir eine hartkodierte Zeichenkette
parsen. Wir können sehen, dass <code>127.0.0.1</code> eine gültige IP-Adresse ist, sodass
es akzeptabel ist, hier <code>unwrap</code> zu verwenden. Eine hartkodierte, gültige
Zeichenkette ändert jedoch nicht den Rückgabetyp der <code>parse</code>-Methode: Wir
erhalten immer noch einen <code>Result</code>-Wert und der Kompilierer wird von uns
verlangen, <code>Result</code> so zu behandeln, als ob die <code>Err</code>-Variante möglich wäre,
weil der Kompilierer nicht klug genug ist, um zu erkennen, dass diese
Zeichenkette stets eine gültige IP-Adresse ist. Wenn die
IP-Adressen-Zeichenkette von einem Benutzer kam, anstatt fest im Programm
kodiert zu sein, und daher möglicherweise fehlschlagen könnte, würden wir
stattdessen definitiv <code>Result</code> auf eine robustere Weise behandeln wollen.</p>
<h3><a class="header" href="#richtlinien-zur-fehlerbehandlung" id="richtlinien-zur-fehlerbehandlung">Richtlinien zur Fehlerbehandlung</a></h3>
<p>Es ist ratsam, dass dein Code abbricht, wenn es möglich ist, dass dein Code in
einem schlechten Zustand enden könnte. In diesem Zusammenhang ist ein
<em>schlechter Zustand</em> (bad state) dann gegeben, wenn eine Annahme, eine
Garantie, ein Vertrag oder eine Invariante gebrochen wurde, z.B. wenn ungültige
Werte, widersprüchliche Werte oder fehlende Werte an deinen Code übergeben
werden – sowie eine oder mehrere der folgenden Punkte zutreffen:</p>
<ul>
<li>Es wird nicht davon ausgegangen, dass ein schlechter Zustand vorkommt kann.</li>
<li>Dein Code muss sich nach diesem Punkt darauf verlassen können, dass er sich
in keinem schlechten Zustand befindet.</li>
<li>Es gibt keine gute Möglichkeit, diese Informationen in den von dir
verwendeten Typen zu kodieren.</li>
</ul>
<p>Wenn jemand deinen Code aufruft und Werte eingibt, die keinen Sinn ergeben, ist
es vielleicht die beste Wahl, <code>panic!</code> anzurufen und die Person, die deine
Bibliothek benutzt, auf den Fehler in ihrem Code hinzuweisen, damit sie ihn
während der Entwicklung beheben kann. In ähnlicher Weise ist <code>panic!</code> oft
angebracht, wenn du externen Code aufrufst, der sich deiner Kontrolle entzieht
und einen ungültigen Zustand zurückgibt, den du nicht beheben kannst.</p>
<p>Wenn jedoch ein Fehler erwartet wird, ist es angemessener, ein <code>Result</code>
zurückzugeben, als <code>panic!</code> aufzurufen. Beispiele hierfür sind ein Parser, dem
fehlerhafte Daten übergeben werden, oder eine HTTP-Anfrage, die einen Status
zurückgibt, der anzeigt, dass du ein Aufruflimit erreicht hast. In diesen
Fällen zeigt der Rückgabetyp <code>Result</code> an, dass ein Fehler eine erwartete
Möglichkeit ist, bei der der aufrufende Code entscheiden muss, wie er damit
umgeht.</p>
<p>Wenn dein Code Operationen mit Werten ausführt, sollte dein Code zuerst
überprüfen, ob die Werte gültig sind, und das Programm abbrechen, wenn die
Werte nicht gültig sind. Dies geschieht hauptsächlich aus Sicherheitsgründen:
Der Versuch, mit ungültigen Daten zu operieren, kann deinen Code Schwachstellen
aussetzen. Dies ist der Hauptgrund dafür, dass die Standardbibliothek <code>panic!</code>
aufruft, wenn du versuchst, einen unzulässigen Speicherzugriff durchzuführen:
Der Versuch, auf Speicher zuzugreifen, der nicht zur aktuellen Datenstruktur
gehört, ist ein häufiges Sicherheitsproblem. Funktionen haben oft <em>Verträge</em>
(contracts): Ihr Verhalten ist nur dann garantiert, wenn die Eingaben bestimmte
Anforderungen erfüllen. Abzubrechen, wenn der Vertrag verletzt wird, ist
sinnvoll, weil eine Vertragsverletzung immer auf einen Fehler auf der
Anruferseite hinweist und es sich nicht um eine Fehlerart handelt, die der
aufgerufende Code explizit behandeln sollte. Tatsächlich gibt es keinen
vernünftigen Weg, wie sich der aufrufende Code vom Fehler erholen kann; die
aufrufenden <em>Programmierer</em> müssen den Code reparieren. Verträge zu einer
Funktion sollten in der API-Dokumentation der Funktion erläutert werden,
insbesondere wenn deren Verletzung zu einem Programmabbruch führt.</p>
<p>Zahlreiche Fehlerprüfungen in deinen Funktionen wären jedoch langatmig und
störend. Glücklicherweise kannst du das Typsystem von Rust (und damit die
Typprüfung durch den Kompilierer) verwenden, um viele Prüfungen für dich zu
übernehmen. Wenn deine Funktion einen besonderen Typ als Parameter hat, kannst
du mit der Logik deines Codes fortfahren, da du weißt, dass der Kompilierer
bereits sichergestellt hat, dass du einen gültigen Wert hast. Wenn du zum
Beispiel einen Typ anstatt einer <code>Option</code> hast, erwartet dein Programm <em>etwas</em>
statt <em>nichts</em>. Dein Code muss dann nicht zwei Fälle für die Varianten <code>Some</code>
und <code>None</code> behandeln: Er wird nur einen Fall mit definitiv einem Wert haben.
Code, der versucht, nichts an deine Funktion zu übergeben, lässt sich nicht
einmal kompilieren, sodass deine Funktion diesen Fall zur Laufzeit nicht prüfen
muss. Ein anderes Beispiel ist die Verwendung eines vorzeichenlosen
Ganzzahl-Typs wie <code>u32</code>, der sicherstellt, dass der Parameter niemals negativ
ist.</p>
<h3><a class="header" href="#benutzerdefinierte-typen-für-die-validierung-erstellen" id="benutzerdefinierte-typen-für-die-validierung-erstellen">Benutzerdefinierte Typen für die Validierung erstellen</a></h3>
<p>Gehen wir die Idee, das Rust-Typsystem zu verwenden, um sicherzustellen, dass
wir einen gültigen Wert haben, einen Schritt weiter und schauen uns an, wie wir
einen benutzerdefinierten Typ für die Validierung erstellen können. Erinnere
dich an das Ratespiel in Kapitel 2, bei dem unser Code den Benutzer
aufforderte, eine Zahl zwischen 1 und 100 zu erraten. Wir haben nie überprüft,
ob die Schätzung des Benutzers zwischen diesen Zahlen lag, bevor wir sie mit
unserer Geheimzahl verglichen haben; wir haben nur überprüft, ob die Schätzung
richtig war. In diesem Fall waren die Folgen nicht sehr gravierend: Unsere
Ausgabe von „zu groß“ oder „zu klein“ wäre immer noch richtig. Aber es wäre
eine nützliche Erweiterung, um den Benutzer zu gültigen Rateversuchen zu führen
und ein unterschiedliches Verhalten zu zeigen, wenn ein Benutzer eine Zahl
eingibt, die außerhalb des Bereichs liegt, als wenn ein Benutzer stattdessen
z.B. Buchstaben eingibt.</p>
<p>Eine Möglichkeit, dies zu tun, wäre, die Eingabe als <code>i32</code> statt nur als <code>u32</code>
zu parsen, um potenziell negative Zahlen zuzulassen, und dann eine
Bereichsprüfung der Zahl zu ergänzen, etwa so:</p>
<pre><code class="language-rust ignore">use rand::Rng;
use std::cmp::Ordering;
use std::io;

fn main() {
    println!(&quot;Rate eine Zahl!&quot;);

    let secret_number = rand::thread_rng().gen_range(1, 101);

    loop {
        // --abschneiden--

        println!(&quot;Bitte gib deine Vermutung ein.&quot;);

        let mut guess = String::new();

        io::stdin()
            .read_line(&amp;mut guess)
            .expect(&quot;Fehler beim Lesen der Zeile&quot;);

        let guess: i32 = match guess.trim().parse() {
            Ok(num) =&gt; num,
            Err(_) =&gt; continue,
        };

        if guess &lt; 1 || guess &gt; 100 {
            println!(&quot;Die geheime Zahl wird zwischen 1 und 100 liegen.&quot;);
            continue;
        }

        match guess.cmp(&amp;secret_number) {
            // --snip--
            Ordering::Less =&gt; println!(&quot;Zu klein!&quot;),
            Ordering::Greater =&gt; println!(&quot;Zu groß!&quot;),
            Ordering::Equal =&gt; {
                println!(&quot;Du hast gewonnen!&quot;);
                break;
            }
        }
    }
}
</code></pre>
<p>Der <code>if</code>-Ausdruck prüft, ob unser Wert außerhalb des Bereichs liegt, informiert
den Benutzer über das Problem und ruft <code>continue</code> auf, um die nächste Iteration
der Schleife zu starten und um eine weitere Schätzung zu bitten. Nach dem
<code>if</code>-Ausdruck können wir mit dem Vergleich zwischen <code>guess</code> und der Geheimzahl
fortfahren, wobei wir wissen, dass <code>guess</code> zwischen 1 und 100 liegt.</p>
<p>Dies ist jedoch keine Ideallösung: Wenn es absolut entscheidend wäre, dass das
Programm nur mit Werten zwischen 1 und 100 arbeitet, und wir viele Funktionen
mit dieser Anforderung haben, wäre eine solche Prüfung in jeder Funktion mühsam
(und könnte die Leistung beeinträchtigen).</p>
<p>Stattdessen können wir einen neuen Typ erstellen und die Validierungen in eine
Funktion geben, um eine Instanz des Typs zu erzeugen, anstatt die Validierungen
überall zu wiederholen. Auf diese Weise ist es für die Funktionen sicher, den
neuen Typ in ihren Signaturen zu verwenden und die erhaltenen Werte
vertrauensvoll zu nutzen. Codeblock 9-10 zeigt eine Möglichkeit, einen Typ
<code>Guess</code> zu definieren, der nur dann eine Instanz von <code>Guess</code> erzeugt, wenn die
Funktion <code>new</code> einen Wert zwischen 1 und 100 erhält.</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Der Schätzwert muss zwischen 1 und 100 liegen, ist jedoch {}.&quot;,
                   value);
        }

        Guess { value }
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 9-10: Ein Typ <code>Guess</code>, der nur bei Werten
zwischen 1 und 100 fortsetzt</span></p>
<p>Zuerst definieren wir eine Struktur <code>Guess</code>, die ein Feld <code>value</code> hat, das
einen <code>i32</code> enthält. Hier wird die Nummer gespeichert.</p>
<p>Dann implementieren wir die zugehörige Funktion <code>new</code> auf <code>Guess</code>, die
Instanzen von <code>Guess</code> erzeugt. Die Funktion <code>new</code> ist so definiert, dass sie
einen Parameter <code>value</code> vom Typ <code>i32</code> nimmt und eine <code>Guess</code>-Instanz
zurückgibt. Der Code im Funktionsrumpf von <code>new</code> testet den Wert in <code>value</code>, um
sicherzustellen, dass er zwischen 1 und 100 liegt. Wenn <code>value</code> diesen Test
nicht besteht, rufen wir <code>panic!</code> auf, was den Programmierer des aufrufenden
Codes darauf aufmerksam macht, dass er einen Fehler hat, den er beheben muss,
denn ein <code>Guess</code> mit einem Wert außerhalb dieses Bereichs zu erzeugen, würde
den Vertrag verletzen, auf den sich <code>Guess::new</code> verlässt. Die Bedingungen,
unter denen <code>Guess::new</code> das Programm abbricht, sollten in der öffentlich
zugänglichen API-Dokumentation genannt werden; wir werden die
Dokumentationskonventionen, die auf die Möglichkeit eines <code>panic!</code>-Aufrufs
hinweisen, in der API-Dokumentation behandeln, die du in Kapitel 14 erstellst. 
Wenn <code>value</code> den Test besteht, erstellen wir eine neue <code>Guess</code>-Instanz, deren
Feld <code>value</code> den Parameterwert <code>value</code> erhält, und geben die Instanz zurück.</p>
<p>Als nächstes implementieren wir eine Methode namens <code>value</code>, die <code>self</code>
ausleiht, keine anderen Parameter hat und ein <code>i32</code> zurückgibt. Diese
Methodenart wird manchmal als <em>Abfragemethode</em> (getter) bezeichnet, weil ihr
Zweck darin besteht, Daten aus ihren Feldern zurückzugeben. Diese öffentliche
Methode ist notwendig, weil das Feld <code>value</code> der Struktur <code>Guess</code> privat ist.
Es ist wichtig, dass das Feld <code>value</code> privat ist, damit Code, der die Struktur
<code>Guess</code> verwendet, <code>value</code> nicht direkt setzen kann: Code außerhalb des Moduls
<em>muss</em> die Funktion <code>Guess::new</code> verwenden, um eine Instanz von <code>Guess</code> zu
erzeugen, wodurch sichergestellt wird, dass es keine Möglichkeit gibt, dass
<code>Guess</code> einen <code>Wert</code> hat, der nicht durch die Bedingungen in der Funktion
<code>Guess::new</code> überprüft wurde.</p>
<p>Eine Funktion, die einen Parameter hat oder nur Zahlen zwischen 1 und 100
zurückgibt, könnte dann in ihrer Signatur angeben, dass sie ein <code>Guess</code>
anstelle eines <code>i32</code> entgegennimmt oder zurückgibt und bräuchte dann in ihrem
Rumpf keine zusätzlichen Prüfungen durchzuführen.</p>
<h2><a class="header" href="#zusammenfassung-5" id="zusammenfassung-5">Zusammenfassung</a></h2>
<p>Die Fehlerbehandlungsfunktionen von Rust sollen dir helfen, robusteren Code zu
schreiben. Das Makro <code>panic!</code> signalisiert, dass sich dein Programm in einem
Zustand befindet, mit dem es nicht umgehen kann, und ermöglicht es dir, den
Prozess anzuhalten, anstatt zu versuchen, mit ungültigen oder falschen Werten
fortzufahren. Die Aufzählung <code>Result</code> verwendet das Typsystem von Rust, um
anzuzeigen, dass Operationen so fehlschlagen könnten, dass dein Code sich davon
wieder erholen könnte. Du kannst <code>Result</code> verwenden, um dem Code, der deinen
Code aufruft, mitzuteilen, dass er auch mit potentiellem Erfolg und Misserfolg
umgehen muss. Das Verwenden von <code>panic!</code> und <code>Result</code> in den entsprechenden
Situationen wird deinen Code angesichts unvermeidlicher Probleme zuverlässiger
machen.</p>
<p>Nachdem du nun nützliche Möglichkeiten gesehen hast, wie die Standardbibliothek
generische Datentypen mit den Enums <code>Option</code> und <code>Result</code> verwendet, werden wir
darüber sprechen, wie generische Datentypen funktionieren und wie du sie in
deinem Code verwenden kannst.</p>
<h1><a class="header" href="#generische-typen-merkmale-traits-und-lebensdauer" id="generische-typen-merkmale-traits-und-lebensdauer">Generische Typen, Merkmale (traits) und Lebensdauer</a></h1>
<p>Jede Programmiersprache verfügt über Werkzeuge, mit denen die Duplizierung von
Konzepten (duplication of concepts) effektiv gehandhabt werden kann. In Rust
ist ein solches Werkzeug der <em>generische Datentyp</em> (generics). Generische
Datentypen sind abstrakte Stellvertreter für konkrete Typen oder andere
Eigenschaften. Wenn wir Code schreiben, können wir das Verhalten generischer
Datentypen oder ihre Beziehung zu anderen generischen Datentypen ausdrücken,
ohne zu wissen, was an ihrer Stelle beim Kompilieren und Ausführen des Codes
stehen wird.</p>
<p>Ähnlich wie eine Funktion Parameter mit unbekannten Werten entgegennimmt, um
den gleichen Code auf mehreren konkreten Werten auszuführen, können Funktionen
Parameter irgendeines generischen Typs anstelle eines konkreten Typs, wie <code>i32</code>
oder <code>String</code>, haben. Tatsächlich haben wir generische Datentypen bereits in
Kapitel 6 mit <code>Option&lt;T&gt;</code>, in Kapitel 8 mit <code>Vec&lt;T&gt;</code> und <code>HashMap&lt;K, V&gt;</code> und in
Kapitel 9 mit <code>Result&lt;T, E&gt;</code> verwendet. In diesem Kapitel erfährst du, wie du
deine eigenen Typen, Funktionen und Methoden mit generischen Datentypen
definieren kannst!</p>
<p>Zunächst werden wir uns anschauen, wie eine Funktion extrahiert werden kann, um
Code-Duplizierung zu reduzieren. Danach verwenden wir dieselbe Technik, um aus
zwei Funktionen, die sich nur im Datentyp ihrer Parameter unterscheiden, eine
generische Funktion zu machen. Wir werden auch erklären, wie generische Typen
in Struktur- (struct) und Aufzählungsdefinitionen (enum) verwendet werden
können.</p>
<p>Dann wirst du lernen, wie man <em>Merkmale</em> (traits) verwendet, um Verhalten auf
generische Weise zu definieren. Du kannst Merkmale mit generischen Typen
kombinieren, um einen generischen Typ auf solche Typen einzuschränken, die ein
bestimmtes Verhalten aufweisen, im Gegensatz zu einem beliebigen Typ.</p>
<p>Schließlich werden wir die <em>Lebensdauer</em> (lifetimes) besprechen, eine Spielart
generischer Typen, die dem Kompilierer Informationen darüber gibt, wie
Referenzen zueinander in Beziehung stehen. Die Lebensdauer erlaubt es uns, in
vielen Situationen Werte auszuleihen und gleichzeitig dem Kompilierer die
Möglichkeit zu geben, die Gültigkeit der Referenzen zu überprüfen.</p>
<h2><a class="header" href="#duplikate-entfernen-durch-extrahieren-einer-funktion" id="duplikate-entfernen-durch-extrahieren-einer-funktion">Duplikate entfernen durch Extrahieren einer Funktion</a></h2>
<p>Bevor wir in die Syntax der generischen Typen eintauchen, wollen wir uns
zunächst ansehen, wie man Duplikate, die keine generischen Typen betreffen,
durch Extrahieren einer Funktion entfernt. Dann werden wir diese Technik
anwenden, um eine generische Funktion zu extrahieren! Auf die gleiche Weise,
wie du doppelten Code erkennst, der zu einer Funktion extrahiert wird, wirst du
auch doppelten Code erkennen, der generische Typen verwenden kann.</p>
<p>Betrachte ein kurzes Programm, das die größte Zahl in einer Liste findet, wie
in Codeblock 10-1 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);
<span class="boring">    assert_eq!(largest, 100);
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 10-1: Code zum Finden der größten Zahl in einer
Liste von Zahlen</span></p>
<p>Dieser Code enthält eine Liste von ganzen Zahlen in der Variablen <code>number_list</code>
und weist die erste Zahl der Liste einer Variablen namens <code>largest</code> zu. Dann
iteriert sie über alle Zahlen in der Liste und wenn die aktuelle Zahl größer
ist als die in <code>largest</code> gespeicherte Zahl, ersetzt sie die Zahl in dieser
Variablen. Wenn die aktuelle Zahl jedoch kleiner oder gleich der größten bisher
gefundenen Zahl ist, ändert sich die Variable nicht, und der Code geht zur
nächsten Zahl in der Liste weiter. Nach dem Durchlaufen aller Zahlen in der
Liste sollte <code>largest</code> die größte Zahl enthalten, in diesem Fall 100.</p>
<p>Um die größte Zahl in zwei verschiedenen Zahlenlisten zu finden, können wir den
Code in Codeblock 10-1 duplizieren und dieselbe Logik an zwei verschiedenen
Stellen im Programm verwenden, wie in Codeblock 10-2 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = number_list[0];

    for number in number_list {
        if number &gt; largest {
            largest = number;
        }
    }

    println!(&quot;Die größte Zahl ist {}&quot;, largest);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-2: Code zum Auffinden der größten Zahl in
<em>zwei</em> Zahlenlisten</span></p>
<p>Obwohl dieser Code funktioniert, ist das Duplizieren von Code mühsam und
fehleranfällig. Außerdem müssen wir den Code an mehreren Stellen aktualisieren,
wenn wir ihn ändern wollen.</p>
<p>Um diese Redundanz zu eliminieren, können wir eine Abstraktion schaffen, indem
wir eine Funktion definieren, die auf einer beliebigen Liste ganzer Zahlen
operiert, die ihr als Parameter übergeben wird. Diese Lösung macht unseren Code
klarer und lässt uns das Konzept, die größte Zahl in einer Liste zu finden,
abstrakter ausdrücken.</p>
<p>In Codeblock 10-3 extrahierten wir den Code, der die größte Zahl findet, in
eine Funktion namens <code>largest</code>. Im Unterschied zum Code in Codeblock 10-1, der
die größte Zahl in nur einer bestimmten Liste finden kann, kann dieses Programm
die größte Zahl in zwei verschiedenen Listen finden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 6000);
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 10-3: Abstrahierter Code, um die größte Zahl in
zwei Listen zu finden</span></p>
<p>Die Funktion <code>largest</code> hat einen Parameter <code>list</code>, der einen beliebigen
Anteilstyp von <code>i32</code>-Werten repräsentiert, die wir an die Funktion übergeben
könnten. Wenn wir die Funktion aufrufen, läuft der Code also auf den
spezifischen Werten, die wir übergeben.</p>
<p>Zusammenfassend hier die Schritte, die wir unternommen haben, um den Code aus
Codeblock 10-2 in Codeblock 10-3 zu überführen:</p>
<ol>
<li>Identifiziere doppelten Code.</li>
<li>Extrahiere den doppelten Code in den Funktionskörper und spezifiziere die
Eingabe- und Rückgabewerte dieses Codes in der Funktionssignatur.</li>
<li>Aktualisiere die beiden Instanzen des doppelten Codes, um stattdessen die
Funktion aufzurufen.</li>
</ol>
<p>Als Nächstes werden wir dieselben Schritte auf generische Datentypen anwenden,
um doppelten Code auf unterschiedliche Weise zu reduzieren. Ähnlich wie der
Funktionsrumpf auf einer abstrakten Liste anstelle spezifischer Werte arbeiten
kann, erlauben es generische Datentypen, auf abstrakten Typen zu arbeiten.</p>
<p>Nehmen wir zum Beispiel an, wir hätten zwei Funktionen: Eine, die das größte
Element in einem Anteilstyp mit <code>i32</code>-Werten findet, und eine, die das größte
Element in einem Anteilstyp mit <code>char</code>-Werten findet. Wie würden wir diese
Duplizierung beseitigen? Lass es uns herausfinden!</p>
<h2><a class="header" href="#generische-datentypen" id="generische-datentypen">Generische Datentypen</a></h2>
<p>Wir können generische Datentypen (generics) verwenden, um Definitionen für
Elemente wie Funktionssignaturen oder Strukturen (structs) zu erstellen, die
wir dann mit vielen verschiedenen konkreten Datentypen verwenden können. Sehen
wir uns zunächst an, wie Funktionen, Strukturen, Aufzählungen und Methoden
mithilfe von generischen Datentypen definiert werden können. Danach werden wir
uns ansehen, wie generische Datentypen die Code-Performanz beeinflussen.</p>
<h3><a class="header" href="#in-funktionsdefinitionen" id="in-funktionsdefinitionen">In Funktionsdefinitionen</a></h3>
<p>Bei der Definition einer Funktion, die generische Datentypen verwendet,
platzieren wir die generischen Datentypen in der Signatur der Funktion, wo wir
normalerweise die Datentypen der Parameter und des Rückgabewerts angeben
würden. Dadurch wird unser Code flexibler und bietet den Aufrufern unserer
Funktion mehr Funktionalität, während gleichzeitig Code-Duplikate verhindert
werden.</p>
<p>Um mit unserer Funktion <code>largest</code> fortzufahren, zeigt Codeblock 10-4 zwei
Funktionen, die beide den größten Wert in einem Anteilstyp finden.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest_i32(list: &amp;[i32]) -&gt; i32 {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn largest_char(list: &amp;[char]) -&gt; char {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest_i32(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 100);
</span>
    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest_char(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
<span class="boring">    assert_eq!(result, 'y');
</span>}
</code></pre></pre>
<p><span class="caption">Codeblock 10-4: Zwei Funktionen, die sich nur in ihren
Namen und den Typen in ihren Signaturen unterscheiden</span></p>
<p>Die Funktion <code>largest_i32</code> ist diejenige, die wir in Codeblock 10-3 extrahiert
haben und die den größten <code>i32</code> in einem Anteilstyp findet. Die Funktion
<code>largest_char</code> findet das größte <code>char</code> in einem Anteilstyp. Die
Funktionsrümpfe haben den gleichen Code, also lass uns die Duplizierung
eliminieren, indem wir einen generischen Typparameter in einer einzigen
Funktion einführen.</p>
<p>Um die Typen in der neuen Funktion, die wir definieren werden, zu
parametrisieren, müssen wir den Typparameter benennen, so wie wir es für die
Wertparameter einer Funktion tun. Du kannst jeden beliebigen Bezeichner als
Typparametername verwenden. Aber wir werden <code>T</code> verwenden, weil die
Parameternamen gemäß Konvention in Rust kurz sind, oft nur ein Buchstabe, und
Rusts Typbezeichnungskonvention verwendet Binnenmajuskel (CamelCase). Als
Abkürzung für „Typ“ ist <code>T</code> die Standardwahl der meisten Rust-Programmierer.</p>
<p>Wenn wir einen Parameter im Funktionsrumpf verwenden, müssen wir den
Parameternamen in der Signatur deklarieren, damit der Kompilierer weiß, was
dieser Name bedeutet. In ähnlicher Weise müssen wir den Typ-Parameternamen
deklarieren, bevor wir ihn in einer Funktionssignatur verwenden können. Um die
generische Funktion <code>largest</code> zu definieren, platzieren wir die
Typnamen-Deklarationen innerhalb spitzer Klammern <code>&lt;&gt;</code>, zwischen dem
Funktionsnamen und der Parameterliste, so wie hier:</p>
<pre><code class="language-rust ignore">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
</code></pre>
<p>Wir lesen diese Definition wie folgt: Die Funktion <code>largest</code> ist generisch über
einen Typ <code>T</code>. Sie hat einen Parameter namens <code>list</code>, der ein Anteilstyp von
Werten des Typs <code>T</code> ist. Die Funktion <code>largest</code> gibt einen Wert des gleichen
Typs <code>T</code> zurück.</p>
<p>Codeblock 10-5 zeigt die kombinierte Funktionsdefinition <code>largest</code>, die den
generischen Datentyp in ihrer Signatur verwendet. Der Codeblock zeigt auch, wie
wir die Funktion entweder mit einem Anteilstyp von <code>i32</code>-Werten oder
<code>char</code>-Werten aufrufen können. Beachte, dass sich dieser Code noch nicht
kompilieren lässt, aber wir werden das Problem später in diesem Kapitel
beheben.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn largest&lt;T&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-5: Eine Definition der Funktion <code>largest</code>,
die generische Typparameter verwendet, aber noch nicht kompiliert</span></p>
<p>Wenn wir diesen Code kompilieren, erhalten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Hinweis erwähnt <code>std::cmp::PartialOrd</code>, was ein <em>Merkmal</em> (trait) ist. Wir
werden im nächsten Abschnitt über Merkmale sprechen. Vorerst bedeutet dieser
Fehler, dass der Rumpf von <code>largest</code> nicht für alle möglichen Typen
funktioniert, die <code>T</code> sein könnten. Da wir Werte des Typs <code>T</code> im Rumpf
vergleichen wollen, können wir nur Typen verwenden, deren Werte sortiert werden
können. Um Vergleiche zu ermöglichen, hat die Standardbibliothek das Merkmal
<code>std::cmp::PartialOrd</code>, das du auf Typen implementieren kannst (siehe Anhang C
für weitere Informationen zu diesem Merkmal). Du wirst im Abschnitt <a href="ch10-02-traits.html#traits-as-parameters">„Merkmale
als Parameter“</a> lernen, wie man angibt, dass ein
generischer Typ ein bestimmtes Merkmal hat, aber lass uns zunächst andere
Möglichkeiten der Verwendung generischer Typparameter untersuchen.</p>
<h3><a class="header" href="#in-struktur-definitionen" id="in-struktur-definitionen">In Struktur-Definitionen</a></h3>
<p>Wir können auch Strukturen definieren, um einen generischen Typparameter in
einem oder mehreren Feldern mit der <code>&lt;&gt;</code> Syntax zu verwenden. Codeblock 10-6
zeigt, wie man eine Struktur <code>Point&lt;T&gt;</code> definiert, um Koordinatenwerte <code>x</code> und
<code>y</code> eines beliebigen Typs aufzunehmen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-6: Eine Struktur <code>Point&lt;T&gt;</code>, die Werte <code>x</code>
und <code>y</code> vom Typ <code>T</code> enthält</span></p>
<p>Die Syntax zum Verwenden von generischen Datentypen in Strukturdefinitionen
ähnelt der Syntax, die in Funktionsdefinitionen verwendet wird. Zuerst
deklarieren wir den Namen des Typparameters innerhalb spitzer Klammern direkt
nach dem Namen der Struktur. Dann können wir den generischen Typ in der
Strukturdefinition verwenden, wo wir sonst konkrete Datentypen angeben würden.</p>
<p>Beachte, da wir nur einen generischen Typ zur Definition von <code>Point&lt;T&gt;</code>
verwendet haben, besagt diese Definition, dass die Struktur <code>Point&lt;T&gt;</code>
generisch über einen Typ <code>T</code> ist, und die beiden Felder <code>x</code> und <code>y</code> <em>denselben</em>
Typ haben, welcher Typ das auch immer sein mag. Wenn wir eine Instanz von
<code>Point&lt;T&gt;</code> erzeugen, die Werte unterschiedlichen Typs hat, wie in Codeblock
10-7, wird sich unser Code nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    let wont_work = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-7: Die Felder <code>x</code> und <code>y</code> müssen vom
gleichen Typ sein, da beide den gleichen generischen Datentyp <code>T</code> haben.</span></p>
<p>Wenn wir in diesem Beispiel <code>x</code> den Integer-Wert 5 zuweisen, lassen wir den
Kompilierer wissen, dass der generische Typ <code>T</code> für diese Instanz von
<code>Point&lt;T&gt;</code> ein Integer sein wird. Wenn wir dann 4.0 für <code>y</code> angeben, das wir so
definiert haben, dass es den gleichen Typ wie <code>x</code> hat, erhalten wir einen
Typfehler wie diesen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0308]: mismatched types
 --&gt; src/main.rs:7:38
  |
7 |     let wont_work = Point { x: 5, y: 4.0 };
  |                                      ^^^ expected integer, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Um eine Struktur <code>Point</code> zu definieren, bei der <code>x</code> und <code>y</code> generische, aber
unterschiedliche, Typen haben können, können wir mehrere generische
Typparameter verwenden. Zum Beispiel können wir in Codeblock 10-8 die
Definition von <code>Point</code> so ändern, dass sie über den Typen <code>T</code> und <code>U</code> generisch
ist, wobei <code>x</code> vom Typ <code>T</code> und <code>y</code> vom Typ <code>U</code> ist.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-8: <code>Point&lt;T, U&gt;</code> ist generisch über zwei
Typen, sodass <code>x</code> und <code>y</code> Werte unterschiedlichen Typs haben können</span></p>
<p>Jetzt sind alle gezeigten Instanzen von <code>Point</code> erlaubt! Du kannst so viele
generische Typparameter in einer Definition verwenden, wie du willst, aber das
Verwenden von mehr als einigen wenigen macht deinen Code schwer lesbar. Wenn du
viele generische Typen in deinem Code benötigst, könnte dies darauf hinweisen,
dass dein Code in kleinere Teile zerlegt werden muss.</p>
<h3><a class="header" href="#in-aufzählungsdefinitionen" id="in-aufzählungsdefinitionen">In Aufzählungsdefinitionen</a></h3>
<p>Wie wir es bei Strukturen gemacht haben, können wir Aufzählungen definieren, um
generische Datentypen in ihren Varianten zu verwenden. Werfen wir noch einmal
einen Blick auf die Aufzählung <code>Option&lt;T&gt;</code>, die die Standardbibliothek bietet
und die wir in Kapitel 6 verwendet haben:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    Some(T),
    None,
}
<span class="boring">}
</span></code></pre></pre>
<p>Diese Definition dürfte für dich jetzt mehr Sinn machen. Wie du sehen kannst,
ist <code>Option&lt;T&gt;</code> eine Aufzählung, die über dem Typ <code>T</code> generisch ist und zwei
Varianten hat: <code>Some</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>None</code>, die
keinen Wert enthält. Durch das Verwenden der Aufzählung <code>Option&lt;T&gt;</code> können wir
das abstrakte Konzept eines optionalen Wertes ausdrücken und da <code>Option&lt;T&gt;</code>
generisch ist, können wir diese Abstraktion unabhängig vom Typ des
optionalen Wertes verwenden.</p>
<p>Aufzählungen können auch mehrere generische Typen verwenden. Die Definition der
Aufzählung <code>Result</code>, die wir in Kapitel 9 verwendet haben, ist ein Beispiel
dafür:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Aufzählung <code>Result</code> ist generisch über zwei Typen <code>T</code> und <code>E</code> und hat zwei
Varianten: <code>Ok</code>, die einen Wert vom Typ <code>T</code> enthält, und <code>Err</code>, die einen Wert
vom Typ <code>E</code> enthält. Diese Definition macht es bequem, die Aufzählung <code>Result</code>
überall dort zu verwenden, wo wir eine Operation haben, die erfolgreich sein
(gibt einen Wert vom Typ <code>T</code> zurück) oder fehlschlagen (gibt einen Fehler vom
Typ <code>E</code> zurück) könnte. Tatsächlich haben wir dies beim Öffnen einer Datei in
Codeblock 9-3 verwendet, wobei für <code>T</code> der Typ <code>std::fs::File</code> verwendet wurde,
wenn die Datei erfolgreich geöffnet wurde, und für <code>E</code> der Typ
<code>std::io::Error</code>, wenn es Probleme beim Öffnen der Datei gab.</p>
<p>Wenn du in deinem Code Situationen mit mehreren Struktur- oder
Aufzählungsdefinitionen erkennst, die sich nur in den Typen der darin
enthaltenen Werte unterscheiden, kannst du doppelten Code vermeiden, indem du
stattdessen generische Typen verwendest.</p>
<h3><a class="header" href="#in-methodendefinitionen" id="in-methodendefinitionen">In Methodendefinitionen</a></h3>
<p>Wir können Methoden auf Strukturen und Aufzählungen implementieren (wie wir es
in Kapitel 5 getan haben) und auch generische Typen in ihren Definitionen
verwenden. Codeblock 10-9 zeigt die Struktur <code>Point&lt;T&gt;</code>, die wir in Codeblock
10-6 definiert haben, mit einer darauf implementierten Methode namens <code>x</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Point&lt;T&gt; {
    fn x(&amp;self) -&gt; &amp;T {
        &amp;self.x
    }
}

fn main() {
    let p = Point { x: 5, y: 10 };

    println!(&quot;p.x = {}&quot;, p.x());
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-9: Implementierung einer Methode <code>x</code> auf der
Struktur <code>Point&lt;T&gt;</code>, die eine Referenz auf das Feld <code>x</code> vom Typ <code>T</code>
zurückgibt</span></p>
<p>Hier haben wir eine Methode <code>x</code> auf <code>Point&lt;T&gt;</code> definiert, die eine Referenz auf
den Wert im Feld <code>x</code> zurückgibt.</p>
<p>Beachte, dass wir <code>T</code> direkt nach <code>impl</code> deklarieren müssen, damit wir Methoden
zum Typ <code>Punkt&lt;T&gt;</code> implementieren können. Durch das Deklarieren von <code>T</code> als
generischen Typ hinter <code>impl</code> kann Rust erkennen, dass der Typ in spitzen
Klammern in <code>Point</code> ein generischer und kein konkreter Typ ist.</p>
<p>Wir könnten zum Beispiel Methoden nur für <code>Point&lt;f32&gt;</code>-Instanzen
implementieren, anstatt für <code>Point&lt;T&gt;</code>-Instanzen mit einem generischen Typ. In
Codeblock 10-10 verwenden wir den konkreten Typ <code>f32</code>, d.h. wir deklarieren
keinen Typ hinter <code>impl</code>.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct Point&lt;T&gt; {
</span><span class="boring">    x: T,
</span><span class="boring">    y: T,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;T&gt; Point&lt;T&gt; {
</span><span class="boring">    fn x(&amp;self) -&gt; &amp;T {
</span><span class="boring">        &amp;self.x
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let p = Point { x: 5, y: 10 };
</span><span class="boring">
</span><span class="boring">    println!(&quot;p.x = {}&quot;, p.x());
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-10: Ein <code>impl</code>-Block, der nur für eine
Struktur mit einem bestimmten konkreten Typ für den generischen Typparameter
<code>T</code> gilt</span></p>
<p>Dieser Code bedeutet, dass der Typ <code>Point&lt;f32&gt;</code> eine Methode namens
<code>distance_from_origin</code> hat und andere Instanzen von <code>Point&lt;T&gt;</code>, bei denen <code>T</code>
nicht vom Typ <code>f32</code> ist, haben diese Methode nicht. Die Methode misst, wie weit
unser Punkt vom Punkt mit den Koordinaten (0,0, 0,0) entfernt ist, und
verwendet mathematische Operationen, die nur für Fließkomma-Typen zur Verfügung
stehen.</p>
<p>Generische Typparameter in einer Strukturdefinition sind nicht immer die
gleichen wie die, die du in den Methodensignaturen für diese Struktur
verwendest. Zum Beispiel definiert Codeblock 10-11 die Methode <code>mixup</code> auf der
Struktur <code>Point&lt;T, U&gt;</code> aus Codeblock 10-8. Die Methode nimmt einen weiteren
<code>Point</code> als Parameter, der andere Typen haben kann als die bei <code>self</code>. Die
Methode erzeugt eine neue <code>Point</code>-Instanz mit dem Wert <code>x</code> aus <code>self</code> (vom Typ
<code>T</code>) und dem Wert <code>y</code> aus dem übergebenen <code>Point</code> (vom Typ <code>W</code>).</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    fn mixup&lt;V, W&gt;(self, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; {
        Point {
            x: self.x,
            y: other.y,
        }
    }
}

fn main() {
    let p1 = Point { x: 5, y: 10.4 };
    let p2 = Point { x: &quot;Hallo&quot;, y: 'c' };

    let p3 = p1.mixup(p2);

    println!(&quot;p3.x = {}, p3.y = {}&quot;, p3.x, p3.y);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-11: Eine Methode, die verschiedene
generische Typen aus der Definition ihrer Struktur verwendet</span></p>
<p>In <code>main</code> haben wir einen <code>Point</code> definiert, bei dem <code>x</code> den Typ <code>i32</code> (mit dem
Wert <code>5</code>) und <code>y</code> den Typ <code>f64</code> (mit dem Wert <code>10.4</code>) hat. Die Variable <code>p2</code>
ist eine Struktur <code>Point</code>, bei der <code>x</code> einen Zeichenkettenanteilstyp (mit dem
Wert <code>&quot;Hallo&quot;</code>) und <code>y</code> den Typ <code>char</code> (mit dem Wert <code>c</code>) hat. Wenn wir <code>mixup</code>
auf <code>p1</code> mit dem Argument <code>p2</code> aufrufen, erhalten wir <code>p3</code>, das ein <code>i32</code> für
<code>x</code> haben wird, weil <code>x</code> von <code>p1</code> kam. Die Variable <code>p3</code> wird ein <code>char</code> für
<code>y</code> haben, weil <code>y</code> von <code>p2</code> stammt. Der Makroaufruf <code>println!</code> gibt
<code>p3.x = 5, p3.y = c</code> aus.</p>
<p>Der Zweck dieses Beispiels ist es, eine Situation zu demonstrieren, in der
einige generische Parameter mit <code>impl</code> und einige mit der Methodendefinition
deklariert werden. Hier werden die generischen Parameter <code>T</code> und <code>U</code> nach
<code>impl</code> deklariert, weil sie zur Strukturdefinition gehören. Die generischen
Parameter <code>V</code> und <code>W</code> werden nach <code>fn mixup</code> deklariert, da sie nur für die
Methode relevant sind.</p>
<h3><a class="header" href="#code-performanz-beim-verwenden-generischer-datentypen" id="code-performanz-beim-verwenden-generischer-datentypen">Code-Performanz beim Verwenden generischer Datentypen</a></h3>
<p>Du fragst dich vielleicht, ob beim Verwenden generischer Typparameter
Laufzeitkosten anfallen. Die gute Nachricht ist, dass Rust generische
Typparameter so implementiert, dass dein Code mit generischen Typen nicht
langsamer läuft als mit konkreten Typen.</p>
<p>Rust erreicht dies durch Duplizierung von Code, der zur Kompilierzeit
generische Datentypen verwendet. <em>Codeduplizierung</em> (monomorphization) ist der
Vorgang der Umwandlung von generischem Code in spezifischen Code durch
Ausfüllen der konkreten Typen, die bei der Kompilierung verwendet werden.</p>
<p>Bei diesem Prozess führt der Kompilierer das Gegenteil der Schritte aus, die
wir beim Erstellen der generischen Funktion in Codeblock 10-5 angewendet haben: 
Der Kompilierer schaut sich alle Stellen an, an denen generischer Code
aufgerufen wird, und generiert Code für die konkreten Typen, mit denen der
generische Code aufgerufen wird.</p>
<p>Betrachten wir die Funktionsweise anhand eines Beispiels, das die Aufzählung
<code>Option&lt;T&gt;</code> der Standardbibliothek verwendet:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let integer = Some(5);
let float = Some(5.0);
<span class="boring">}
</span></code></pre></pre>
<p>Wenn Rust diesen Code kompiliert, führt es eine Codeduplizierung durch. Während
dieses Vorgangs liest der Kompilierer die Werte ein, die in
<code>Option&lt;T&gt;</code>-Instanzen verwendet wurden, und identifiziert zwei Arten von
<code>Option&lt;T&gt;</code>: Eine verwendet den Typ <code>i32</code> und die andere <code>f64</code>. Daraufhin
erweitert es die generische Definition von <code>Option&lt;T&gt;</code> zu <code>Option_i32</code> und
<code>Option_f64</code> und ersetzt damit die generische Definition durch die spezifische.</p>
<p>Die duplizierte Codeversion sieht wie folgt aus. Die generische <code>Option&lt;T&gt;</code>
wird durch die vom Kompilierer erstellten spezifischen Definitionen ersetzt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">enum Option_i32 {
    Some(i32),
    None,
}

enum Option_f64 {
    Some(f64),
    None,
}

fn main() {
    let integer = Option_i32::Some(5);
    let float = Option_f64::Some(5.0);
}
</code></pre></pre>
<p>Da Rust generischen Code in Code kompiliert, der den Typ in jedem Fall
spezifiziert, zahlen wir keine Laufzeitkosten beim Verwenden von generischen
Datentypen. Wenn der Code läuft, verhält er sich genauso, wie wenn wir jede
Definition von Hand dupliziert hätten. Der Vorgang der Codeduplizierung macht
Rusts generische Datentypen zur Laufzeit äußerst effizient.</p>
<h2><a class="header" href="#merkmale-traits-gemeinsames-verhalten-definieren" id="merkmale-traits-gemeinsames-verhalten-definieren">Merkmale (traits): Gemeinsames Verhalten definieren</a></h2>
<p>Ein <em>Merkmal</em> (trait) teilt dem Rust-Kompilierer mit, welche Funktionalität ein
bestimmter Typ hat und mit anderen Typen teilen kann. Wir können Merkmale
verwenden, um gemeinsames Verhalten auf abstrakte Weise zu definieren. Wir
können Merkmalsabgrenzungen (trait bounds) verwenden, um anzugeben, dass ein
generischer Typ jeder Typ sein kann, der ein bestimmtes Verhalten aufweist.</p>
<blockquote>
<p>Anmerkung: Merkmale sind einer Funktionalität recht ähnlich, die in anderen
Sprachen oft <em>Schnittstelle</em> (interface) genannt wird, wenn auch mit einigen
Unterschieden.</p>
</blockquote>
<h3><a class="header" href="#ein-merkmal-definieren" id="ein-merkmal-definieren">Ein Merkmal definieren</a></h3>
<p>Das Verhalten eines Typs besteht aus den Methoden, die wir auf diesen Typ
anwenden können. Verschiedene Typen haben das gleiche Verhalten, wenn wir bei
allen die gleichen Methoden aufrufen können. Merkmalsdefinitionen sind eine
Möglichkeit, Methodensignaturen zu gruppieren, um eine Reihe von
Verhaltensweisen zu definieren, die zum Erreichen eines bestimmten Zwecks
erforderlich sind.</p>
<p>Nehmen wir zum Beispiel an, wir haben mehrere Strukturen (structs), die
verschiedene Arten und Mengen von Text enthalten: Eine Struktur <code>NewsArticle</code>,
die eine Nachricht enthält, die sich auf einen bestimmten Ort bezieht, und ein
<code>Tweet</code>, der maximal 280 Zeichen umfassen kann, sowie Metadaten, die angeben,
ob es sich um eine neue Kurznachricht, eine Wiederholung oder eine Antwort auf
eine andere Kurznachricht handelt.</p>
<p>Wir wollen eine Medienaggregator-Bibliothek erstellen, die Zusammenfassungen
von Daten anzeigen kann, die in einer <code>NewsArticle</code>- oder <code>Tweet</code>-Instanz
gespeichert sind. Dazu benötigen wir eine Zusammenfassung für jeden Typ und wir
wollen diese Zusammenfassung anfordern, indem wir eine Methode <code>summarize</code> der
Instanz aufrufen. Codeblock 10-12 zeigt die Definition eines Merkmals
<code>Summary</code>, das dieses Verhalten zum Ausdruck bringt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String;
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-12: Ein Merkmal <code>Summary</code>, dessen Verhalten
aus der Methode <code>summarize</code> besteht</span></p>
<p>Hier deklarieren wir ein Merkmal mit dem Schlüsselwort <code>trait</code> und dann den
Namen des Merkmals, der in diesem Fall <code>Summary</code> lautet. Innerhalb der
geschweiften Klammern deklarieren wir die Methodensignaturen, die das Verhalten
der Typen beschreiben, die dieses Merkmal implementieren, was in diesem Fall
<code>fn summarize(&amp;self) -&gt; String</code> ist.</p>
<p>Nach der Methodensignatur verwenden wir statt einer Implementierung in
geschweiften Klammern ein Semikolon. Jeder Typ, der dieses Merkmal
implementiert, muss sein eigenes benutzerdefiniertes Verhalten für den
Methodenrumpf bereitstellen. Der Kompilierer wird sicherstellen, dass jeder
Typ, der das Merkmal <code>Summary</code> hat, die Methode <code>summarize</code> mit genau dieser
Signatur hat.</p>
<p>Ein Merkmal kann mehrere Methoden umfassen: Die Methodensignaturen werden
zeilenweise aufgelistet und jede Zeile endet mit einem Semikolon.</p>
<h3><a class="header" href="#ein-merkmal-für-einen-typ-implementieren" id="ein-merkmal-für-einen-typ-implementieren">Ein Merkmal für einen Typ implementieren</a></h3>
<p>Da wir nun das gewünschte Verhalten mithilfe des Merkmals <code>Summary</code> definiert
haben, können wir es für die Typen unseres Medienaggregators implementieren. 
Codeblock 10-13 zeigt eine Implementierung des Merkmals <code>Summary</code> für die
Struktur <code>NewsArticle</code>, die die Überschrift, den Autor und den Ort verwendet,
um den Rückgabewert von <code>summarize</code> zu erzeugen. Für die Struktur <code>Tweet</code>
definieren wir <code>summarize</code> als den Benutzernamen, gefolgt vom gesamten Text der
Kurznachricht, wobei wir davon ausgehen, dass der Inhalt der Kurznachricht
bereits auf 280 Zeichen begrenzt ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
    }
}

pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-13: Implementierung des Merkmals <code>Summary</code>
für die Typen <code>NewsArticle</code> und <code>Tweet</code></span></p>
<p>Die Implementierung eines Merkmals für einen Typ ist ähnlich zur
Implementierung regulärer Methoden. Der Unterschied besteht darin, dass wir
nach <code>impl</code> den Namen des Merkmals schreiben, das wir implementieren wollen,
dann das Schlüsselwort <code>for</code> gefolgt vom Namen des Typs angeben, für den wir
das Merkmal implementieren wollen. Innerhalb des <code>impl</code>-Blocks geben wir die
Methodensignaturen an, die das Merkmal vorgibt. Anstatt nach jeder Signatur ein
Semikolon zu schreiben, verwenden wir geschweifte Klammern und füllen den
Methodenrumpf mit dem spezifischen Verhalten, das die Methoden des Merkmals für
den jeweiligen Typ haben sollen.</p>
<p>Nachdem wir das Merkmal implementiert haben, können wir die Methoden der
<code>NewsArticle</code>- und <code>Tweet</code>-Instanzen auf die gleiche Weise aufrufen, wie wir
reguläre Methoden aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(
            &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
        ),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: horse_ebooks: natürlich, wie du wahrscheinlich schon weißt</code> aus.</p>
<p>Beachte, dass wir in Codeblock 10-13 das Merkmal <code>Summary</code> und die Typen
<code>NewsArticle</code> und <code>Tweet</code> in der gleichen Datei <em>lib.rs</em> definiert haben,
sodass sie alle im gleichen Gültigkeitsbereich liegen. Nehmen wir an, diese
Datei <em>lib.rs</em> ist für eine Kiste (crate), die wir <code>aggregator</code> genannt haben,
und jemand anderes möchte die Funktionalität unserer Kiste nutzen, um das
Merkmal <code>Summary</code> für eine Struktur innerhalb des Gültigkeitsbereichs seiner
Bibliothek zu implementieren. Dann muss er das Merkmal erst in seinen
Gültigkeitsbereich bringen. Er würde dies durch Angeben von
<code>use aggregator::Summary;</code> tun, was es ihm dann ermöglichen würde,<code>Summary</code> für
seinen Typ zu implementieren. Das Merkmal <code>Summary</code> müsste auch ein
öffentliches Merkmal für eine andere Kiste sein, um sie zu implementieren, was
auch der Fall ist, weil wir in Codeblock 10-12 das Schlüsselwort <code>pub</code> vor das
Merkmal <code>trait</code> gestellt haben.</p>
<p>Eine Einschränkung, die bei der Implementierung von Merkmalen zu beachten ist,
ist, dass wir ein Merkmal für einen Typ nur dann implementieren können, wenn
entweder das Merkmal oder der Typ lokal in unserer Kiste vorhanden ist. Zum
Beispiel können wir Standard-Bibliotheksmerkmale wie <code>Display</code> auf einem
benutzerdefinierten Typ wie <code>Tweet</code> als Teil unserer
<code>aggregator</code>-Kistenfunktionalität implementieren, weil der Typ <code>Tweet</code> lokal zu
unserer <code>aggregator</code>-Kiste gehört. Wir können auch <code>Summary</code> auf <code>Vec&lt;T&gt;</code> in
unserer <code>aggregator</code>-Kiste implementieren, weil das Merkmal <code>Summary</code> lokal zu
unserer <code>aggregator</code>-Kiste gehört.</p>
<p>Aber wir können externe Merkmale nicht auf externe Typen anwenden. Zum Beispiel
können wir das Merkmal <code>Display</code> auf <code>Vec&lt;T&gt;</code> in unserer <code>aggregator</code>-Kiste
nicht implementieren, weil <code>Display</code> und <code>Vec&lt;T&gt;</code> in der Standardbibliothek
definiert sind und nicht lokal zu unserer <code>aggregator</code>-Kiste gehören. Diese
Beschränkung ist Teil einer Eigenschaft von Programmen namens <em>Kohärenz</em>
(coherence), genauer gesagt der <em>Waisenregel</em> (orphan rule), die so genannt
wird, weil der übergeordnete Typ nicht vorhanden ist. Diese Regel stellt
sicher, dass der Code anderer Personen deinen Code nicht brechen kann und
umgekehrt. Ohne diese Regel könnten zwei Kisten dasselbe Merkmal für denselben
Typ implementieren und Rust wüsste nicht, welche Implementierung es verwenden
sollte.</p>
<h3><a class="header" href="#standard-implementierungen" id="standard-implementierungen">Standard-Implementierungen</a></h3>
<p>Manchmal ist es nützlich, ein Standardverhalten für einige oder alle Methoden
eines Merkmals zu haben, anstatt Implementierungen für alle Methoden für jeden
Typ zu verlangen. Wenn wir dann das Merkmal für einem bestimmten Typ
implementieren, können wir das Standardverhalten jeder Methode beibehalten oder
überschreiben.</p>
<p>Codeblock 10-14 zeigt, wie man eine Standard-Zeichenkette für die Methode
<code>summarize</code> des Merkmals <code>Summary</code> angibt, anstatt nur die Methodensignatur zu
definieren, wie wir es in Codeblock 10-12 getan haben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize(&amp;self) -&gt; String {
        String::from(&quot;(Lies mehr ...)&quot;)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-14: Definition eines Merkmals <code>Summary</code> mit
einer Standard-Implementierung der Methode <code>summarize</code></span></p>
<p>Um eine Standard-Implementierung zu verwenden, um Instanzen von <code>NewsArticle</code>
zusammenzufassen, anstatt eine benutzerdefinierte Implementierung zu
definieren, geben wir einen leeren <code>impl</code>-Block mit <code>impl Summary for NewsArticle {}</code> an.</p>
<p>Auch wenn wir die Methode <code>summarize</code> nicht mehr direkt für <code>NewsArticle</code>
definieren, haben wir eine Standard-Implementierung bereitgestellt und
festgelegt, dass <code>NewsArticle</code> das Merkmal <code>Summary</code> implementiert.
Infolgedessen können wir immer noch die Methode <code>summarize</code> einer
<code>NewsArticle</code>-Instanz aufrufen, etwa so:</p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, NewsArticle, Summary};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let article = NewsArticle {
        headline: String::from(&quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;),
        location: String::from(&quot;Pittsburgh, PA, USA&quot;),
        author: String::from(&quot;Iceburgh&quot;),
        content: String::from(&quot;Die Pittsburgh Penguins sind erneut die beste \
                               Eishockeymannschaft in der NHL.&quot;,
        ),
    };

    println!(&quot;Neuer Artikel verfügbar! {}&quot;, article.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>Neuer Artikel verfügbar! (Lies mehr ...)</code> aus.</p>
<p>Das Erstellen einer Standard-Implementierung für <code>summarize</code> erfordert nicht,
dass wir an der Implementierung von <code>Summary</code> für <code>Tweet</code> in Codeblock 10-13
etwas ändern. Der Grund dafür ist, dass die Syntax für das Überschreiben einer
Standard-Implementierung die gleiche ist wie die Syntax für die Implementierung
einer Merkmalsmethode, die keine Standard-Implementierung hat.</p>
<p>Standard-Implementierungen können andere Methoden desselben Merkmals aufrufen,
selbst wenn diese anderen Methoden keine Standard-Implementierung haben. Auf
diese Weise kann ein Merkmal eine Menge nützlicher Funktionalität bereitstellen
und von den Implementierern nur die Angabe eines kleinen Teils verlangen. Zum
Beispiel könnten wir das Merkmal <code>Summary</code> so definieren, dass wir eine Methode
<code>summarize_author</code> haben, deren Implementierung erforderlich ist, und dann eine
Methode <code>summarize</code> definieren, die eine Standard-Implementierung hat und die
Methode <code>summarize_author</code> aufruft:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub trait Summary {
    fn summarize_author(&amp;self) -&gt; String;

    fn summarize(&amp;self) -&gt; String {
        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Um diese Version von <code>Summary</code> zu verwenden, müssen wir <code>summarize_author</code> nur
dann definieren, wenn wir das Merkmal für einen Typ implementieren:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize_author(&amp;self) -&gt; String;
</span><span class="boring">
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;(Lies mehr von {}...)&quot;, self.summarize_author())
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span>impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
        format!(&quot;@{}&quot;, self.username)
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Nachdem wir <code>summarize_author</code> definiert haben, können wir <code>summarize</code> auf
Instanzen der <code>Tweet</code>-Struktur aufrufen, und die Standard-Implementierung von
<code>summarize</code> wird die Definition von <code>summarize_author</code> aufrufen, die wir
bereitgestellt haben. Da wir <code>summarize_author</code> implementiert haben, hat uns
das Merkmal <code>Summary</code> das Verhalten der <code>summarize</code>-Methode mitgeliefert, ohne
dass wir weiteren Code schreiben müssen. </p>
<pre><code class="language-rust ignore"><span class="boring">use chapter10::{self, Summary, Tweet};
</span><span class="boring">
</span><span class="boring">fn main() {
</span>    let tweet = Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    };

    println!(&quot;1 neue Kurznachricht: {}&quot;, tweet.summarize());
<span class="boring">}
</span></code></pre>
<p>Dieser Code gibt <code>1 neue Kurznachricht: (Lies mehr von @horse_ebooks...)</code> aus.</p>
<p>Beachte, dass es nicht möglich ist, die Standardimplementierung von einer
übergeordneten Implementierung derselben Methode aus aufzurufen.</p>
<h3><a class="header" href="#merkmale-als-parameter" id="merkmale-als-parameter">Merkmale als Parameter</a></h3>
<p>Da du jetzt weißt, wie man Merkmale definiert und implementiert, können wir
untersuchen, wie man Merkmale zur Definition von Funktionen verwendet, die
viele verschiedene Typen akzeptieren.</p>
<p>Beispielsweise haben wir in Codeblock 10-13 das Merkmal <code>Summary</code> für die Typen
<code>NewsArticle</code> und <code>Tweet</code> implementiert. Wir können eine Funktion <code>notify</code>
definieren, die die Methode <code>summarize</code> ihres <code>item</code>-Parameters aufruft, der
einen Typ hat, der das Merkmal <code>Summary</code> implementiert. Um dies zu tun, können
wir die Syntax <code>impl Trait</code> verwenden, etwa so:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify(item: impl Summary) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>Anstelle eines konkreten Typs für den Parameter <code>item</code> geben wir das
Schlüsselwort <code>impl</code> und den Merkmalsnamen an. Dieser Parameter akzeptiert
jeden Typ, der das angegebene Merkmal implementiert. Im Rumpf von <code>notify</code>
können wir alle Methoden von <code>item</code> aufrufen, die vom Merkmal <code>Summary</code>
herrühren, zum Beispiel <code>summarize</code>. Wir können <code>notify</code> aufrufen und jede
Instanz von <code>NewsArticle</code> und <code>Tweet</code> angeben. Code, der die Funktion mit einem
anderen Typ aufruft, z.B. <code>String</code> oder <code>i32</code>, lässt sich nicht kompilieren, da
diese Typen kein <code>Summary</code> implementieren.</p>
<h4><a class="header" href="#merkmalsabgrenzungs-syntax" id="merkmalsabgrenzungs-syntax">Merkmalsabgrenzungs-Syntax</a></h4>
<p>Die Syntax <code>impl Trait</code> funktioniert für einfache Fälle, ist aber eigentlich
syntaktischer Zucker für eine längere Form, die <em>Merkmalsabgrenzung</em> (trait
bound) genannt wird; sie sieht so aus:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>pub fn notify&lt;T: Summary&gt;(item: &amp;T) {
    println!(&quot;Eilmeldung! {}&quot;, item.summarize());
}
<span class="boring">}
</span></code></pre></pre>
<p>Diese längere Form entspricht dem Beispiel im vorigen Abschnitt, ist aber
wortreicher. Wir platzieren Merkmalsabgrenzungen in der Deklaration des
generischen Typparameters nach einem Doppelpunkt und innerhalb spitzer
Klammern.</p>
<p>Die Syntax <code>impl Trait</code> ist bequem und ermöglicht in einfachen Fällen einen
prägnanteren Code. Die Merkmalsabgrenzungs-Syntax kann andererseits mehr
Komplexität ausdrücken. Zum Beispiel können wir zwei Parameter haben, die
<code>Summary</code> implementieren. Das Verwenden der Syntax <code>impl Trait</code> sieht
folgendermaßen aus:</p>
<pre><code class="language-rust ignore">pub fn notify(item1: &amp;impl Summary, item2: &amp;impl Summary) {
</code></pre>
<p>Wenn wir wollten, dass diese Funktion bei <code>item1</code> und <code>item2</code> unterschiedliche
Typen haben kann, wäre das Verwenden von <code>impl Trait</code> dafür geeignet (solange
beide Typen <code>Summary</code> implementieren). Wenn beide Parameter aber den gleichen
Typ haben sollten, dann kann man das nur durch eine Merkmalsabgrenzung
ausdrücken, so wie hier:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary&gt;(item1: &amp;T, item2: &amp;T) {
</code></pre>
<p>Der als Parametertyp für <code>item1</code> und <code>item2</code> angegebene generische Typ <code>T</code>
schränkt die Funktion so ein, dass der konkrete Typ der als Argument für
<code>item1</code> und <code>item2</code> übergebenen Werte derselbe sein muss.</p>
<h4><a class="header" href="#angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-" id="angeben-mehrerer-merkmalsabgrenzungen-mit-der-syntax-">Angeben mehrerer Merkmalsabgrenzungen mit der Syntax <code>+</code></a></h4>
<p>Wir können auch mehr als eine Merkmalsabgrenzung angeben. Nehmen wir an, wir
wollen, dass sowohl <code>notify</code> als auch die Methode <code>summarize</code> die
Bildschirmausgabe für <code>item</code> formatieren: Spezifizieren wir in der
<code>notify</code>-Definition, dass <code>item</code> sowohl <code>Display</code> als auch <code>Summary</code>
implementieren muss. Wir können dies mit der Syntax <code>+</code> tun:</p>
<pre><code class="language-rust ignore">pub fn notify(item: &amp;(impl Summary + Display)) {
</code></pre>
<p>Die Syntax <code>+</code> ist auch bei Merkmalsabgrenzungen mit generischen Typen gültig:</p>
<pre><code class="language-rust ignore">pub fn notify&lt;T: Summary + Display&gt;(item: &amp;T) {
</code></pre>
<p>Mit den beiden angegebenen Merkmalsabgrenzungen kann der Rumpf von <code>notify</code> die
Methode <code>summarize</code> aufrufen und <code>{}</code> verwenden, um <code>item</code> zu formatieren.</p>
<h4><a class="header" href="#klarere-merkmalsabgrenzungen-mit-where-klauseln" id="klarere-merkmalsabgrenzungen-mit-where-klauseln">Klarere Merkmalsabgrenzungen mit <code>where</code>-Klauseln</a></h4>
<p>Zu viele Merkmalsabgrenzungen zu verwenden, hat seine Schattenseiten. Jeder
generische Datentyp hat seine eigenen Merkmalsabgrenzungen, sodass Funktionen
mit mehreren generischen Typparametern viele Merkmalsabgrenzungsangaben
zwischen Funktionsname und Parameterliste enthalten können, wodurch die
Funktionssignatur schwer lesbar wird. Aus diesem Grund hat Rust für die Angabe
von Merkmalsabgrenzungen eine alternative Syntax in Form einer <code>where</code>-Klausel
nach der Funktionssignatur. Anstatt das hier zu schreiben:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: &amp;T, u: &amp;U) -&gt; i32 {
</code></pre>
<p>können wir eine <code>where</code>-Klausel wie folgt verwenden:</p>
<pre><code class="language-rust ignore">fn some_function&lt;T, U&gt;(t: &amp;T, u: &amp;U) -&gt; i32
    where T: Display + Clone,
          U: Clone + Debug
{
</code></pre>
<p>Die Signatur dieser Funktion ist übersichtlicher: Der Funktionsname, die
Parameterliste und der Rückgabetyp liegen nahe beieinander, ähnlich wie bei
einer Funktion ohne viele Merkmalsabgrenzungen.</p>
<h3><a class="header" href="#rückgabetypen-die-merkmale-implementieren" id="rückgabetypen-die-merkmale-implementieren">Rückgabetypen, die Merkmale implementieren</a></h3>
<p>Wir können die Syntax <code>impl Trait</code> auch für den Rückgabetyp verwenden, wie hier
gezeigt:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable() -&gt; impl Summary {
    Tweet {
        username: String::from(&quot;horse_ebooks&quot;),
        content: String::from(&quot;natürlich, wie du wahrscheinlich schon weißt&quot;),
        reply: false,
        retweet: false,
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Durch Verwenden von <code>impl Summary</code> für den Rückgabetyp legen wir fest, dass die
Funktion <code>returns_summarizable</code> einen Typ zurückgibt, der das Merkmal <code>Summary</code>
implementiert, ohne den konkreten Typ zu nennen. In diesem Fall gibt
<code>returns_summarizable</code> einen <code>Tweet</code> zurück, aber der Code, der diese Funktion
aufruft, weiß das nicht.</p>
<p>Die Fähigkeit, einen Typ zurückzugeben, der nur durch das Merkmal spezifiziert
ist, das er implementiert, ist besonders nützlich im Zusammenhang mit
Funktionsabschlüssen und Iteratoren, die wir in Kapitel 13 behandeln.
Funktionsabschlüsse und Iteratoren erzeugen Typen, die nur der Kompilierer
kennt oder deren Spezifikation sehr lang ist. Mit der Syntax <code>impl Trait</code>
kannst du prägnant angeben, dass eine Funktion einen Typ zurückgibt, der das
Merkmal <code>Iterator</code> implementiert, ohne dass du einen sehr langen Typ schreiben
musst.</p>
<p>Du kannst <code>impl Trait</code> jedoch nur verwenden, wenn du einen einzigen Typ
zurückgibst. Beispielsweise würde dieser Code, der entweder einen <code>NewsArticle</code>
oder einen <code>Tweet</code> mit dem Rückgabetyp <code>impl Summary</code> zurückgibt, nicht
funktionieren:</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub trait Summary {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct NewsArticle {
</span><span class="boring">    pub headline: String,
</span><span class="boring">    pub location: String,
</span><span class="boring">    pub author: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for NewsArticle {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}, von {} ({})&quot;, self.headline, self.author, self.location)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Tweet {
</span><span class="boring">    pub username: String,
</span><span class="boring">    pub content: String,
</span><span class="boring">    pub reply: bool,
</span><span class="boring">    pub retweet: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Summary for Tweet {
</span><span class="boring">    fn summarize(&amp;self) -&gt; String {
</span><span class="boring">        format!(&quot;{}: {}&quot;, self.username, self.content)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(
                &quot;Pinguine gewinnen die Stanley-Cup-Meisterschaft!&quot;,
            ),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(
                &quot;Die Pittsburgh Penguins sind erneut die beste \
                 Eishockeymannschaft in der NHL.&quot;,
            ),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(
                &quot;natürlich, wie du wahrscheinlich schon weißt&quot;,
            ),
            reply: false,
            retweet: false,
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Rückgabe entweder eines <code>NewsArticle</code> oder eines <code>Tweet</code> ist aufgrund von
Einschränkungen hinsichtlich der Implementierung der Syntax <code>impl Trait</code> im
Kompilierer nicht erlaubt. Wie man eine Funktion mit diesem Verhalten schreibt,
wird im Abschnitt <a href="ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types">„Merkmalsobjekte (trait objects) die Werte unterschiedlicher
Typen erlauben“</a>
in Kapitel 17 behandelt.</p>
<h3><a class="header" href="#korrigieren-der-funktion-largest-mit-merkmalsabgrenzungen" id="korrigieren-der-funktion-largest-mit-merkmalsabgrenzungen">Korrigieren der Funktion <code>largest</code> mit Merkmalsabgrenzungen</a></h3>
<p>Da du nun weißt, wie du das gewünschte Verhalten mit generischer
Typparameterabgrenzung spezifizieren kannst, kehren wir zu Codeblock 10-5
zurück, um die Definition der Funktion <code>largest</code>, die einen generischen
Typparameter verwendet, zu korrigieren! Als wir das letzte Mal versuchten,
den Code auszuführen, erhielten wir diesen Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0369]: binary operation `&gt;` cannot be applied to type `T`
 --&gt; src/main.rs:5:17
  |
5 |         if item &gt; largest {
  |            ---- ^ ------- T
  |            |
  |            T
  |
  = note: `T` might need a bound for `std::cmp::PartialOrd`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0369`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Im Rumpf von <code>largest</code> wollten wir zwei Werte vom Typ <code>T</code> mit dem Operator
größer als (<code>&gt;</code>) vergleichen. Da dieser Operator als Standardmethode für das
Standardbibliotheks-Merkmal <code>std::cmp::PartialOrd</code> definiert ist, müssen wir
<code>PartialOrd</code> als Merkmalsabgrenzung für <code>T</code> angeben, damit die Funktion
<code>largest</code> auf Anteilstypen beliebiger Typen arbeiten kann, die wir vergleichen
können. Wir brauchen <code>PartialOrd</code> nicht in den Gültigkeitsbereich zu bringen,
weil das automatisch erfolgt. Ändere die Signatur von <code>largest</code> wie folgt:</p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd&gt;(list: &amp;[T]) -&gt; T {
<span class="boring">    let mut largest = list[0];
</span><span class="boring">
</span><span class="boring">    for &amp;item in list {
</span><span class="boring">        if item &gt; largest {
</span><span class="boring">            largest = item;
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    largest
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let number_list = vec![34, 50, 25, 100, 65];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;number_list);
</span><span class="boring">    println!(&quot;Die größte Zahl ist {}&quot;, result);
</span><span class="boring">
</span><span class="boring">    let char_list = vec!['y', 'm', 'a', 'q'];
</span><span class="boring">
</span><span class="boring">    let result = largest(&amp;char_list);
</span><span class="boring">    println!(&quot;Das größte Zeichen ist {}&quot;, result);
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir den Code kompilieren, erhalten wir nun andere Fehlermeldungen:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0508]: cannot move out of type `[T]`, a non-copy slice
 --&gt; src/main.rs:2:23
  |
2 |     let mut largest = list[0];
  |                       ^^^^^^^
  |                       |
  |                       cannot move out of here
  |                       move occurs because `list[_]` has type `T`, which does not implement the `Copy` trait
  |                       help: consider borrowing here: `&amp;list[0]`

error[E0507]: cannot move out of a shared reference
 --&gt; src/main.rs:4:18
  |
4 |     for &amp;item in list {
  |         -----    ^^^^
  |         ||
  |         |data moved here
  |         |move occurs because `item` has type `T`, which does not implement the `Copy` trait
  |         help: consider removing the `&amp;`: `item`

error: aborting due to 2 previous errors

Some errors have detailed explanations: E0507, E0508.
For more information about an error, try `rustc --explain E0507`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Schlüsselzeile bei diesem Fehler ist <code>cannot move out of type [T], a non-copy slice</code>. Mit unseren nicht-generischen Versionen der Funktion <code>largest</code>
versuchten wir nur, die größte <code>i32</code> oder <code>char</code> zu finden. Wie im Abschnitt
<a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel
4 besprochen, können Typen wie <code>i32</code> und <code>char</code>, die eine bekannte Größe haben,
auf dem Stapelspeicher gespeichert werden, sodass sie das Merkmal <code>Copy</code>
implementieren. Aber als wir die Funktion <code>largest</code> generisch gemacht haben,
wurde es möglich, dass der Parameter <code>list</code> Typen enthält, die das Merkmal
<code>Copy</code> nicht implementieren. Folglich wären wir nicht in der Lage, den Wert aus
<code>list[0]</code> in die Variable <code>largest</code> zu verschieben, was zu diesem Fehler führt.</p>
<p>Um diesen Code nur mit den Typen aufzurufen, die das Merkmal <code>Copy</code>
implementieren, können wir <code>Copy</code> zu den Merkmalsabgrenzungen von <code>T</code>
hinzufügen! Codeblock 10-15 zeigt den vollständigen Code einer generischen
Funktion <code>largest</code>, die kompiliert, solange die Typen der Werte im Anteilstyp,
die wir der Funktion übergeben, die Merkmale <code>PartialOrd</code> <em>und</em> <code>Copy</code>
implementieren, wie <code>i32</code> und <code>char</code> es tun.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {
    let mut largest = list[0];

    for &amp;item in list {
        if item &gt; largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&amp;number_list);
    println!(&quot;Die größte Zahl ist {}&quot;, result);

    let char_list = vec!['y', 'm', 'a', 'q'];

    let result = largest(&amp;char_list);
    println!(&quot;Das größte Zeichen ist {}&quot;, result);
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-15: Eine funktionierende Definition der
Funktion <code>largest</code>, die mit jedem generischen Typ funktioniert, der die
Merkmale <code>PartialOrd</code> und <code>Copy</code> implementiert</span></p>
<p>Wenn wir die Funktion <code>largest</code> nicht auf Typen beschränken wollen, die das
Merkmal <code>Copy</code> implementieren, könnten wir angeben, dass <code>T</code> die
Merkmalsabgrenzung <code>Clone</code> anstelle von <code>Copy</code> verwendet. Dann könnten wir
jeden Wert des Anteilstyps klonen, wenn wir wollen, dass die Funktion <code>largest</code>
die Eigentümerschaft übernimmt. Das Verwenden der Funktion <code>clone</code> bedeutet,
dass wir potenziell mehr Allokationen im dynamischen Speicher im Falle von
Typen vornehmen, die dynamische Speicherdaten wie <code>String</code> besitzen. Und
Allokationen im dynamischen Speicher können langsam sein, wenn wir mit großen
Datenmengen arbeiten.</p>
<p>Eine andere Möglichkeit, wie wir <code>largest</code> implementieren könnten, besteht
darin, dass die Funktion eine Referenz auf einen <code>T</code>-Wert im Anteilstyp
zurückgibt. Wenn wir den Rückgabetyp in <code>&amp;T</code> anstelle von <code>T</code> ändern und
dadurch den Funktionsrumpf ändern, um eine Referenz zurückzugeben, bräuchten
wir die Merkmalsabgrenzungen <code>Clone</code> oder <code>Copy</code> nicht und könnten Allokationen
im dynamischen Speicher vermeiden. Versuche, diese alternativen Lösungen selbst
zu implementieren!</p>
<h3><a class="header" href="#verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden" id="verwenden-von-merkmalsabgrenzungen-zur-bedingten-implementierung-von-methoden">Verwenden von Merkmalsabgrenzungen zur bedingten Implementierung von Methoden</a></h3>
<p>Durch Verwenden einer Merkmalsabgrenzung mit einem <code>impl</code>-Block, der generische
Typparameter verwendet, können wir Methoden bedingt für Typen implementieren,
die das angegebene Merkmal implementieren. Beispielsweise implementiert der Typ
<code>Pair&lt;T&gt;</code> in Codeblock 10-16 immer die Funktion <code>new</code>. Aber <code>Pair&lt;T&gt;</code>
implementiert die Methode <code>cmp_display</code> nur, wenn ihr innerer Typ <code>T</code> die
Merkmale <code>PartialOrd</code> <em>und</em> <code>Display</code> implementiert, die den Vergleich bzw.
eine Ausgabe ermöglichen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>use std::fmt::Display;

struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self { x, y }
    }
}

impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;Das größte Element ist x = {}&quot;, self.x);
        } else {
            println!(&quot;Das größte Element ist y = {}&quot;, self.y);
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-16: Bedingte Implementierung von Methoden
für einen generischen Typ in Abhängigkeit von Merkmalsabgrenzungen</span></p>
<p>Wir können auch ein Merkmal für beliebige Typen bedingt implementieren, die ein
anderes Merkmal implementieren. Implementierungen eines Merkmals für Typen, die
Merkmalsabgrenzungen erfüllen, werden als <em>Pauschal-Implementierungen</em> (blanket
implementations) bezeichnet und kommen in der Rust-Standardbibliothek ausgiebig
zur Anwendung. Beispielsweise implementiert die Standardbibliothek das Merkmal
<code>ToString</code> für jeden Typ, der das Merkmal <code>Display</code> implementiert. Der
<code>impl</code>-Block in der Standardbibliothek sieht in etwa so aus:</p>
<pre><code class="language-rust ignore">impl&lt;T: Display&gt; ToString for T {
    // --abschneiden--
}
</code></pre>
<p>Da die Standardbibliothek diese Pauschal-Implementierungen hat, können wir die
<code>to_string</code>-Methode, die durch das Merkmal <code>ToString</code> definiert ist, bei jedem
Typ aufrufen, der das Merkmal <code>Display</code> implementiert. Zum Beispiel können wir
ganze Zahlen in ihre entsprechenden <code>String</code>-Werte umwandeln, weil ganze
Zahlen <code>Display</code> implementieren:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s = 3.to_string();
<span class="boring">}
</span></code></pre></pre>
<p>Pauschal-Implementierungen erscheinen in der Dokumentation des Merkmals im
Abschnitt „Implementierer“ (implementors).</p>
<p>Mithilfe von Merkmalen und Merkmalsabgrenzungen können wir Code schreiben, der
generische Typparameter verwendet, um Duplikationen zu reduzieren, aber auch
dem Kompilierer gegenüber angeben, dass der generische Typ ein bestimmtes
Verhalten haben soll. Der Kompilierer kann dann die Merkmalsabgrenzungen
verwenden, um zu überprüfen, ob alle konkreten Typen, die von unserem Code
verwendet werden, das richtige Verhalten aufweisen. In dynamisch typisierten
Sprachen würden wir einen Laufzeitfehler erhalten, wenn wir eine Methode bei
einem Typ aufrufen, der die Methode nicht definiert hat. Rust verschiebt diese
Fehler jedoch in die Kompilierzeit und verlangt damit, dass wir die Probleme
beheben, bevor unser Code überhaupt lauffähig ist. Außerdem müssen wir keinen
Code schreiben, der das Verhalten zur Laufzeit überprüft, da wir es bereits zur
Kompilierungszeit überprüft haben. Auf diese Weise wird die Performanz
verbessert, ohne die Flexibilität der generischen Datentypen aufgeben zu
müssen.</p>
<p>Eine weitere generische Funktionalität, die wir bereits verwendet haben, heißt
<em>Lebensdauer</em> (lifetimes). Anstatt sicherzustellen, dass ein Typ das von uns
gewünschte Verhalten hat, stellen wir durch die Lebensdauer sicher, dass
Referenzen so lange gültig sind, wie wir sie brauchen. Schauen wir uns an, wie
Lebensdauern das tun.</p>
<h2><a class="header" href="#referenzen-validieren-mit-lebensdauern" id="referenzen-validieren-mit-lebensdauern">Referenzen validieren mit Lebensdauern</a></h2>
<p>Ein Detail, das wir im Abschnitt <a href="ch04-02-references-and-borrowing.html">„Referenzen und Ausleihen
(borrowing)“</a> in Kapitel 4 nicht erörtert haben, ist,
dass jede Referenz in Rust eine <em>Lebensdauer</em> (lifetime) hat, d.h. einen
Gültigkeitsbereich, in dem diese Referenz gültig ist. In den meisten Fällen
sind Lebensdauern implizit und abgeleitet, ebenso wie in den meisten Fällen
Typen abgeleitet werden. Wir müssen Typen mit Annotationen versehen, wenn
mehrere Typen möglich sind. In ähnlicher Weise müssen wir Lebensdauern
annotieren, wenn die Lebensdauern von Referenzen auf verschiedene Weise
miteinander in Beziehung gesetzt werden könnten. Rust verlangt von uns, die
Beziehungen mit generischen Lebensdauerparametern zu annotieren, um
sicherzustellen, dass die tatsächlich zur Laufzeit verwendeten Referenzen
definitiv gültig sind.</p>
<p>Das Konzept der Lebensdauer unterscheidet sich etwas von Werkzeugen in anderen
Programmiersprachen, was die Lebensdauer wohl zur charakteristischsten
Funktionalität von Rust macht. Auch wenn wir in diesem Kapitel die Lebensdauern
nicht in ihrer Gesamtheit behandeln werden, so werden wir doch allgemeine
Möglichkeiten erörtern, mit denen du dich mit der Syntax der Lebensdauer und
den Konzepten vertraut machen kannst.</p>
<h3><a class="header" href="#verhindern-hängender-referenzen-mit-lebensdauern" id="verhindern-hängender-referenzen-mit-lebensdauern">Verhindern hängender Referenzen mit Lebensdauern</a></h3>
<p>Das Hauptziel der Lebensdauer ist es, hängende Referenzen zu verhindern, die
dazu führen, dass ein Programm auf andere Daten referenziert als die, auf die
es referenzieren soll. Betrachte das Programm in Codeblock 10-17, das einen
äußeren und einen inneren Gültigkeitsbereich hat.</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn main() {
    {
        let r;

        {
            let x = 5;
            r = &amp;x;
        }

        println!(&quot;r: {}&quot;, r);
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-17: Ein Versuch, eine Referenz zu verwenden,
deren Wert außerhalb des Gültigkeitsbereichs liegt</span></p>
<blockquote>
<p>Hinweis: Die Beispiele in den Codeblöcken 10-17, 10-18 und 10-24 deklarieren
Variablen ohne Initialwert, sodass der Variablenname im äußeren
Gültigkeitsbereich existiert. Auf den ersten Blick mag dies im Widerspruch
dazu stehen, dass Rust keine Nullwerte hat. Wenn wir jedoch versuchen, eine
Variable zu verwenden, bevor wir ihr einen Wert geben, erhalten wir einen
Kompilierfehler, der zeigt, dass Rust tatsächlich keine Nullwerte zulässt.</p>
</blockquote>
<p>Der äußere Gültigkeitsbereich deklariert eine Variable <code>r</code> ohne Initialwert und
der innere Gültigkeitsbereich deklariert eine Variable <code>x</code> mit dem Initialwert
5. Im inneren Gültigkeitsbereich versuchen wir, den Wert von <code>r</code> als Referenz
auf <code>x</code> zu setzen. Dann endet der innere Gültigkeitsbereich und wir versuchen,
den Wert in <code>r</code> auszugeben. Dieser Code lässt sich nicht kompilieren, weil der
Wert, auf den sich <code>r</code> bezieht, den Gültigkeitsbereich verlassen hat, bevor wir
versuchen, ihn zu verwenden. Hier ist die Fehlermeldung:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `x` does not live long enough
  --&gt; src/main.rs:7:17
   |
7  |             r = &amp;x;
   |                 ^^ borrowed value does not live long enough
8  |         }
   |         - `x` dropped here while still borrowed
9  | 
10 |         println!(&quot;r: {}&quot;, r);
   |                           - borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Die Variable <code>x</code> lebt nicht „lange genug“. Der Grund dafür ist, dass <code>x</code> den
Gültigkeitsbereich verlässt, da der innere Gültigkeitsbereich bei Zeile 8
endet. Aber <code>r</code> ist im äußeren Gültigkeitsbereich immer noch gültig; da sein
Gültigkeitsbereich größer ist, sagen wir, dass es „länger lebt“. Wenn Rust
diesen Code funktionieren ließe, würde <code>r</code> auf Speicher verweisen, der
freigegeben wurde, als <code>x</code> den Gültigkeitsbereich verlassen hat, und alles, was
wir mit <code>r</code> tun würden, würde nicht korrekt funktionieren. Wie stellt Rust also
fest, dass dieser Code ungültig ist? Es verwendet einen Ausleihenprüfer (borrow
checker).</p>
<h3><a class="header" href="#der-ausleihenprüfer" id="der-ausleihenprüfer">Der Ausleihenprüfer</a></h3>
<p>Der Rust-Kompilierer verfügt über einen <em>Ausleihenprüfer</em> (borrow checker), der
Gültigkeitsbereiche vergleicht, um festzustellen, ob alle Ausleihen gültig
sind. Codeblock 10-18 zeigt den gleichen Code wie Codeblock 10-17, jedoch mit
Annotationen, die die Lebensdauer der Variablen angeben.</p>
<pre><pre class="playpen"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span>    {
        let r;                // ---------+-- 'a
                              //          |
        {                     //          |
            let x = 5;        // -+-- 'b  |
            r = &amp;x;           //  |       |
        }                     // -+       |
                              //          |
        println!(&quot;r: {}&quot;, r); //          |
    }                         // ---------+
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-18: Annotationen der Lebensdauern von <code>r</code>
und <code>x</code>, genannt <code>'a</code> bzw. <code>'b</code></span></p>
<p>Hier haben wir die Lebensdauer von <code>r</code> mit <code>'a</code> und die Lebensdauer von <code>x</code> mit
<code>'b</code> vermerkt. Wie du sehen kannst, ist der innere <code>'b</code>-Block viel kleiner als
der äußere <code>'a</code>-Lebensdauer-Block. Zur Kompilierzeit vergleicht Rust die Größe
der beiden Lebensdauern und stellt fest, dass <code>r</code> eine Lebensdauer von <code>'a</code>
hat, jedoch auf einen Speicherbereich mit Lebensdauern <code>'b</code> referenziert. Das
Programm wird abgelehnt, weil <code>'b</code> kürzer als <code>'a</code> ist: Der Referenzinhalt lebt
nicht so lange wie die Referenz selbst.</p>
<p>Mit Codeblock 10-19 wird der Code so korrigiert, dass er keine hängende
Referenz hat und fehlerfrei kompiliert werden kann.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    {
        let x = 5;            // ----------+-- 'b
                              //           |
        let r = &amp;x;           // --+-- 'a  |
                              //   |       |
        println!(&quot;r: {}&quot;, r); //   |       |
                              // --+       |
    }                         // ----------+
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-19: Eine gültige Referenz, da die Daten eine
längere Lebensdauer als die Referenz haben</span></p>
<p>Hier hat <code>x</code> die Lebensdauer <code>'b</code>, die in diesem Fall größer ist als <code>'a</code>. Das
bedeutet, dass <code>r</code> auf <code>x</code> referenzieren kann, weil Rust weiß, dass die
Referenz in <code>r</code> immer gültig sein wird, solange <code>x</code> gültig ist.</p>
<p>Da du nun weißt, wo die Lebensdauern von Referenzen sind und wie Rust die
Lebensdauer analysiert, um sicherzustellen, dass Referenzen immer gültig sind,
lass uns die generischen Lebensdauern von Parametern und Rückgabewerten im
Kontext von Funktionen untersuchen.</p>
<h3><a class="header" href="#generische-lebensdauern-in-funktionen" id="generische-lebensdauern-in-funktionen">Generische Lebensdauern in Funktionen</a></h3>
<p>Schreiben wir eine Funktion, die den längeren von zwei
Zeichenkettenanteilstypen zurückgibt. Diese Funktion nimmt zwei
Zeichenkettenanteilstypen entgegen und gibt einen
Zeichenkettenanteilstyp zurück. Nachdem wir die Funktion <code>longest</code>
implementiert haben, sollte der Code in Codeblock 10-20 <code>Die längere Zeichenkette ist abcd</code> ausgeben.</p>
<p><span class="filename">Datei: src/main.rs</span></p>
<pre><code class="language-rust ignore">fn main() {
    let string1 = String::from(&quot;abcd&quot;);
    let string2 = &quot;xyz&quot;;

    let result = longest(string1.as_str(), string2);
    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
}
</code></pre>
<p><span class="caption">Codeblock 10-20: Eine Funktion <code>main</code>, die die Funktion
<code>longest</code> aufruft, um die längere von zwei Zeichenkettenanteilstypen zu
bestimmen</span></p>
<p>Beachte, dass wir wollen, dass die Funktion Zeichenkettenanteilstypen nimmt,
die Referenzen sind, weil wir nicht wollen, dass die Funktion <code>longest</code> die
Eigentümerschaft ihrer Parameter übernimmt. Wir wollen der Funktion
ermöglichen, sowohl Zeichenkettenanteilstypen (der Typ der Variable <code>string1</code>)
als auch Zeichenkettenliterale (was die Variable <code>string2</code> enthält)
entgegenzunehmen.</p>
<p>Lies den Abschnitt <a href="ch04-03-slices.html#zeichenkettenanteilstypen-als-parameter">„Zeichenkettenanteilstypen als
Parameter“</a> in Kapitel 4, um mehr darüber zu
erfahren, warum die Parameter, die wir in Codeblock 10-20 verwenden, die von
uns gewünschten sind.</p>
<p>Wenn wir versuchen, die Funktion <code>longest</code>, wie in Codeblock 10-21 gezeigt, zu
implementieren, wird sie sich nicht kompilieren lassen.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-21: Eine Implementierung der Funktion
<code>longest</code>, die die längere von zwei Zeichenkettenanteilstypen zurückgibt, aber
noch nicht kompiliert</span></p>
<p>Stattdessen erhalten wir folgenden Fehler, der von Lebensdauern spricht:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0106]: missing lifetime specifier
 --&gt; src/main.rs:9:33
  |
9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
  |                                 ^ expected lifetime parameter
  |
  = help: this function's return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y`

error: aborting due to previous error

For more information about this error, try `rustc --explain E0106`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Aus dem Hilfetext geht hervor, dass der Rückgabetyp einen generischen
Lebensdauer-Parameter benötigt, da Rust nicht sagen kann, ob sich die
zurückgegebene Referenz auf <code>x</code> oder auf <code>y</code> bezieht. Eigentlich wissen wir es
auch nicht, weil der <code>if</code>-Zweig im Funktionsrumpf eine Referenz auf <code>x</code> und der
<code>else</code>-Zweig eine Referenz auf <code>y</code> zurückgibt!</p>
<p>Wenn wir diese Funktion definieren, kennen wir die konkreten Werte nicht, die
an diese Funktion übergeben werden, also wissen wir nicht, ob der <code>if</code>-Zweig
oder der <code>else</code>-Zweig ausgeführt wird. Wir kennen auch nicht die konkreten
Lebensdauern der Referenzen, die weitergegeben werden, sodass wir nicht wie in
den Codeblöcken 10-18 und 10-19 die Gültigkeitsbereiche betrachten können, um
festzustellen, ob die von uns zurückgegebene Referenz immer gültig sein wird.
Der Ausleihenprüfer kann dies auch nicht feststellen, weil er nicht weiß, wie
die Lebensdauer von <code>x</code> und <code>y</code> mit der Lebensdauer des Rückgabewertes
zusammenhängt. Um diesen Fehler zu beheben, geben wir generische
Lebensdauerparameter an, die die Beziehung zwischen den Referenzen definieren,
damit der Ausleihenprüfer seine Analyse durchführen kann.</p>
<h3><a class="header" href="#lebensdauer-annotationssyntax" id="lebensdauer-annotationssyntax">Lebensdauer-Annotationssyntax</a></h3>
<p>Lebensdauer-Annotationen ändern nichts daran, wie lange eine Referenz lebt.
Genauso wie Funktionen jeden Typ entgegennehmen können, wenn die Signatur einen
generischen Typparameter angibt, können Funktionen Referenzen mit beliebiger
Lebensdauer akzeptieren, indem sie einen generischen Lebensdauerparameter
angeben. Lebensdauer-Annotationen beschreiben die Beziehungen der Lebensdauern
mehrerer Referenzen zueinander, ohne die Lebensdauern zu beeinflussen.</p>
<p>Lebensdauer-Annotationen haben eine etwas ungewöhnliche Syntax: Die Namen der
Lebensdauer-Parameter müssen mit einem Apostroph (<code>'</code>) beginnen und sind
normalerweise kleingeschrieben und sehr kurz, wie generische Typen. Die meisten
Menschen verwenden den Namen <code>'a</code>. Wir platzieren
Lebensdauer-Parameter-Annotationen hinter dem <code>&amp;</code> einer Referenz, wobei wir ein
Leerzeichen verwenden, um die Annotation vom Typ der Referenz zu trennen.</p>
<p>Hier sind einige Beispiele: Eine Referenz auf einen <code>i32</code> ohne
Lebensdauer-Parameter, eine Referenz auf einen <code>i32</code>, die einen
Lebensdauer-Parameter namens <code>'a</code> hat, und eine veränderlicher Referenz auf
einen <code>i32</code>, die ebenfalls die Lebensdauer <code>'a</code> hat.</p>
<pre><code class="language-rust ignore">&amp;i32        // eine Referenz
&amp;'a i32     // eine Referenz mit expliziter Lebensdauer
&amp;'a mut i32 // eine veränderliche Referenz mit expliziter Lebensdauer
</code></pre>
<p>Eine Lebensdauer-Annotation an sich hat nicht viel Bedeutung, da die
Annotationen Rust mitteilen sollen, wie sich generische
Lebensdauer-Parameter mehrerer Referenzen zueinander verhalten. Nehmen wir zum
Beispiel an, wir haben eine Funktion mit dem Parameter <code>first</code>, die eine
Referenz auf einen <code>i32</code> mit Lebensdauer <code>'a</code> ist. Die Funktion hat noch einen
weiteren Parameter namens <code>second</code>, der eine weitere Referenz auf einen <code>i32</code>
ist, die ebenfalls die Lebensdauer <code>'a</code> hat. Die Lebensdauer-Annotationen
weisen darauf hin, dass die Referenzen <code>first</code> und <code>second</code> beide so lange
leben müssen wie diese generische Lebensdauer.</p>
<h3><a class="header" href="#lebensdauer-annotationen-in-funktionssignaturen" id="lebensdauer-annotationen-in-funktionssignaturen">Lebensdauer-Annotationen in Funktionssignaturen</a></h3>
<p>Lass uns nun Lebensdauer-Annotationen im Kontext der Funktion <code>longest</code>
untersuchen. Wie bei generischen Typparametern müssen wir generische
Lebensdauerparameter innerhalb spitzer Klammern zwischen dem Funktionsnamen und
der Parameterliste deklarieren. Die Beschränkung, die wir mit dieser Signatur
zum Ausdruck bringen wollen, besteht darin, dass alle Referenzen in den
Parametern und dem Rückgabewert die gleiche Lebensdauer haben müssen. Wir
nennen die Lebensdauer <code>'a</code> und fügen sie dann jeder Referenz hinzu, wie in
Codeblock 10-22 gezeigt.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-22: Die Funktionsdefinition <code>longest</code> gibt
an, dass alle Referenzen in der Signatur die gleiche Lebensdauer <code>'a</code> haben
müssen</span></p>
<p>Die Funktionssignatur sagt Rust, dass die Funktion für eine gewisse Lebensdauer
<code>'a</code> zwei Parameter benötigt, die beide den Zeichenkettenanteilstyp haben und
mindestens so lange leben wie die Lebensdauer <code>'a</code>. Die Funktionssignatur sagt
Rust auch, dass der von der Funktion zurückgegebene Zeichenkettenanteilstyp
mindestens so lange leben wird wie die Lebensdauer <code>'a</code>. In der Praxis bedeutet
dies, dass die Lebensdauer der von der Funktion <code>longest</code> zurückgegebenen
Referenz identisch mit der kürzeren der Lebensdauern der entgegengenommenen
Referenzen ist. Diese Bedingung wollen wir durch Rust sicherstellen lassen.
Denke daran, indem wir die Lebensdauerparameter in dieser Funktionssignatur
angeben, ändern wir nicht die Lebensdauer der übergebenen oder zurückgegebenen
Werte. Vielmehr legen wir fest, dass der Ausleihenprüfer alle Werte ablehnen
soll, die sich nicht an diese Bedingung halten. Beachte, dass die Funktion
<code>longest</code> nicht genau wissen muss, wie lange <code>x</code> und <code>y</code> leben werden, nur dass
ein gewisser Gültigkeitsbereich für <code>'a</code> eingesetzt werden kann, der dieser
Signatur genügt.</p>
<p>Wenn Funktionen mit Lebensdauern annotiert werden, gehören die Annotationen zur
Funktionssignatur, nicht zum Funktionsrumpf. Rust kann den Code innerhalb der
Funktion ohne jede Hilfe analysieren. Wenn eine Funktion jedoch Referenzen auf
oder von Code außerhalb dieser Funktion hat, wird es für Rust fast unmöglich,
die Lebensdauer der Parameter oder Rückgabewerte allein herauszufinden. Die
Lebensdauer kann bei jedem Aufruf der Funktion unterschiedlich sein. Aus diesem
Grund müssen wir die Lebensdauern manuell angeben.</p>
<p>Wenn wir der Funktion <code>longest</code> konkrete Referenzen übergeben, ist die konkrete
Lebensdauer, die an die Stelle von <code>'a</code> tritt, der Teil des Gültigkeitsbereichs
von <code>x</code>, der sich mit dem Gültigkeitsbereich von <code>y</code> überschneidet. Mit anderen
Worten bekommt die generische Lebensdauer <code>'a</code> die konkrete Lebensdauer, die
der kürzeren der Lebensdauern von <code>x</code> und <code>y</code> entspricht. Da wir die
zurückgegebene Referenz mit dem gleichen Lebensdauer-Parameter <code>'a</code> annotiert
haben, wird die zurückgegebene Referenz auch für die Dauer der kürzeren
Lebensdauer von <code>x</code> und <code>y</code> gültig sein.</p>
<p>Schauen wir uns an, wie die Lebensdauer-Annotationen die Funktion <code>longest</code>
beschränken, indem wir Referenzen mit unterschiedlichen konkreten Lebensdauern
übergeben. Codeblock 10-23 ist ein einfaches Beispiel.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let string1 = String::from(&quot;lange Zeichenkette ist lang&quot;);

    {
        let string2 = String::from(&quot;xyz&quot;);
        let result = longest(string1.as_str(), string2.as_str());
        println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
    }
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-23: Verwenden der Funktion <code>longest</code> mit
Referenzen auf Zeichenketten, die unterschiedliche konkrete Lebensdauern
haben</span></p>
<p>In diesem Beispiel ist <code>string1</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig, <code>string2</code> ist bis zum Ende des inneren Gültigkeitsbereichs gültig, und
<code>result</code> referenziert auf etwas, das bis zum Ende des inneren
Gültigkeitsbereichs gültig ist. Führe diesen Code aus und du wirst sehen, dass
der Ausleihenprüfer diesen Code akzeptiert; er kompiliert und gibt <code>Die längere Zeichenkette ist lange Zeichenkette ist lang</code>.</p>
<p>Versuchen wir als nächstes ein Beispiel, das zeigt, dass die Lebensdauer der
Referenz in <code>result</code> die kürzere Lebensdauer der beiden Argumente sein muss. 
Wir verschieben die Deklaration der Variable <code>result</code> oberhalb des inneren
Gültigkeitsbereichs, lassen aber die Zuweisung des Wertes an die Variable
<code>result</code> innerhalb des Gültigkeitsbereichs mit <code>string2</code>. Dann verschieben wir
<code>println!</code>, das <code>result</code> verwendet, unterhalb des inneren Gültigkeitsbereichs.
Der Code in Codeblock 10-24 lässt sich nicht kompilieren.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">fn main() {
    let string1 = String::from(&quot;lange Zeichenkette ist lang&quot;);
    let result;
    {
        let string2 = String::from(&quot;xyz&quot;);
        result = longest(string1.as_str(), string2.as_str());
    }
    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
}
<span class="boring">
</span><span class="boring">fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;'a str) -&gt; &amp;'a str {
</span><span class="boring">    if x.len() &gt; y.len() {
</span><span class="boring">        x
</span><span class="boring">    } else {
</span><span class="boring">        y
</span><span class="boring">    }
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-24: Der Versuch, <code>result</code> zu verwenden,
nachdem <code>string2</code> den Gültigkeitsbereich verlassen hat</span></p>
<p>Wenn wir versuchen, diesen Code zu kompilieren, erhalten wir folgenden Fehler:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0597]: `string2` does not live long enough
 --&gt; src/main.rs:6:44
  |
6 |         result = longest(string1.as_str(), string2.as_str());
  |                                            ^^^^^^^ borrowed value does not live long enough
7 |     }
  |     - `string2` dropped here while still borrowed
8 |     println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
  |                                                 ------ borrow later used here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0597`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Der Fehler zeigt, dass <code>string2</code> bis zum Ende des äußeren Gültigkeitsbereichs
gültig sein müsste, damit <code>result</code> in der Anweisung <code>println!</code> noch gültig ist. 
Rust weiß das, weil wir die Lebensdauer der Funktionsparameter und
Rückgabewerte mit dem gleichen Lebensdauerparameter <code>'a</code> annotiert haben.</p>
<p>Als Menschen können wir uns diesen Code ansehen und erkennen, dass <code>string1</code>
länger als <code>string2</code> ist und deshalb wird <code>result</code> eine Referenz auf <code>string1</code>
enthalten. Da <code>string1</code> den Gültigkeitsbereich noch nicht verlassen hat, wird
eine Referenz auf <code>string1</code> in der <code>println!</code>-Anweisung noch gültig sein. Der
Kompilierer kann jedoch nicht sehen, dass die Referenz in diesem Fall gültig
ist. Wir haben Rust gesagt, dass die Lebensdauer der Referenz, die von der
Funktion <code>longest</code> zurückgegeben wird, die gleiche ist wie die kürzere der
Lebensdauern der entgegengenommenen Referenzen. Daher lehnt der Ausleihenprüfer
den Code in Codeblock 10-24 als möglicherweise ungültige Referenz ab.</p>
<p>Versuche, dir weitere Experimente auszudenken, die die Werte und die
Lebensdauern der an die Funktion <code>longest</code> übergebenen Referenzen variieren und
wie die zurückgegebene Referenz verwendet wird. Stelle Hypothesen darüber auf,
ob deine Experimente den Ausleihenprüfer bestehen oder nicht, bevor du
kompilierst; prüfe dann, ob du Recht hast!</p>
<h3><a class="header" href="#denken-in-lebensdauern" id="denken-in-lebensdauern">Denken in Lebensdauern</a></h3>
<p>Die Art und Weise, in der du Lebensdauerparameter angeben musst, hängt davon
ab, was deine Funktion tut. Wenn wir zum Beispiel die Implementierung der
Funktion <code>longest</code> so ändern würden, dass sie immer den ersten Parameter
zurückgibt und nicht den längsten Zeichenkettenanteilstyp, bräuchten wir keine
Lebensdauer für den Parameter <code>y</code> anzugeben. Der folgende Code wird
kompilieren:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;efghijklmnopqrstuvwxyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;'a str, y: &amp;str) -&gt; &amp;'a str {
    x
}
</code></pre></pre>
<p>In diesem Beispiel haben wir einen Lebensdauer-Parameter <code>'a</code> für den Parameter
<code>x</code> und den Rückgabetyp angegeben, aber nicht für den Parameter <code>y</code>, weil die
Lebensdauer von <code>y</code> in keiner Beziehung zur Lebensdauer von <code>x</code> oder dem
Rückgabewert steht.</p>
<p>Wenn eine Funktion eine Referenz zurückgibt, muss der Lebensdauerparameter für
den Rückgabetyp mit dem Lebensdauerparameter für einen der Parameter
übereinstimmen. Wenn sich die zurückgegebene Referenz <em>nicht</em> auf einen der
Parameter bezieht, muss er sich auf einen innerhalb dieser Funktion erzeugten
Wert beziehen, was eine hängende Referenz wäre, da der Wert am Ende der
Funktion den Gültigkeitsbereich verlässt. Betrachte diesen Versuch einer
Implementierung der Funktion <code>longest</code>, die sich nicht kompilieren lässt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest(string1.as_str(), string2);
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>fn longest&lt;'a&gt;(x: &amp;str, y: &amp;str) -&gt; &amp;'a str {
    let result = String::from(&quot;wirklich lange Zeichenkette&quot;);
    result.as_str()
}
</code></pre></pre>
<p>Auch wenn wir hier einen Lebensdauer-Parameter <code>'a</code> für den Rückgabetyp
angegeben haben, wird diese Implementierung nicht kompilieren, weil die
Lebensdauer des Rückgabewerts überhaupt nicht mit der Lebensdauer der Parameter
zusammenhängt. Hier ist die Fehlermeldung, die wir erhalten:</p>
<pre><code class="language-console">$ cargo run
   Compiling chapter10 v0.1.0 (file:///projects/chapter10)
error[E0515]: cannot return value referencing local variable `result`
  --&gt; src/main.rs:11:5
   |
11 |     result.as_str()
   |     ------^^^^^^^^^
   |     |
   |     returns a value referencing data owned by the current function
   |     `result` is borrowed here

error: aborting due to previous error

For more information about this error, try `rustc --explain E0515`.
error: could not compile `chapter10`.

To learn more, run the command again with --verbose.
</code></pre>
<p>Das Problem ist, dass <code>result</code> den Gültigkeitsbereich verlässt und am Ende der
Funktion <code>longest</code> aufgeräumt wird. Wir versuchen auch, eine Referenz auf den
Wert in <code>result</code> zurückzugeben. Es gibt keine Möglichkeit, Lebensdauerparameter
so anzugeben, dass die hängende Referenz beseitigt wird, Rust lässt uns also
keine hängende Referenz erstellen. In diesem Fall wäre die beste Lösung, einen
eigenen Datentyp statt einer Referenz zurückzugeben, sodass die aufrufende
Funktion dann für das Aufräumen des Wertes verantwortlich ist.</p>
<p>Letztlich geht es bei der Lebensdauersyntax darum, die Lebensdauern
verschiedener Parameter und Rückgabewerte von Funktionen miteinander zu
verbinden. Sobald sie verbunden sind, verfügt Rust über genügend Informationen,
um speichersichere Operationen zu ermöglichen und Operationen zu unterbinden,
die hängende Zeiger erzeugen oder anderweitig die Speichersicherheit verletzen
würden.</p>
<h3><a class="header" href="#lebensdauer-annotationen-in-struktur-definitionen" id="lebensdauer-annotationen-in-struktur-definitionen">Lebensdauer-Annotationen in Struktur-Definitionen</a></h3>
<p>Bisher haben wir nur Strukturen (structs) definiert, die aneigenbare Typen
enthalten. Es ist möglich, dass Strukturen Referenzen enthalten, aber in diesem
Fall müssten wir Lebensdauer-Annotationen zu jeder Referenz in der
Strukturdefinition angeben. Codeblock 10-25 hat eine Struktur namens
<code>ImportantExcerpt</code>, die einen Zeichenkettenanteilstyp enthält.</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">struct ImportantExcerpt&lt;'a&gt; {
    part: &amp;'a str,
}

fn main() {
    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
</code></pre></pre>
<p><span class="caption">Codeblock 10-25: Eine Struktur, die eine Referenz
enthält, sodass ihre Definition eine Lebensdauer-Annotationen benötigt</span></p>
<p>Diese Struktur hat ein Feld <code>part</code>, das einen Zeichenkettenanteilstyp enthält,
der eine Referenz ist. Wie bei generischen Datentypen deklarieren wir den Namen
des generischen Lebensdauerparameters innerhalb spitzer Klammern hinter dem
Strukturnamen, damit wir den Lebensdauerparameter im Rumpf der
Strukturdefinition verwenden können. Diese Annotation bedeutet, dass eine
Instanz von <code>ImportantExcerpt</code> die Referenz, die sie in ihrem Feld <code>part</code>
enthält, nicht überleben kann.</p>
<p>Die Funktion <code>main</code> erzeugt hier eine Instanz der Struktur <code>ImportantExcerpt</code>,
die eine Referenz auf den ersten Satz des <code>String</code> enthält, der der Variablen
<code>novel</code> gehört. Die Daten in <code>novel</code> existieren, bevor die Instanz
<code>ImportantExcerpt</code> erzeugt wird. Darüber hinaus verlässt <code>novel</code> den
Gültigkeitsbereich erst, nachdem <code>ImportantExcerpt</code> den Gültigkeitsbereich
verlassen hat, sodass die Referenz in der <code>ImportantExcerpt</code>-Instanz gültig
ist.</p>
<h3><a class="header" href="#lebensdauer-elision" id="lebensdauer-elision">Lebensdauer-Elision</a></h3>
<p>Du hast gelernt, dass jede Referenz eine Lebensdauer hat und dass du
Lebensdauerparameter für Funktionen oder Strukturen angeben musst, die
Referenzen verwenden. In Kapitel 4 hatten wir jedoch eine Funktion in Codeblock
4-9, die wiederum in Codeblock 10-26 gezeigt wird, die ohne
Lebensdauer-Annotationen kompiliert.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn first_word(s: &amp;str) -&gt; &amp;str {
    let bytes = s.as_bytes();

    for (i, &amp;item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &amp;s[0..i];
        }
    }

    &amp;s[..]
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let my_string = String::from(&quot;Hallo Welt&quot;);
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von `String`
</span><span class="boring">    let word = first_word(&amp;my_string[..]);
</span><span class="boring">
</span><span class="boring">    let my_string_literal = &quot;Hallo Welt&quot;;
</span><span class="boring">
</span><span class="boring">    // first_word funktioniert mit Anteilstypen von Zeichenkettenliteralen
</span><span class="boring">    let word = first_word(&amp;my_string_literal[..]);
</span><span class="boring">
</span><span class="boring">    // Da Zeichenkettenliterale bereits Zeichenkettenanteilstypen sind,
</span><span class="boring">    // funktioniert dies auch ohne die Anteilstypensyntax!
</span><span class="boring">    let word = first_word(my_string_literal);
</span><span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 10-26: Eine Funktion, die wir in Codeblock 4-9
definiert haben und die ohne Lebensdauer-Annotationen kompiliert, obwohl
Parameter und Rückgabetyp Referenzen sind</span></p>
<p>Der Grund, warum diese Funktion ohne Lebensdauer-Annotationen kompiliert, ist
historisch bedingt: In frühen Versionen (vor 1.0) von Rust hätte sich dieser
Code nicht kompilieren lassen, da jede Referenz eine explizite Lebensdauer
benötigte. Damals wäre die Funktionssignatur so geschrieben worden:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Nachdem jede Menge Rust-Code geschrieben wurde, stellte das Rust-Team fest,
dass die Rust-Programmierer in bestimmten Situationen immer wieder die gleichen
Lebensdauer-Annotationen angaben. Diese Situationen waren vorhersehbar und
folgten einigen wenigen deterministischen Mustern. Die Entwickler
programmierten diese Muster in den Code des Kompilierers, sodass der
Ausleihenprüfer in diesen Situationen auf die Lebensdauer schließen konnte und
keine expliziten Annotationen benötigte.</p>
<p>Dieses Stück Rust-Geschichte ist relevant, weil es möglich ist, dass weitere
deterministische Muster auftauchen und dem Kompilierer hinzugefügt werden. In
Zukunft könnten noch weniger Lebensdauer-Annotationen erforderlich sein.</p>
<p>Die Muster, die in Rusts Referenzanalyse programmiert sind, werden die
<em>Lebensdauer-Elisionsregeln</em> (lifetime elision rules) genannt. Dies sind keine
Regeln, die Programmierer befolgen müssen; es handelt sich um eine Reihe
besonderer Fälle, die der Kompilierer berücksichtigt, und wenn dein Code zu
einem dieser Fälle passt, brauchst du die Lebensdauer nicht explizit anzugeben.</p>
<p>Die Elisionsregeln bieten keine vollständige Schlussfolgerung. Wenn Rust die
Regeln deterministisch anwendet, aber immer noch Unklarheit darüber besteht,
welche Lebensdauer die Referenzen haben, wird der Kompilierer nicht erraten,
wie lang die Lebensdauer der verbleibenden Referenzen sein sollte. In diesem
Fall gibt dir der Kompilierer statt einer Vermutung einen Fehler an, den du
beheben kannst, indem du die Lebensdauer-Annotationen angibst, die festlegen,
wie sich die Referenzen zueinander verhalten.</p>
<p>Die Lebensdauern der Funktions- oder Methodenparameter werden als
<em>Eingangslebensdauern</em> (input lifetimes) bezeichnet, und die Lebensdauern der
Rückgabewerte als <em>Ausgangslebensdauern</em> (output lifetimes) bezeichnet.</p>
<p>Der Kompilierer verwendet drei Regeln, um herauszufinden, welche Lebensdauer
Referenzen haben, wenn keine expliziten Annotationen vorhanden sind. Die erste
Regel gilt für Eingangslebensdauern und die zweite und dritte Regel gelten für
Ausgangslebensdauern. Wenn der Kompilierer das Ende der drei Regeln erreicht
und es immer noch Referenzen gibt, für die er keine Lebensdauern ermitteln
kann, bricht der Kompilierer mit einem Fehler ab. Diese Regeln gelten sowohl
für <code>fn</code>-Definitionen als auch für <code>impl</code>-Blöcke.</p>
<p>Die erste Regel ist, dass jeder Parameter, der eine Referenz ist, seinen
eigenen Lebensdauerparameter erhält. Mit anderen Worten, eine Funktion mit
einem Parameter erhält einen Lebensdauerparameter: <code>fn foo&lt;'a&gt;(x: &amp;'a i32)</code>;
eine Funktion mit zwei Parametern erhält zwei separate Lebensdauerparameter:
<code>fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)</code>; und so weiter.</p>
<p>Die zweite Regel lautet: Wenn es genau einen Eingangslebensdauer-Parameter
gibt, wird diese Lebensdauer allen Ausgangslebensdauer-Parametern zugewiesen:
<code>fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32</code>.</p>
<p>Die dritte Regel lautet: Wenn es mehrere Eingangslebensdauer-Parameter gibt,
aber einer davon <code>&amp;self</code> oder <code>&amp;mut self</code> ist, weil dies eine Methode ist, wird
die Lebensdauer von <code>self</code> allen Ausgangslebensdauer-Parametern zugewiesen.
Diese dritte Regel macht Methoden viel angenehmer zu lesen und zu schreiben,
weil weniger Symbole erforderlich sind.</p>
<p>Tun wir so, als wären wir der Kompilierer. Wir werden diese Regeln anwenden, um
herauszufinden, wie lang die Lebensdauer der Referenzen in der Signatur der
Funktion <code>first_word</code> in Codeblock 10-26 ist. Die Signatur beginnt ohne
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn first_word(s: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Dann wendet der Kompilierer die erste Regel an, die festlegt, dass jeder
Parameter seine eigene Lebensdauer erhält. Wir nennen sie wie üblich <code>'a</code>, also
sieht die Signatur jetzt so aus:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;str {
</code></pre>
<p>Die zweite Regel trifft zu, weil es genau eine Eingangslebensdauer gibt. Die
zweite Regel legt fest, dass die Lebensdauer des einen Eingabeparameters der
Ausgangslebensdauer zugeordnet wird, sodass die Signatur nun wie folgt
aussieht:</p>
<pre><code class="language-rust ignore">fn first_word&lt;'a&gt;(s: &amp;'a str) -&gt; &amp;'a str {
</code></pre>
<p>Jetzt haben alle Referenzen in dieser Funktionssignatur eine Lebensdauer und
der Kompilierer kann seine Analyse fortsetzen, ohne dass der Programmierer die
Lebensdauer in dieser Funktionssignatur annotieren muss.</p>
<p>Schauen wir uns ein anderes Beispiel an, diesmal mit der Funktion <code>longest</code>,
die keine Lebensdauerparameter hatte, als wir in Codeblock 10-21 mit ihr zu
arbeiten begannen:</p>
<pre><code class="language-rust ignore">fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str {
</code></pre>
<p>Wenden wir die erste Regel an: Jeder Parameter erhält seine eigene Lebensdauer.
Diesmal haben wir zwei Parameter anstelle von einem, also haben wir zwei
Lebensdauern:</p>
<pre><code class="language-rust ignore">fn longest&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; &amp;str {
</code></pre>
<p>Du siehst, dass die zweite Regel nicht gilt, weil es mehr als eine
Eingangslebensdauer gibt. Auch die dritte Regel trifft nicht zu, weil <code>longest</code>
eine Funktion ist, keine Methode, sodass keiner der Parameter <code>self</code> ist.
Nachdem wir alle drei Regeln durchgearbeitet haben, haben wir immer noch nicht
herausgefunden, wie lang die Lebensdauer des Rückgabetyps ist. Aus diesem Grund
haben wir beim Versuch, den Code in Codeblock 10-21 zu kompilieren, einen
Fehler erhalten: Der Kompilierer arbeitete die Lebensdauer-Elisionsregeln
durch, konnte aber immer noch nicht alle Lebensdauern der Referenzen in der
Signatur ermitteln.</p>
<p>Da die dritte Regel eigentlich nur für Methodensignaturen gilt, werden wir uns
als nächstes die Lebensdauern in diesem Zusammenhang ansehen, um zu sehen,
warum die dritte Regel bedeutet, dass wir die Lebensdauer in Methodensignaturen
nicht sehr oft annotieren müssen.</p>
<h3><a class="header" href="#lebensdauer-annotationen-in-methodendefinitionen" id="lebensdauer-annotationen-in-methodendefinitionen">Lebensdauer-Annotationen in Methodendefinitionen</a></h3>
<p>Wenn wir Methoden auf einer Struktur mit Lebensdauer implementieren, verwenden
wir die gleiche Syntax wie die in Codeblock 10-11 gezeigten generischen
Typparameter. Wo wir die Lebensdauerparameter deklarieren und verwenden, hängt
davon ab, ob sie sich auf die Strukturfelder oder auf die Methodenparameter und
Rückgabewerte beziehen.</p>
<p>Lebensdauer-Namen für Struktur-Felder müssen immer nach dem
<code>impl</code>-Schlüsselwort deklariert und dann hinter dem Namen der Struktur verwendet
werden, da diese Lebensdauern Teil des Typs der Struktur sind.</p>
<p>In Methodensignaturen innerhalb des <code>impl</code>-Blocks können Referenzen an die
Lebensdauern der Referenzen in den Feldern der Struktur gebunden sein oder sie
können unabhängig sein. Darüber hinaus sorgen die Lebensdauer-Elisionsregeln
oft dafür, dass Lebensdauer-Annotationen in Methodensignaturen nicht
erforderlich sind. Betrachten wir einige Beispiele mit der Struktur
<code>ImportantExcerpt</code> an, die wir in Codeblock 10-25 definiert haben.</p>
<p>Zuerst werden wir eine Methode namens <code>level</code> verwenden, deren einziger
Parameter eine Referenz auf <code>self</code> ist und deren Rückgabewert ein <code>i32</code> ist,
was keine Referenz ist:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn level(&amp;self) -&gt; i32 {
        3
    }
}
<span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
</span><span class="boring">        println!(&quot;Bitte um Aufmerksamkeit: {}&quot;, announcement);
</span><span class="boring">        self.part
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>Die Lebensdauer-Parameter-Deklaration nach <code>impl</code> und ihre Verwendung hinter dem
Typnamen sind erforderlich, aber wir sind nicht verpflichtet, die Lebensdauer der
Referenz auf <code>self</code> wegen der ersten Elisionsregel zu annotieren.</p>
<p>Hier ist ein Beispiel, bei dem die dritte Lebensdauer-Elisionsregel gilt:</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">struct ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    part: &amp;'a str,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
</span><span class="boring">    fn level(&amp;self) -&gt; i32 {
</span><span class="boring">        3
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
    fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
        println!(&quot;Bitte um Aufmerksamkeit: {}&quot;, announcement);
        self.part
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let novel = String::from(&quot;Nennen Sie mich Ishmael. Vor einigen Jahren ...&quot;);
</span><span class="boring">    let first_sentence = novel.split('.').next().expect(&quot;Konnte keinen '.' finden.&quot;);
</span><span class="boring">    let i = ImportantExcerpt {
</span><span class="boring">        part: first_sentence,
</span><span class="boring">    };
</span><span class="boring">}
</span></code></pre></pre>
<p>Es gibt zwei Eingangslebensdauern, sodass Rust die erste
Lebensdauer-Elisionsregel anwendet und sowohl <code>&amp;self</code> als auch <code>announcement</code>
ihre eigene Lebensdauer gibt. Da einer der Parameter <code>&amp;self</code> ist, erhält der
Rückgabetyp die Lebensdauer von <code>&amp;self</code>, und alle Lebensdauern sind
berücksichtigt worden.</p>
<h3><a class="header" href="#statische-lebensdauer" id="statische-lebensdauer">Statische Lebensdauer</a></h3>
<p>Eine besondere Lebensdauer, die wir besprechen müssen, ist <code>'static</code>, was
bedeutet, dass diese Referenz während der gesamten Dauer des Programms leben
kann. Alle Zeichenkettenliterale haben die Lebensdauer <code>'static</code>, die wir wie
folgt annotieren können:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>let s: &amp;'static str = &quot;Ich habe eine statische Lebensdauer.&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>Der Text dieser Zeichenkette wird direkt in der Binärdatei des Programms
gespeichert, die immer verfügbar ist. Daher ist die Lebensdauer aller
Zeichenkettenliterale <code>'static</code>.</p>
<p>Möglicherweise siehst du Hinweise zur Verwendung der Lebensdauer <code>'static</code> in
Fehlermeldungen. Aber bevor du <code>'static</code> als Lebensdauer für eine Referenz
angibst, denke darüber nach, ob deine Referenz tatsächlich während der gesamten
Lebensdauer deines Programms lebt oder nicht. Du könntest überlegen, ob du
willst, dass sie so lange lebt, selbst wenn sie das könnte. Meistens ergibt
sich das Problem aus dem Versuch, eine hängende Referenz zu erstellen oder eine
Unvereinbarkeit zwischen den verfügbaren Lebensdauern zu beheben. In solchen
Fällen besteht die Lösung darin, diese Probleme zu beheben und nicht darin, die
Lebensdauer als <code>'static</code> festzulegen.</p>
<h2><a class="header" href="#generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen" id="generische-typparameter-merkmalsabgrenzungen-und-lebensdauern-zusammen">Generische Typparameter, Merkmalsabgrenzungen und Lebensdauern zusammen</a></h2>
<p>Schauen wir uns kurz die Syntax zu Angabe generischer Typparameter,
Merkmalsabgrenzungen und Lebensdauern in einer Funktion an!</p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let string1 = String::from(&quot;abcd&quot;);
</span><span class="boring">    let string2 = &quot;xyz&quot;;
</span><span class="boring">
</span><span class="boring">    let result = longest_with_an_announcement(
</span><span class="boring">        string1.as_str(),
</span><span class="boring">        string2,
</span><span class="boring">        &quot;Heute hat jemand Geburtstag!&quot;,
</span><span class="boring">    );
</span><span class="boring">    println!(&quot;Die längere Zeichenkette ist {}&quot;, result);
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt::Display;

fn longest_with_an_announcement&lt;'a, T&gt;(
    x: &amp;'a str,
    y: &amp;'a str,
    ann: T,
) -&gt; &amp;'a str
where
    T: Display,
{
    println!(&quot;Bekanntmachung! {}&quot;, ann);
    if x.len() &gt; y.len() {
        x
    } else {
        y
    }
}
</code></pre></pre>
<p>Dies ist die Funktion <code>longest</code> aus Codeblock 10-22, die die längere von zwei
Zeichenkettenanteilstypen zurückgibt. Aber jetzt hat sie einen zusätzlichen
Parameter namens <code>ann</code> vom generischen Typ <code>T</code>, der jeder beliebige Typ sein
kann, der das Merkmal <code>Display</code> implementiert, wie in der <code>where</code>-Klausel
spezifiziert ist. Dieser zusätzliche Parameter wird ausgegeben, bevor die
Funktion die Längen der Zeichenkettenanteilstypen vergleicht, weshalb die
Merkmalsabgrenzung <code>Display</code> notwendig ist. Da die Lebensdauer ein generischer
Typ ist, stehen die Deklarationen des Lebensdauer-Parameters <code>'a</code> und des
generischen Typ-Parameters <code>T</code> in der gleichen Liste innerhalb spitzer Klammern
hinter dem Funktionsnamen.</p>
<h2><a class="header" href="#zusammenfassung-6" id="zusammenfassung-6">Zusammenfassung</a></h2>
<p>Wir haben in diesem Kapitel viel behandelt! Jetzt, da du über generische
Typparameter, Merkmale und Merkmalsabgrenzungen sowie generische
Lebensdauerparameter Bescheid weißt, bist du bereit, Code ohne Wiederholungen
zu schreiben, der in vielen verschiedenen Situationen funktioniert. Merkmale
und Merkmalsabgrenzungen stellen sicher, dass die Typen, auch wenn sie
generisch sind, das Verhalten haben, das der Code benötigt. Du hast gelernt,
wie man Lebensdauer-Annotationen verwendet, um sicherzustellen, dass dieser
flexible Code keine hängenden Referenzen hat. Und all diese Analysen finden zur
Kompilierzeit statt, was die Laufzeitperformanz nicht beeinträchtigt!</p>
<p>Ob du es glaubst oder nicht, es gibt zu den Themen, die wir in diesem Kapitel
besprochen haben, noch viel mehr zu sagen: In Kapitel 17 werden Merkmalsobjekte
erörtert, die eine weitere Möglichkeit zur Verwendung von Merkmalen darstellen.
Kapitel 19 behandelt komplexere Szenarien mit Lebensdauer-Annotationen sowie
einige fortgeschrittene Typsystem-Funktionalitäten. Aber als Nächstes wirst du
lernen, wie man Tests in Rust schreibt, damit du sicherstellen kannst, dass
dein Code so funktioniert, wie er sollte.</p>
<h1><a class="header" href="#automatisierte-tests-schreiben" id="automatisierte-tests-schreiben">Automatisierte Tests schreiben</a></h1>
<p>In seinem Essay „Der bescheidene Programmierer“ von 1972 sagte Edsger W.
Dijkstra, dass „Programmtests eine sehr effektive Methode sein können, das
Vorhandensein von Fehlern zu zeigen, aber sie sind hoffnungslos unzureichend,
um deren Abwesenheit zu zeigen“. Das bedeutet nicht, dass wir nicht versuchen
sollten, so viel wie möglich zu testen!</p>
<p>Korrektheit unserer Programme ist das Maß, inwieweit unser Code das tut, was
wir beabsichtigen. Bei der Entwicklung von Rust wird der Korrektheit von
Programmen große Bedeutung beigemessen, aber Korrektheit ist komplex und nicht
leicht zu beweisen. Das Typsystem von Rust trägt einen großen Teil dieser Last,
aber das Typsystem kann nicht jede Art von Unrichtigkeit erkennen. Rust
beinhaltet Unterstützung für das Schreiben automatisierter Softwaretests
innerhalb der Sprache.</p>
<p>Nehmen wir beispielsweise an, wir schreiben eine Funktion namens <code>add_two</code>, die
2 zu jeder Zahl addiert, die ihr übergeben wird. Die Signatur dieser Funktion
akzeptiert eine ganze Zahl als Parameter und gibt als Ergebnis eine ganze Zahl
zurück. Wenn wir diese Funktion implementieren und kompilieren, führt Rust die
gesamte Typ- und Ausleihenprüfung durch, die du bisher kennengelernt hast, um
sicherzustellen, dass wir z.B. keinen <code>String</code>-Wert oder eine ungültige
Referenz an diese Funktion übergeben. Aber Rust kann <em>nicht</em> überprüfen, ob
diese Funktion genau das tut, was wir beabsichtigen, nämlich den Parameter plus
2 zurückzugeben und nicht etwa den Parameter plus 10 oder den Parameter minus
50! Hier kommen Tests ins Spiel.</p>
<p>Wir können Tests schreiben, die zum Beispiel sicherstellen, dass der
Rückgabewert <code>5</code> ist, wenn wir <code>3</code> an die Funktion <code>add_two</code> übergeben. Wir
können diese Tests immer dann durchführen, wenn wir Änderungen an unserem Code
vornehmen, um sicherzustellen, dass sich ein bestehendes korrektes Verhalten
nicht geändert hat.</p>
<p>Testen ist eine komplexe Fähigkeit: Obwohl wir nicht jedes Detail darüber, wie
man gute Tests schreibt, in einem Kapitel behandeln können, werden wir die
Mechanismen der Rust-Testmöglichkeiten besprechen. Wir werden über Annotationen
und Makros sprechen, die dir beim Schreiben deiner Tests zur Verfügung stehen,
über das Standardverhalten und die Optionen, die es bei der Ausführung deiner
Tests gibt, und darüber, wie du Tests in Modultests (unit tests) und
Integrationstests organisieren kannst.</p>
<h2><a class="header" href="#tests-schreiben" id="tests-schreiben">Tests schreiben</a></h2>
<p>Tests sind Funktionen in Rust, die überprüfen, ob der zu testende Code in der
erwarteten Weise funktioniert. Der Rumpf von Testfunktionen führt in der Regel
diese drei Aktionen aus:</p>
<ol>
<li>Bereite die benötigten Daten und Zustände vor.</li>
<li>Führe den Code aus, den du testen möchtest.</li>
<li>Stelle sicher, dass die Ergebnisse das sind, was du erwartest.</li>
</ol>
<p>Schauen wir uns die Funktionalität an, die Rust speziell für das Schreiben von
Tests bereitstellt, die diese Aktionen ausführen. Dazu gehören das Attribut
<code>test</code>, einige Makros und das Attribut <code>hould_panic</code>.</p>
<h3><a class="header" href="#anatomie-einer-testfunktion" id="anatomie-einer-testfunktion">Anatomie einer Testfunktion</a></h3>
<p>Im einfachsten Fall ist ein Test in Rust eine Funktion, die mit dem Attribut
<code>test</code> annotiert wird. Attribute sind Metadaten über Teile des Rust-Codes; ein
Beispiel ist das Attribut <code>derive</code>, das wir in Kapitel 5 bei Strukturen
verwendet haben. Um eine Funktion in eine Testfunktion zu verwandeln, füge
<code>#[test]</code> oberhalb der Zeile mit <code>fn</code> ein. Wenn du deine Tests mit dem Befehl
<code>cargo test</code> ausführst, erstellt Rust eine Testausführungs-Binärdatei (test
runner binary), die die mit dem Attribut <code>test</code> annotierten Funktionen ausführt
und darüber berichtet, ob jede Testfunktion erfolgreich war oder nicht.</p>
<p>Wenn wir ein neues Bibliotheksprojekt mit Cargo durchführen, wird für uns
automatisch ein Testmodul mit einer Testfunktion darin generiert. Dieses Modul
hilft dir, mit dem Schreiben deiner Tests zu beginnen, sodass du nicht jedes
Mal, wenn du ein neues Projekt startest, die genaue Struktur und Syntax der
Testfunktionen nachschlagen musst. Du kannst so viele zusätzliche
Testfunktionen und Testmodule hinzufügen, wie du möchtest!</p>
<p>Wir werden einige Aspekte der Funktionsweise von Tests untersuchen, indem wir
mit der für uns generierten Testvorlage experimentieren, ohne tatsächlich Code
zu testen. Dann schreiben wir einige Tests aus der realen Welt, die einen von
uns geschriebenen Code aufrufen und sicherstellen, dass sein Verhalten korrekt
ist.</p>
<p>Lass uns ein neues Bibliotheksprojekt namens <code>adder</code> erstellen:</p>
<pre><code class="language-console">$ cargo new adder --lib
     Created library `adder` project
$ cd adder
</code></pre>
<p>Der Inhalt der Datei <em>src/lib.rs</em> in deiner Bibliothek <code>adder</code> sollte wie
Codeblock 11-1 aussehen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-1: Das Testmodul und die Funktion, die
automatisch von <code>cargo new</code> generiert werden</span></p>
<p>Ignorieren wir vorerst die beiden oberen Zeilen und konzentrieren uns auf die
Funktion, um zu sehen, wie sie funktioniert. Beachte die Annotation <code>#[test]</code>
oberhalb der Zeile mit <code>fn</code>: Dieses Attribut zeigt an, dass es sich um eine
Testfunktion handelt, sodass die Testausführung weiß, dass es diese Funktion
als einen Test behandeln soll. Wir könnten auch Nicht-Test-Funktionen im Modul
<code>tests</code> haben, um gängige Szenarien aufzusetzen oder gängige Operationen
durchzuführen, daher müssen wir mit dem Attribut <code>#[test]</code> angeben, welche
Funktionen Tests sind.</p>
<p>Der Funktionsrumpf verwendet das Makro <code>assert_eq!</code>, um sicherzustellen, dass 2
+ 2 gleich 4 ist. Diese Prüfung dient als Beispiel für den Aufbau eines
typischen Tests. Lassen wir ihn laufen, um zu sehen, dass dieser Test
erfolgreich ist.</p>
<p>Das Kommando <code>cargo test</code> führt alle Tests in unserem Projekt aus, wie in
Codeblock 11-2 zu sehen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.57s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_works ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p><span class="caption">Codeblock 11-2: Ergebnis der Ausführung des automatisch
generierten Tests</span></p>
<p>Cargo hat den Test kompiliert und ausgeführt. Nach den Zeilen <code>Compiling</code>,
<code>Finished</code> und <code>Running</code> folgt die Zeile <code>running 1 test</code>. Die nächste Zeile
zeigt den Namen der generierten Testfunktion <code>it_works</code> und das Ergebnis der
Testausführung: <code>ok</code>. Als nächstes wird die Gesamtzusammenfassung der
Testausführung angegeben. Der Text <code>test result: ok.</code> bedeutet, dass alle Tests
bestanden wurden, und der Teil <code>1 passed; 0 failed</code> gibt die Anzahl der Tests
an, die bestanden oder nicht bestanden wurden.</p>
<p>Da wir keine Tests haben, die wir als ignoriert markiert haben, zeigt die
Zusammenfassung <code>0 ignored</code>. Wir haben zudem die auszuführenden Tests nicht
gefiltert, sodass am Ende der Zusammenfassung <code>0 filtered out</code> steht. Wir
werden das Ignorieren und Herausfiltern von Tests im nächsten Abschnitt,
<a href="ch11-02-running-tests.html">„Steuern wie Tests ausgeführt werden“</a>,
besprechen.</p>
<p>Die Statistik <code>0 measured</code> ist für Benchmark-Tests, die die Performanz messen.
Benchmark-Tests sind zum Zeitpunkt, als dieser Text verfasst wurde, nur im
nächtlichen (nightly) Rust verfügbar. Siehe <a href="https://doc.rust-lang.org/unstable-book/library-features/test.html">„Dokumentation über
Benchmark-Tests“</a>, um mehr zu erfahren.</p>
<p>Der nächste Teil der Testausgabe, der mit <code>Doc-tests adder</code> beginnt, ist für
die Ergebnisse von Dokumentationstests. Wir haben noch keine
Dokumentationstests, aber Rust kann alle Code-Beispiele kompilieren, die in
unserer API-Dokumentation erscheinen. Diese Funktionalität hilft uns dabei,
unsere Dokumentation und unseren Code synchron zu halten! Wie man
Dokumentationstests schreibt, werden wir im Abschnitt
<a href="ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests">„Dokumentationskommentare als Tests“</a> in Kapitel 14 besprechen.
Vorerst ignorieren wir die Ausgabe von <code>Doc-tests</code>.</p>
<p>Lass uns den Namen unseres Tests ändern, um zu sehen, wie sich dadurch die
Testausgabe ändert. Ändere die Funktion <code>it_works</code> auf einen anderen Namen,
z.B. <code>exploration</code>, etwa so:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Dann führe <code>cargo test</code> erneut aus. Die Ausgabe zeigt nun <code>exploration</code>
anstelle von <code>it_works</code>:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.59s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::exploration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Fügen wir einen weiteren Test hinzu, aber dieses Mal machen wir einen Test, der
fehlschlägt! Tests schlagen fehl, wenn etwas die Testfunktion zum Abbrechen
bringt. Jeder Test wird in einem neuen Strang (thread) ausgeführt und wenn der
Hauptstrang (main thread) sieht, dass ein Teststrang (test thread) gestorben
ist, wird der Test als fehlgeschlagen markiert. Über den einfachsten Weg, ein
Programm abzubrechen, sprachen wir in Kapitel 9, und zwar durch den Aufruf des
Makros <code>panic!</code>. Erstelle einen neuen Test <code>another</code>, sodass deine Datei
<em>src/lib.rs</em> wie in Codeblock 11-3 aussieht.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust panics">#[cfg(test)]
mod tests {
    #[test]
    fn exploration() {
        assert_eq!(2 + 2, 4);
    }

    #[test]
    fn another() {
        panic!(&quot;Lasse diesen Test fehlschlagen&quot;);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-3: Hinzufügen eines zweiten Tests, der
fehlschlägt, weil wir das Makro <code>panic!</code> aufrufen</span></p>
<p>Führe die Tests erneut mit <code>cargo test</code> aus. Die Ausgabe sollte wie in
Codeblock 11-4 aussehen, was zeigt, dass unser Test <code>exploration</code> bestanden und
<code>another</code> fehlgeschlagen ist.</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.72s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::another ... FAILED
test tests::exploration ... ok

failures:

---- tests::another stdout ----
thread 'main' panicked at 'Lasse diesen Test fehlschlagen', src/lib.rs:10:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::another

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p><span class="caption">Codeblock 11-4: Testergebnisse, wenn ein Test bestanden
und ein Test nicht bestanden wird</span></p>
<p>Statt <code>ok</code> zeigt die Zeile <code>test tests::another</code> das Ergebnis <code>FAILED</code>.
Zwischen den Einzelergebnissen und der Zusammenfassung erscheinen zwei neue
Abschnitte: Der erste Abschnitt zeigt die detaillierte Ursache für jeden
fehlgeschlagenen Test an. In diesem Fall scheiterte <code>another</code> mit der Meldung
<code>panicked at 'Lasse diesen Test fehlschlagen'</code> in Zeile 10 der Datei
<em>src/lib.rs</em>. Der nächste Abschnitt listet nur die Namen aller fehlgeschlagenen
Tests auf, was nützlich ist, wenn es viele Tests und viele detaillierte
Ausgaben von fehlgeschlagenen Tests gibt. Wir können den Namen eines
fehlgeschlagenen Tests verwenden, um genau diesen Test auszuführen, um ihn
leichter zu debuggen; wir werden im Abschnitt <a href="ch11-02-running-tests.html">„Steuern wie Tests ausgeführt
werden“</a> mehr über Möglichkeiten zur Ausführung
von Tests sprechen.</p>
<p>Die Zusammenfassungszeile zeigt am Ende an: Insgesamt ist unser Testergebnis
<code>FAILED</code>. Wir hatten einen Test bestanden und einen Test nicht bestanden.</p>
<p>Da du nun gesehen hast, wie die Testergebnisse in verschiedenen Szenarien
aussehen, wollen wir uns einige Makros neben <code>panic!</code> ansehen, die bei Tests
nützlich sind.</p>
<h3><a class="header" href="#ergebnisse-überprüfen-mit-dem-makro-assert" id="ergebnisse-überprüfen-mit-dem-makro-assert">Ergebnisse überprüfen mit dem Makro <code>assert!</code></a></h3>
<p>Das Makro <code>assert!</code>, das von der Standardbibliothek bereitgestellt wird, ist
nützlich, wenn du sicherstellen willst, dass eine Bedingung in einem Test als
wahr (true) bewertet wird. Wir geben dem Makro <code>assert!</code> ein Argument, das
boolesch ausgewertet wird. Wenn der Wert <code>true</code> ist, tut <code>assert!</code> nichts und
der Test ist bestanden. Wenn der Wert <code>false</code> ist, ruft das Makro <code>assert!</code> das
Makro <code>panic!</code> auf, wodurch der Test fehlschlägt. Das Verwenden des Makros
<code>assert!</code> hilft uns zu überprüfen, ob unser Code so funktioniert, wie wir es
beabsichtigen.</p>
<p>In Codeblock 5-15 in Kapitel 5 haben wir eine Struktur <code>Rectangle</code> und eine
Methode <code>can_hold</code> verwendet, die hier in Codeblock 11-5 wiederholt werden.
Lass uns diesen Code in die Datei <em>src/lib.rs</em> packen und einige Tests dafür
mit dem Makro <code>assert!</code> schreiben.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-5: Verwenden der Struktur <code>Rectangle</code> und
ihrer Methode <code>can_hold</code> aus Kapitel 5</span></p>
<p>Die Methode <code>can_hold</code> gibt ein Boolean zurück, was bedeutet, dass es ein
perfekter Anwendungsfall für das Makro <code>assert!</code> ist. In Codeblock 11-6
schreiben wir einen Test, der die Methode <code>can_hold</code> überprüft, indem wir eine
<code>Rectangle</code>-Instanz mit einer Breite von 8 und einer Höhe von 7 erstellen und
sicherstellen, dass es eine weitere <code>Rectangle</code>-Instanz mit einer Breite von 5
und einer Höhe von 1 enthalten kann.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
<span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&amp;smaller));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-6: Ein Test für <code>can_hold</code>, der prüft, ob in
ein größeres Rechteck tatsächlich ein kleineres Rechteck passt</span></p>
<p>Beachte, dass wir eine neue Zeile innerhalb des Moduls <code>tests</code> hinzugefügt
haben: <code>use super::*;</code>. Das Modul <code>tests</code> ist ein reguläres Modul, das den
üblichen Sichtbarkeitsregeln folgt, die wir in Kapitel 7 im Abschnitt <a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html">„Mit
Pfaden auf ein Element im Modulbaum
verweisen“</a> behandelt haben.
Da das Modul <code>tests</code> ein inneres Modul ist, müssen wir den Code, der im äußeren
Modul getestet wird, in den Gültigkeitsbereich des inneren Moduls bringen. Wir
verwenden hier einen Stern (glob), sodass alles, was wir im äußeren Modul
definieren, auch in diesem Modul <code>tests</code> zur Verfügung steht.</p>
<p>Wir haben unseren Test <code>larger_can_hold_smaller</code> genannt und wir haben die
beiden <code>Rectangle</code>-Instanzen erzeugt, die wir benötigen. Dann haben wir das
Makro <code>assert!</code> aufgerufen und ihm das Aufrufergebnis von
<code>larger.can_hold(&amp;smaller)</code> übergeben. Dieser Ausdruck soll <code>true</code> zurückgeben,
also sollte unser Test erfolgreich sein. Lass es uns herausfinden!</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 1 test
test tests::larger_can_hold_smaller ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Es funktioniert! Fügen wir noch einen weiteren Test hinzu, diesmal mit der
Zusicherung, dass ein kleineres Rechteck nicht in ein größeres Rechteck passt:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[derive(Debug)]
<span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Rectangle {
</span><span class="boring">    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
</span><span class="boring">        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn larger_can_hold_smaller() {
        // --abschneiden--
<span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span>    }

    #[test]
    fn smaller_cannot_hold_larger() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(!smaller.can_hold(&amp;larger));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Da das korrekte Ergebnis der Funktion <code>can_hold</code> in diesem Fall <code>false</code> ist,
müssen wir dieses Ergebnis negieren, bevor wir es an das Makro <code>assert!</code>
übergeben. Als Ergebnis wird unser Test bestehen, wenn <code>can_hold</code> den
Rückgabewert <code>false</code> hat:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... ok
test tests::smaller_cannot_hold_larger ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests rectangle

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Zwei Tests, die erfolgreich sind! Nun wollen wir sehen, was mit unseren
Testergebnissen passiert, wenn wir einen Fehler in unseren Code einbringen.
Lass uns die Implementierung der Methode <code>can_hold</code> ändern, indem wir das
größer-als-Zeichen durch ein kleiner-als-Zeichen ersetzen, wenn sie die Breiten
vergleicht:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"><span class="boring">#[derive(Debug)]
</span><span class="boring">struct Rectangle {
</span><span class="boring">    width: u32,
</span><span class="boring">    height: u32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Rectangle {
    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &lt; other.width &amp;&amp; self.height &gt; other.height
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn larger_can_hold_smaller() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(larger.can_hold(&amp;smaller));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn smaller_cannot_hold_larger() {
</span><span class="boring">        let larger = Rectangle {
</span><span class="boring">            width: 8,
</span><span class="boring">            height: 7,
</span><span class="boring">        };
</span><span class="boring">        let smaller = Rectangle {
</span><span class="boring">            width: 5,
</span><span class="boring">            height: 1,
</span><span class="boring">        };
</span><span class="boring">
</span><span class="boring">        assert!(!smaller.can_hold(&amp;larger));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Das Ausführen der Tests ergibt nun Folgendes:</p>
<pre><code class="language-console">$ cargo test
   Compiling rectangle v0.1.0 (file:///projects/rectangle)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/rectangle-6584c4561e48942e

running 2 tests
test tests::larger_can_hold_smaller ... FAILED
test tests::smaller_cannot_hold_larger ... ok

failures:

---- tests::larger_can_hold_smaller stdout ----
thread 'main' panicked at 'assertion failed: larger.can_hold(&amp;smaller)', src/lib.rs:28:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.


failures:
    tests::larger_can_hold_smaller

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Unsere Tests haben den Fehler entdeckt! Da <code>larger.width</code> gleich 8 ist und
<code>smaller.width</code> gleich 5, ergibt der Vergleich der Breiten in <code>can_hold</code> jetzt
<code>false</code>: 8 ist nicht weniger als 5.</p>
<h3><a class="header" href="#prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne" id="prüfung-auf-gleichheit-mit-den-makros-assert_eq-und-assert_ne">Prüfung auf Gleichheit mit den Makros <code>assert_eq!</code> und <code>assert_ne!</code></a></h3>
<p>Eine übliche Methode zum Testen der Funktionalität besteht darin, das Ergebnis
des zu testenden Codes mit dem Wert zu vergleichen, den du vom Code erwartest,
um sicherzustellen, dass sie gleich sind. Du könntest dies mit dem Makro
<code>assert!</code> tun und ihm einen Ausdruck mit dem Operator <code>==</code> übergeben. Dies ist
jedoch ein so häufiger Testfall, dass die Standardbibliothek zwei Makros zur
Verfügung stellt, um diesen Test bequemer durchzuführen: <code>assert_eq!</code> und
<code>assert_ne!</code>. Diese Makros vergleichen zwei Argumente auf Gleichheit bzw.
Ungleichheit. Sie geben auch die beiden Werte aus, wenn die Zusicherung
fehlschlägt, was es einfacher macht zu erkennen, <em>warum</em> der Test
fehlgeschlagen ist; umgekehrt zeigt das Makro <code>assert!</code> nur an, dass der
Ausdruck <code>==</code> den Wert <code>false</code> ergeben hat, nicht die Werte, die zum falschen
Testergebnis führen.</p>
<p>In Codeblock 11-7 schreiben wir eine Funktion namens <code>add_two</code>, die zu ihrem
Parameter <code>2</code> addiert und das Ergebnis zurückgibt. Dann testen wir diese
Funktion mit dem Makro <code>assert_eq!</code>.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-7: Testen der Funktion <code>add_two</code> mit dem
Makro <code>assert_eq!</code></span></p>
<p>Lass uns prüfen, ob sie den Test besteht!</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Das erste Argument <code>4</code>, das wir dem Makro <code>assert_eq!</code> übergeben haben, ist
identisch mit dem Ergebnis des Aufrufs <code>add_two(2)</code>. Die Zeile für diesen Test
lautet <code>test tests::it_adds_two ... ok</code>, und der Text <code>ok</code> zeigt an, dass unser
Test bestanden wurde!</p>
<p>Lass uns einen Fehler in unseren Code einbringen, um zu sehen, wie es aussieht,
wenn ein Test, der <code>assert_eq!</code> verwendet, fehlschlägt. Ändern wir die
Implementierung der Funktion <code>add_two</code>, sodass sie stattdessen <code>3</code> addiert:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior">pub fn add_two(a: i32) -&gt; i32 {
    a + 3
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn it_adds_two() {
</span><span class="boring">        assert_eq!(4, add_two(2));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Führe die Tests erneut aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::it_adds_two ... FAILED

failures:

---- tests::it_adds_two stdout ----
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `4`,
 right: `5`', src/lib.rs:11:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::it_adds_two

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Unser Test hat den Fehler entdeckt! Der Test <code>it_adds_two</code> schlug fehl mit der
Meldung <code>assertion failed: `(left == right)` </code> und dass <code>left</code> den Wert <code>4</code>
und <code>right</code> den Wert <code>5</code> hatte. Diese Nachricht ist nützlich und hilft uns, mit
der Fehlersuche zu beginnen: Sie bedeutet, dass das Argument <code>left</code> von
<code>assert_eq!</code> den Wert <code>4</code> hatte, aber das Argument <code>right</code>, wo wir
<code>add_two(2)</code> hatten, war <code>5</code>.</p>
<p>Beachte, dass in einigen Sprachen und Test-Bibliotheken die Parameter der
Funktionen, die zwei Werte auf Gleichheit prüfen, <code>expected</code> und <code>actual</code>
genannt werden und deren Reihenfolge wichtig ist. In Rust werden sie jedoch
<code>left</code> und <code>right</code> genannt und die Reihenfolge, in der wir den erwarteten Wert
und den vom zu testenden Code produzierten Wert angeben, spielt keine Rolle.
Wir könnten die Zusicherung in diesem Test als <code>assert_eq!(add_two(2), 4)</code>
schreiben, was zur Fehlermeldung <code>assertion failed: `(left == right)` </code>
führen würde und dass <code>left</code> den Wert <code>5</code> und <code>right</code> den Wert <code>4</code> hatte.</p>
<p>Das Makro <code>assert_ne!</code> prüft, ob die beiden Werte, die wir ihm übergeben,
ungleich sind und scheitert, wenn sie gleich sind. Dieses Makro ist am
nützlichsten in Fällen, in denen wir nicht sicher sind, <em>welchen</em> Wert wir
bekommen werden, aber wir wissen, welcher Wert es definitiv <em>nicht</em> sein wird,
wenn unser Code so funktioniert, wie wir es beabsichtigen. Wenn wir zum
Beispiel eine Funktion testen, die ihre Eingabe garantiert in irgendeiner Weise
verändert, aber die Art und Weise, wie die Eingabe verändert wird, vom
Wochentag abhängt, an dem wir unsere Tests ausführen, ist es vielleicht am
besten sicherzustellen, dass die Ausgabe der Funktion nicht gleich der Eingabe
ist.</p>
<p>Unter der Haube verwenden die Makros <code>assert_eq!</code> und <code>assert_ne!</code> die
Operatoren <code>==</code> bzw. <code>!=</code>. Wenn die Zusicherungen fehlschlagen, geben diese
Makros ihre Argumente unter Verwendung der Debug-Formatierung aus, was
bedeutet, dass die zu vergleichenden Werte die Merkmale <code>PartialEq</code> und
<code>Debug</code> implementieren müssen. Alle primitiven Typen und die meisten
Standardbibliothekstypen implementieren diese Merkmale. Für Strukturen und
Aufzählungen, die du definierst, musst du <code>PartialEq</code> implementieren, um
prüfen zu können, dass Werte dieser Typen gleich oder ungleich sind. Du musst
<code>Debug</code> implementieren, um die Werte zu auszugeben, wenn die Zusicherung
fehlschlägt. Da es sich bei beiden Merkmalen um ableitbare Merkmale handelt,
wie in Codeblock 5-12 in Kapitel 5 erwähnt, genügt normalerweise das Ergänzen
der Annotation <code>#[derive(PartialEq, Debug)]</code> bei deiner Struktur- und
Aufzählungsdefinition. Siehe Anhang C <a href="appendix-03-derivable-traits.html">„Ableitbare Merkmale
(traits)“</a> für weitere Einzelheiten über diese und andere
ableitbare Merkmale.</p>
<h3><a class="header" href="#benutzerdefinierte-fehlermeldungen-angeben" id="benutzerdefinierte-fehlermeldungen-angeben">Benutzerdefinierte Fehlermeldungen angeben</a></h3>
<p>Du kannst den Makros <code>assert!</code>, <code>assert_eq!</code> und <code>assert_ne!</code> optional auch
eine benutzerdefinierte Nachricht mitgeben, die mit der Fehlermeldungen
ausgegeben wird. Alle Argumente, die nach dem einen erforderlichen Argument für
<code>assert!</code> oder den beiden erforderlichen Argumenten für <code>assert_eq!</code> und
<code>assert_ne!</code> angegeben werden, werden an das Makro <code>format!</code> übergeben (siehe
Kapitel 8, Abschnitt <a href="ch08-02-strings.html#aneinanderh%C3%A4ngen-mit-dem-operator--und-dem-makro-format">„Aneinanderhängen mit dem Operator <code>+</code> und dem Makro
<code>format!</code>“</a>), sodass du
eine Formatierungs-Zeichenkette übergeben kannst, die Platzhalter <code>{}</code> und
Werte enthält, die in diese Platzhalter gehören. Benutzerdefinierte Nachrichten
sind nützlich, um zu dokumentieren, was eine Zusicherung bedeutet; wenn ein
Test fehlschlägt, hast du eine bessere Vorstellung davon, wo das Problem im
Code liegt.</p>
<p>Nehmen wir zum Beispiel an, wir haben eine Funktion, die Leute mit Namen
begrüßt, und wir wollen testen, ob der Name, den wir an die Funktion übergeben,
in der Ausgabe auftaucht:</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub fn greeting(name: &amp;str) -&gt; String {
    format!(&quot;Hallo {}!&quot;, name)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(result.contains(&quot;Carol&quot;));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Die Anforderungen für dieses Programm sind noch nicht abgestimmt worden und wir
sind ziemlich sicher, dass sich der Text <code>Hallo</code> zu Beginn der Begrüßung ändern
wird. Wir haben beschlossen, dass wir den Test nicht aktualisieren wollen, wenn
sich die Anforderungen ändern. Anstatt also zu prüfen, ob der Test exakt dem
von der Funktion <code>greeting</code> zurückgegebenen Wert entspricht, stellen wir
einfach sicher, dass die Ausgabe den Text des Eingabeparameters enthält.</p>
<p>Lass uns einen Fehler in diesen Code einbringen, indem wir <code>greeting</code> so
ändern, dass <code>name</code> nicht enthalten ist, um zu sehen, wie dieses Testversagen
aussieht:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior">pub fn greeting(name: &amp;str) -&gt; String {
    String::from(&quot;Hallo!&quot;)
}

<span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn greeting_contains_name() {
</span><span class="boring">        let result = greeting(&quot;Carol&quot;);
</span><span class="boring">        assert!(result.contains(&quot;Carol&quot;));
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Das Ausführen dieses Tests führt zu folgender Ausgabe:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.91s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'assertion failed: result.contains(&quot;Carol&quot;)', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Dieses Ergebnis zeigt nur an, dass die Zusicherung fehlgeschlagen ist und in
welcher Zeile die Zusicherung steht. Eine nützlichere Fehlermeldung würde in
diesem Fall den Wert ausgeben, den wir von der Funktion <code>greeting</code> erhalten
haben. Lass uns die Testfunktion ändern, indem wir ihr eine benutzerdefinierte
Fehlermeldung angeben, die aus einer Formatierungszeichenkette mit einem
Platzhalter besteht, der mit dem tatsächlichen Wert gefüllt ist, den wir von
der Funktion <code>greeting</code> erhalten haben:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub fn greeting(name: &amp;str) -&gt; String {
</span><span class="boring">    String::from(&quot;Hallo!&quot;)
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
<span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span>    #[test]
    fn greeting_contains_name() {
        let result = greeting(&quot;Carol&quot;);
        assert!(
            result.contains(&quot;Carol&quot;),
            &quot;Begrüßung enthielt nicht den Namen, Wert war `{}`&quot;,
            result
        );
    }
<span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir jetzt den Test ausführen, erhalten wir eine aussagekräftigere
Fehlermeldung:</p>
<pre><code class="language-console">$ cargo test
   Compiling greeter v0.1.0 (file:///projects/greeter)
    Finished test [unoptimized + debuginfo] target(s) in 0.93s
     Running target/debug/deps/greeter-170b942eb5bf5e3a

running 1 test
test tests::greeting_contains_name ... FAILED

failures:

---- tests::greeting_contains_name stdout ----
thread 'main' panicked at 'Begrüßung enthielt nicht den Namen, Wert war `Hallo!`', src/lib.rs:12:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::greeting_contains_name

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Wir können den Wert, den wir tatsächlich erhalten haben, in der Testausgabe
sehen, was uns helfen wird, das zu debuggen, was passiert ist, anstatt das,
was wir erwartet hatten.</p>
<h3><a class="header" href="#mit-should_panic-auf-programmabbrüche-prüfen" id="mit-should_panic-auf-programmabbrüche-prüfen">Mit <code>should_panic</code> auf Programmabbrüche prüfen</a></h3>
<p>Neben der Prüfung, ob unser Code die von uns erwarteten korrekten Werte
zurückgibt, ist es auch wichtig zu prüfen, ob unser Code Fehlerbedingungen so
behandelt, wie wir es erwarten. Denke zum Beispiel an den Typ <code>Guess</code>, den wir
in Kapitel 9 in Codeblock 9-10 erstellt haben. Anderer Code, der <code>Guess</code>
verwendet, hängt von der Garantie ab, dass <code>Guess</code>-Instanzen nur Werte zwischen
1 und 100 enthalten. Wir können einen Test schreiben, der sicherstellt, dass
der Versuch, eine <code>Guess</code>-Instanz mit einem Wert außerhalb dieses Bereichs zu
erzeugen, zum Programmabbrucht führt.</p>
<p>Wir tun dies, indem wir ein weiteres Attribut <code>should_panic</code> zu unserer
Testfunktion hinzufügen. Dieses Attribut bewirkt, dass ein Test als bestanden
gilt, wenn der Code innerhalb der Funktion abbricht; der Test schlägt fehl,
wenn der Code innerhalb der Funktion nicht abbricht.</p>
<p>Codeblock 11-8 zeigt einen Test, der prüft, ob die Fehlerbedingungen von
<code>Guess::new</code> eintreten, wenn wir dies erwarten.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 || value &gt; 100 {
            panic!(&quot;Schätzwert muss zwischen 1 und 100 liegen, ist {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-8: Testet, dass eine Bedingung zum
Programmabbruch führt</span></p>
<p>Wir setzen das Attribut <code>#[should_panic]</code> hinter das Attribut <code>#[test]</code> und vor
die Testfunktion, auf die sie sich bezieht. Schauen wir uns das Ergebnis an,
wenn dieser Test bestanden ist:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests guessing_game

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Sieht gut aus! Lass uns nun einen Fehler in unseren Code einbringen, indem wir
die Bedingung entfernen, bei der die Funktion <code>new</code> das Programm abbricht, wenn
der Wert größer als 100 ist:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Schätzwert muss zwischen 1 und 100 liegen, ist {}.&quot;, value);
        }

        Guess { value }
    }
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Wenn wir den Test in Codeblock 11-8 ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
note: test did not panic as expected

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Wir erhalten in diesem Fall keine sehr hilfreiche Meldung, aber wenn wir uns
die Testfunktion ansehen, sehen wir, dass sie mit <code>#[should_panic]</code> annotiert
ist. Der Fehler, den wir erhielten, bedeutet, dass der Code in der Testfunktion
keinen Programmabbruch verursacht hat.</p>
<p>Tests, die <code>should_panic</code> verwenden, können ungenau sein, weil sie nur
anzeigen, dass der Code einen Programmabbruch verursacht hat. Ein Test mit
<code>should_panic</code> würde auch dann bestanden werden, wenn der Test aus einem
anderen Grund zum Programmabbrucht führt als dem, den wir erwartet haben. Um
Tests mit <code>should_panic</code> präziser zu machen, können wir beim
<code>should_panic</code>-Attribut einen optionalen Parameter <code>expected</code> ergänzen. Das
Testsystem stellt sicher, dass die Fehlermeldung den angegebenen Text enthält.
Betrachte zum Beispiel den modifizierten Code für <code>Guess</code> in Codeblock 11-9, wo
die Funktion <code>new</code> mit unterschiedlichen Meldungen das Programm abbricht, je
nachdem, ob der Wert zu klein oder zu groß ist.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust"><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span>// --abschneiden--
impl Guess {
    pub fn new(value: i32) -&gt; Guess {
        if value &lt; 1 {
            panic!(&quot;Schätzwert muss größer oder gleich 1 sein, ist {}.&quot;, value);
        } else if value &gt; 100 {
            panic!(&quot;Schätzwert muss kleiner oder gleich 100 sein, ist {}.&quot;, value);
        }

        Guess { value }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[should_panic(expected = &quot;Schätzwert muss kleiner oder gleich 100 sein&quot;)]
    fn greater_than_100() {
        Guess::new(200);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-9: Testet, ob ein Zustand einen
Programmabbruch mit einer bestimmten Abbruchsmeldung auslöst</span></p>
<p>Dieser Test wird bestanden werden, weil der Wert, den wir beim Parameter
<code>expected</code> des <code>should_panic</code>-Attributs angeben, eine Teilzeichenkette der
Nachricht ist, mit der die Funktion <code>Guess::new</code> das Programm abbricht. Wir
hätten die gesamte erwartete Abbruchsnachricht angeben können, in diesem Fall
also <code>Schätzwert muss kleiner oder gleich 100 sein, ist 200</code>. Was du im
Parameter <code>expected</code> für <code>should_panic</code> angibst, hängt davon ab, wie viel von
der Abbruchsnachricht eindeutig oder dynamisch ist und wie präzise dein Test
sein soll. In diesem Fall reicht eine Teilzeichenkette der Abbruchsnachricht
aus, um sicherzustellen, dass der Code in der Testfunktion den Fall <code>else if value &gt; 100</code> ausführt.</p>
<p>Um zu sehen, was passiert, wenn ein Test mit <code>should_panic</code> und einer
<code>expected</code>-Nachricht fehlschlägt, wollen wir wieder einen Fehler in unseren
Code einbringen, indem wir die Zweige <code>if value &lt; 1</code>  und <code>else if value &gt; 100</code>
vertauschen:</p>
<pre><pre class="playpen"><code class="language-rust not_desired_behavior">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span><span class="boring">pub struct Guess {
</span><span class="boring">    value: i32,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Guess {
</span><span class="boring">    pub fn new(value: i32) -&gt; Guess {
</span>        if value &lt; 1 {
            panic!(&quot;Schätzwert muss kleiner oder gleich 100 sein, ist {}.&quot;,
                   value);
        } else if value &gt; 100 {
            panic!(&quot;Schätzwert muss größer oder gleich 1 sein, ist {}.&quot;, value);
        }
<span class="boring">
</span><span class="boring">        Guess { value }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    #[should_panic(expected = &quot;Guess value must be less than or equal to 100&quot;)]
</span><span class="boring">    fn greater_than_100() {
</span><span class="boring">        Guess::new(200);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">}
</span></code></pre></pre>
<p>Wenn wir diesmal den <code>should_panic</code>-Test ausführen, wird er fehlschlagen:</p>
<pre><code class="language-console">$ cargo test
   Compiling guessing_game v0.1.0 (file:///projects/guessing_game)
    Finished test [unoptimized + debuginfo] target(s) in 0.66s
     Running target/debug/deps/guessing_game-57d70c3acb738f4d

running 1 test
test tests::greater_than_100 ... FAILED

failures:

---- tests::greater_than_100 stdout ----
thread 'main' panicked at 'Schätzwert muss größer oder gleich 1 sein, ist 200.', src/lib.rs:13:13
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
note: panic did not contain expected string
      panic message: `&quot;Schätzwert muss größer oder gleich 1 sein, ist 200.&quot;`,
 expected substring: `&quot;Schätzwert muss kleiner oder gleich 100 sein&quot;`

failures:
    tests::greater_than_100

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Die Fehlermeldung zeigt an, dass dieser Test tatsächlich wie erwartet das
Programm abgebrochen hat, aber die Abbruchsmeldung enthielt nicht die erwartete
Zeichenfolge <code>'Schätzwert muss kleiner oder gleich 100 sein'</code>. Die
Abbruchsmeldung, die wir in diesem Fall erhielten, lautete: <code>Schätzwert muss größer oder gleich 1 sein, ist 200.</code> Jetzt können wir anfangen herauszufinden,
wo unser Fehler liegt!</p>
<h3><a class="header" href="#verwenden-von-resultt-e-in-tests" id="verwenden-von-resultt-e-in-tests">Verwenden von <code>Result&lt;T, E&gt;</code> in Tests</a></h3>
<p>Bisher haben wir Tests geschrieben, die das Programm abbrechen, wenn sie
fehlschlagen. Wir können auch Tests schreiben, die <code>Result&lt;T, E&gt;</code> verwenden!
Hier ist der Test aus Codeblock 11-1 so umgeschrieben, dass er <code>Result&lt;T, E&gt;</code>
verwendet und <code>Err</code> zurückgibt, anstatt das Programm abzubrechen:</p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    #[test]
    fn it_works() -&gt; Result&lt;(), String&gt; {
        if 2 + 2 == 4 {
            Ok(())
        } else {
            Err(String::from(&quot;zwei plus zwei ist nicht gleich vier&quot;))
        }
    }
}
<span class="boring">}
</span></code></pre></pre>
<p>Die Funktion <code>it_works</code> hat jetzt den Rückgabetyp <code>Result&lt;(), String&gt;</code>. Anstatt
das Makro <code>assert_eq!</code> aufzurufen, geben wir im Funktionsrumpf <code>Ok(())</code> zurück,
wenn der Test bestanden ist, und ein <code>Err</code> mit einem <code>String</code> im Inneren, wenn
der Test fehlschlägt.</p>
<p>Wenn du Tests so schreibst, dass sie ein <code>Result&lt;T, E&gt;</code> zurückgeben, kannst du
den Fragezeichen-Operator im Testrumpf verwenden, was eine bequeme Möglichkeit
sein kann, Tests zu schreiben, die fehlschlagen sollten, wenn irgendeine
Operation darin eine <code>Err</code>-Variante zurückgibt.</p>
<p>Du kannst die Annotation <code>#[should_panic]</code> nicht für Tests verwenden, die
<code>Result&lt;T, E&gt;</code> verwenden. Stattdessen solltest du direkt einen <code>Err</code>-Wert
zurückgeben, wenn der Test fehlschlagen soll.</p>
<p>Da du nun verschiedene Möglichkeiten kennst, Tests zu schreiben, lass uns einen
Blick darauf werfen, was passiert, wenn wir unsere Tests ausführen, und die
verschiedenen Optionen untersuchen, die wir mit <code>cargo test</code> verwenden können.</p>
<h2><a class="header" href="#steuern-wie-tests-ausgeführt-werden" id="steuern-wie-tests-ausgeführt-werden">Steuern wie Tests ausgeführt werden</a></h2>
<p>So wie <code>cargo run</code> deinen Code kompiliert und dann die resultierende Binärdatei
ausführt, kompiliert <code>cargo test</code> deinen Code im Testmodus und führt die
resultierende Testbinärdatei aus. Du kannst Befehlszeilenoptionen angeben, um
das Standardverhalten von <code>cargo test</code> zu ändern. Das Standardverhalten der von
<code>cargo test</code> erzeugten Binärdatei besteht beispielsweise darin, alle Tests
parallel auszuführen und die während der Testläufe generierte Ausgabe zu
erfassen, wodurch verhindert wird, dass die Ausgabe angezeigt wird, und das
Lesen der Ausgabe bezüglich der Testergebnisse erleichtert wird.</p>
<p>Einige Kommandozeilen-Optionen betreffen <code>cargo test</code> und einige betreffen die
resultierende Testbinärdatei. Um diese beiden Argumentarten
auseinanderzuhalten, gibst du zuerst die Argumente für <code>cargo test</code>, gefolgt
vom Trennzeichen <code>--</code>, und danach die der Testbinärdatei an. Wenn du <code>cargo test --help</code> ausführst, werden die Optionen angezeigt, die du für <code>cargo test</code>
verwenden kannst, und wenn du <code>cargo test -- --help</code> ausführst, werden die
Optionen angezeigt, die du nach dem Trennzeichen <code>--</code> verwenden kannst.</p>
<h3><a class="header" href="#tests-parallel-oder-nacheinander-ausführen" id="tests-parallel-oder-nacheinander-ausführen">Tests parallel oder nacheinander ausführen</a></h3>
<p>Wenn du mehrere Tests ausführst, werden diese standardmäßig parallel in
Strängen (threads) ausgeführt. Das bedeutet, dass die Tests schneller
abgeschlossen werden, sodass du schneller Rückmeldung darüber erhältst, ob dein
Code funktioniert oder nicht. Da die Tests gleichzeitig ausgeführt werden,
stelle sicher, dass deine Tests nicht voneinander oder von einem gemeinsam
genutzten Zustand abhängen, einschließlich einer gemeinsam genutzten Umgebung,
z.B. dem aktuellen Arbeitsverzeichnis oder Umgebungsvariablen.</p>
<p>Angenommen, jeder deiner Tests führt einen Code aus, der eine Datei auf der
Festplatte mit dem Namen <em>test-output.txt</em> erstellt und einige Daten in diese
Datei schreibt. Dann liest jeder Test Daten aus dieser Datei und stellt fest,
dass die Datei einen bestimmten Wert enthält, der bei jedem Test anders ist. Da
die Tests zur gleichen Zeit laufen, kann es vorkommen, dass ein Test die Datei
überschreibt, während ein anderer Test die Datei schreibt und liest. Der zweite
Test wird dann fehlschlagen, nicht weil der Code falsch ist, sondern weil sich
die Tests bei der parallelen Ausführung gegenseitig beeinflusst haben. Eine
Lösung besteht darin, dafür zu sorgen, dass jeder Test in eine eigene Datei
schreibt; eine andere Lösung besteht darin, die Tests einzeln nacheinander
auszuführen.</p>
<p>Wenn du die Tests nicht parallel ausführen möchtest oder wenn du eine
feingranularere Kontrolle über die Anzahl der verwendeten Stränge haben willst,
kannst du den Schalter <code>--test-threads</code> mit der Anzahl der Stränge, die du
verwenden möchtest, an die Testbinärdatei übergeben. Sieh dir das folgende
Beispiel an:</p>
<pre><code class="language-console">$ cargo test -- --test-threads=1
</code></pre>
<p>Wir setzen die Anzahl der Teststränge auf <code>1</code> und weisen das Programm an, keine
Parallelität zu verwenden. Die Ausführung der Tests mit einem Strang dauert
länger als die parallele Ausführung, aber die Tests stören sich nicht
gegenseitig, wenn sie den gleichen Zustand verwenden.</p>
<h3><a class="header" href="#anzeigen-der-funktionsausgabe" id="anzeigen-der-funktionsausgabe">Anzeigen der Funktionsausgabe</a></h3>
<p>Standardmäßig erfasst die Testbibliothek von Rust bei einem bestandenen Test
alles, was in die Standardausgabe ausgegeben wurde. Wenn wir beispielsweise
<code>println!</code> in einem Test aufrufen und der Test erfolgreich ist, sehen wir die
Ausgabe von <code>println!</code> im Terminal nicht; wir sehen nur die Zeile, die den
bestandenen Test anzeigt. Wenn ein Test fehlschlägt, sehen wir das, was in die
Standardausgabe ausgegeben wurde, mit dem Rest der Fehlermeldung.</p>
<p>Als Beispiel hat Codebock 11-10 eine dumme Funktion, die den Wert ihres
Parameters ausgibt und 10 zurückgibt, sowie einen Test, der bestanden wird, und
einen Test, der fehlschlägt.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust panics">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn prints_and_returns_10(a: i32) -&gt; i32 {
    println!(&quot;Ich habe den Wert {} erhalten.&quot;, a);
    10
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn this_test_will_pass() {
        let value = prints_and_returns_10(4);
        assert_eq!(10, value);
    }

    #[test]
    fn this_test_will_fail() {
        let value = prints_and_returns_10(8);
        assert_eq!(5, value);
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codebock 11-10: Tests einer Funktion, die <code>println!</code>
aufruft</span></p>
<p>Wenn wir diese Tests mit <code>cargo test</code> ausführen, werden wir folgende Ausgabe
sehen:</p>
<pre><code class="language-console">$ cargo test
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.58s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<p>Beachte, dass wir nirgendwo in dieser Ausgabe <code>Ich habe den Wert 4 erhalten.</code>
sehen, was beim erfolgreichen Testlauf ausgegeben wird. Diese Ausgabe wurde
aufgefangen. Die Ausgabe <code>Ich habe den Wert 8 erhalten.</code> des fehlgeschlagenen
Tests erscheint im Abschnitt der Testzusammenfassung, der auch die Ursache des
Testfehlers anzeigt.</p>
<p>Wenn wir auch die ausgegebenen Werte der bestandenen Tests sehen wollen, können
wir Rust mit <code>--show-output</code> anweisen, die Ausgabe erfolgreicher Tests
ebenfalls mit anzuzeigen.</p>
<pre><code class="language-console">$ cargo test -- --show-output
</code></pre>
<p>Wenn wir die Tests in Codeblock 11-10 mit dem Schalter <code>--show-output</code> erneut
ausführen, sehen wir folgende Ausgabe:</p>
<pre><code class="language-console">$ cargo test -- --show-output
   Compiling silly-function v0.1.0 (file:///projects/silly-function)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/silly_function-160869f38cff9166

running 2 tests
test tests::this_test_will_fail ... FAILED
test tests::this_test_will_pass ... ok

successes:

---- tests::this_test_will_pass stdout ----
Ich habe den Wert 4 erhalten.

successes:
    tests::this_test_will_pass

failures:

---- tests::this_test_will_fail stdout ----
Ich habe den Wert 8 erhalten.
thread 'main' panicked at 'assertion failed: `(left == right)`
  left: `5`,
 right: `10`', src/lib.rs:19:9
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace.

failures:
    tests::this_test_will_fail

test result: FAILED. 1 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out

error: test failed, to rerun pass '--lib'
</code></pre>
<h3><a class="header" href="#ausführen-einer-test-teilmenge-mittels-name" id="ausführen-einer-test-teilmenge-mittels-name">Ausführen einer Test-Teilmenge mittels Name</a></h3>
<p>Manchmal kann die Ausführung einer vollständigen Testsammlung sehr lange
dauern. Wenn du an Code in einem bestimmten Bereich arbeitest, solltest du
vielleicht nur die Tests ausführen, die diesen Code betreffen. Du kannst
wählen, welche Tests ausgeführt werden sollen, indem du <code>cargo test</code> den oder
die Namen der Tests, die du ausführen willst, als Argument übergibst.</p>
<p>Um zu demonstrieren, wie man eine Teilmenge von Tests ausführt, werden wir drei
Tests für unsere Funktion <code>add_two</code> erstellen, wie in Codeblock 11-11 zu sehen
ist, und auswählen, welche wir ausführen wollen.</p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn add_two(a: i32) -&gt; i32 {
    a + 2
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn add_two_and_two() {
        assert_eq!(4, add_two(2));
    }

    #[test]
    fn add_three_and_two() {
        assert_eq!(5, add_two(3));
    }

    #[test]
    fn one_hundred() {
        assert_eq!(102, add_two(100));
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-11: Drei Tests mit drei verschiedenen
Namen</span></p>
<p>Wenn wir die Tests ohne Argumente durchführen, wie vorhin gesehen, werden alle
Tests parallel laufen:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.62s
     Running target/debug/deps/adder-92948b65e88960b4

running 3 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok
test tests::one_hundred ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<h4><a class="header" href="#ausführen-einzelner-tests" id="ausführen-einzelner-tests">Ausführen einzelner Tests</a></h4>
<p>Wir können den Namen einer beliebigen Testfunktion an <code>cargo test</code> übergeben,
um nur diesen Test auszuführen:</p>
<pre><code class="language-console">$ cargo test one_hundred
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.69s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::one_hundred ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>Nur der Test mit dem Namen <code>one_hundred</code> lief; die beiden anderen Tests passten
nicht zu diesem Namen. Die Testausgabe lässt uns wissen, dass wir mehrere Tests
hatten, als dieser Befehl ausgeführt wurde, indem am Ende der
Zusammenfassungszeile <code>2 filtered out</code> angezeigt wird.</p>
<p>Wir können die Namen mehrerer Tests nicht auf diese Weise angeben; es wird nur
der erste Wert verwendet, der bei <code>cargo test</code> angegeben wird. Aber es gibt
eine Möglichkeit, mehrere Tests auszuführen.</p>
<h4><a class="header" href="#filtern-um-mehrerer-tests-auszuführen" id="filtern-um-mehrerer-tests-auszuführen">Filtern um mehrerer Tests auszuführen</a></h4>
<p>Wir können einen Teil eines Testnamens angeben und jeder Test, dessen Name zu
diesem Wert passt, wird ausgeführt. Da zum Beispiel zwei der Namen unserer
Tests <code>add</code> enthalten, können wir diese beiden Tests ausführen, indem wir
<code>cargo test add</code> ausführen:</p>
<pre><code class="language-console">$ cargo test add
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test tests::add_three_and_two ... ok
test tests::add_two_and_two ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out
</code></pre>
<p>Dieser Befehl führte alle Tests mit <code>add</code> im Namen aus und filterte den Test
mit dem Namen <code>one_hundred</code> heraus. Beachte auch, dass das Modul, in dem sich
ein Test befindet, Teil des Testnamens wird, sodass wir alle Tests in einem
Modul ausführen können, indem wir nach dem Namen des Moduls filtern.</p>
<h3><a class="header" href="#tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden" id="tests-ignorieren-die-nicht-ausdrücklich-verlangt-werden">Tests ignorieren, die nicht ausdrücklich verlangt werden</a></h3>
<p>Manchmal kann die Ausführung einiger spezifischer Tests sehr zeitaufwendig
sein, sodass du diese bei den meisten <code>cargo test</code>-Aufrufen ausschließen
solltest. Anstatt alle Tests, die du ausführen möchtest, als Argumente
aufzulisten, kannst du die zeitaufwendigen Tests stattdessen mit dem Attribut
<code>ignore</code> annotieren, um sie auszuschließen, wie hier gezeigt: </p>
<p><span class="filename">Dateiname: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[test]
fn it_works() {
    assert_eq!(2 + 2, 4);
}

#[test]
#[ignore]
fn expensive_test() {
    // Code, dessen Ausführung eine Stunde dauert
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Unterhalb <code>#[test]</code> fügen wir die Zeile <code>#[ignore]</code> beim Test ein, den wir
ausschließen wollen. Wenn wir nun unsere Tests ausführen, läuft <code>it_works</code>,
aber <code>expensive_test</code> nicht:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.60s
     Running target/debug/deps/adder-92948b65e88960b4

running 2 tests
test expensive_test ... ignored
test it_works ... ok

test result: ok. 1 passed; 0 failed; 1 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die Funktion <code>expensive_test</code> wird als <code>ignored</code> aufgeführt. Wenn wir nur die
ignorierten Tests ausführen wollen, können wir <code>cargo test -- --ignored</code>
angeben:</p>
<pre><code class="language-console">$ cargo test -- --ignored
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.61s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test expensive_test ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 1 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Indem du kontrollierst, welche Tests durchgeführt werden, kannst du
sicherstellen, dass dein <code>cargo test</code>-Aufruf schnell zu Ergebnissen führt. Wenn
du an einem Punkt angelangt bist, an dem es sinnvoll ist, die Ergebnisse der
<code>ignored</code>-Tests zu überprüfen, und du Zeit hast, auf die Ergebnisse zu warten,
kannst du stattdessen <code>cargo test -- --ignored</code> ausführen.</p>
<h2><a class="header" href="#testverwaltung" id="testverwaltung">Testverwaltung</a></h2>
<p>Wie zu Beginn des Kapitels erwähnt, ist das Testen eine komplexe Disziplin, und
verschiedene Personen verwenden unterschiedliche Terminologien und
Organisationen. Die Rust-Gemeinschaft teilt Tests in zwei Hauptkategorien ein:
<em>Modultests</em> (unit tests) und <em>Integrationstests</em> (integration tests).
Modultests sind klein und zielgerichteter, testen jeweils ein Modul isoliert
und können private Schnittstellen testen. Integrationstests sind völlig
außerhalb deiner Bibliothek und verwenden deinen Code auf die gleiche Weise wie
jeder andere externe Code, wobei nur die öffentliche Schnittstelle verwendet
wird und möglicherweise mehrere Module pro Test ausgeführt werden.</p>
<p>Es ist wichtig, beide Testarten zu schreiben, um sicherzustellen, dass die
Teile deiner Bibliothek einzeln und zusammen das tun, was du von ihnen
erwartest.</p>
<h3><a class="header" href="#modultests" id="modultests">Modultests</a></h3>
<p>Der Zweck von Modultests besteht darin, jede Code-Einheit isoliert vom Rest des
Codes zu testen, um schnell herauszufinden, welcher Code wie erwartet
funktioniert und welcher nicht. Modultests befinden sich im Verzeichnis <em>src</em>
in den Quellcodedateien, den sie testen. Die Konvention besteht darin, in jeder
Datei ein Modul namens <code>tests</code> zu erstellen, das die Testfunktionen enthält,
und das Modul mit <code>cfg(test)</code> zu annotieren.</p>
<h4><a class="header" href="#das-testmodul-und-cfgtest" id="das-testmodul-und-cfgtest">Das Testmodul und <code>#[cfg(test)]</code></a></h4>
<p>Die Annotation <code>#[cfg(test)]</code> am Testmodul weist Rust an, den Testcode nur dann
zu kompilieren und auszuführen, wenn du <code>cargo test</code> ausführst, nicht aber,
wenn du <code>cargo build</code> ausführst. Dies spart Kompilierzeit, wenn du nur die
Bibliothek erstellen möchtest, und spart Platz im resultierenden, kompilierten
Artefakt, da die Tests nicht enthalten sind. Du wirst feststellen, dass
Integrationstests die Annotation <code>#[cfg(test)]</code> nicht benötigen, weil sie in
einem anderen Verzeichnis liegen. Da Modultests jedoch in den gleichen Dateien
wie der Code sind, wirst du <code>#[cfg(test)]</code> verwenden, um anzugeben, dass sie
nicht im kompilierten Ergebnis enthalten sein sollen.</p>
<p>Erinnere dich daran, dass Cargo diesen Code für uns generiert hat, als wir das
neue Projekt <code>adder</code> im ersten Abschnitt dieses Kapitels erstellt haben:</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>Dieser Code ist das automatisch generierte Testmodul. Das Attribut <code>cfg</code> steht
für <em>Konfiguration</em> und teilt Rust mit, dass das folgende Element nur bei einer
bestimmten Konfigurationsoption eingebunden werden soll. In diesem Fall ist die
Konfigurationsoption <code>test</code>, die von Rust beim Kompilieren und Ausführen von
Tests verwendet wird. Durch das Verwenden des Attributs <code>cfg</code> kompiliert Cargo
unseren Testcode nur dann, wenn wir die Tests aktiv mit <code>cargo test</code> ausführen.
Dies schließt alle Hilfsfunktionen ein, die sich innerhalb dieses Moduls
befinden könnten, zusätzlich zu den mit <code>#[test]</code> annotierten Funktionen.</p>
<h4><a class="header" href="#testen-privater-funktionen" id="testen-privater-funktionen">Testen privater Funktionen</a></h4>
<p>In der Testgemeinschaft wird darüber diskutiert, ob private Funktionen direkt
getestet werden sollten oder nicht, und andere Sprachen machen es schwierig
oder gar unmöglich, private Funktionen zu testen. Unabhängig davon, an welcher
Testideologie du festhältst, erlauben dir Rusts Datenschutzregeln, private
Funktionen zu testen. Betrachte den Code in Codeblock 11-12 mit der privaten
Funktion <code>internal_adder</code>.</p>
<p><span class="filename">Filename: src/lib.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">pub fn add_two(a: i32) -&gt; i32 {
    internal_adder(a, 2)
}

fn internal_adder(a: i32, b: i32) -&gt; i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn internal() {
        assert_eq!(4, internal_adder(2, 2));
    }
}
<span class="boring">
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p><span class="caption">Codeblock 11-12: Testen einer privaten Funktion</span></p>
<p>Beachte, dass die Funktion <code>internal_adder</code> nicht mit <code>pub</code> markiert ist, aber
da Tests nur Rust-Code sind und das Modul <code>tests</code> nur ein weiteres Modul ist,
kannst du <code>internal_adder</code> in den Gültigkeitsbereich eines Tests bringen und
sie aufrufen. Wenn du der Meinung bist, dass private Funktionen nicht getestet
werden sollten, gibt es in Rust nichts, was dich dazu zwingen würde.</p>
<h3><a class="header" href="#integrationstests" id="integrationstests">Integrationstests</a></h3>
<p>In Rust sind Integrationstests völlig außerhalb deiner Bibliothek angesiedelt.
Du verwendest deine Bibliothek auf die gleiche Weise wie jeder andere Code,
d.h. es können nur Funktionen aufgerufen werden, die Teil der öffentlichen
Programmierschnittstelle (API) deiner Bibliothek sind. Ihr Zweck ist es, zu
testen, ob viele Teile deiner Bibliothek korrekt zusammenarbeiten.
Code-Einheiten, die alleine korrekt funktionieren, könnten Probleme nach deren
Integration haben, daher ist auch die Testabdeckung des integrierten Codes
wichtig. Um Integrationstests zu erstellen, benötigst du zunächst ein
Verzeichnis <em>tests</em>.</p>
<h4><a class="header" href="#das-verzeichnis-tests" id="das-verzeichnis-tests">Das Verzeichnis <em>tests</em></a></h4>
<p>Wir erstellen ein Verzeichnis <em>tests</em> auf der obersten Ebene unseres
Projektverzeichnisses, neben <em>src</em>. Cargo weiß, dass es in diesem Verzeichnis
nach Integrationstestdateien suchen soll. Wir können dann in diesem Verzeichnis
so viele Testdateien erstellen, wie wir wollen, und Cargo wird jede dieser
Dateien als eine einzelne Kiste (crate) kompilieren.</p>
<p>Lass uns einen Integrationstest erstellen. Wenn sich der Code in Codeblock
11-12 noch in der Datei <em>src/lib.rs</em> befindet, erstelle ein Verzeichnis
<em>tests</em> und eine neue Datei mit dem Namen <em>tests/integration_test.rs</em> und gib
den Code aus Codeblock 11-13 ein.</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

#[test]
fn it_adds_two() {
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p><span class="caption">Codeblock 11-13: Integrationstest einer Funktion in der
Kiste <code>adder</code></span></p>
<p>Wir haben am Anfang des Codes <code>use adder;</code> angegeben, was wir bei Modultests
nicht brauchten. Der Grund dafür ist, dass jede Datei im Verzeichnis <code>tests</code>
eine separate Kiste ist, sodass wir unsere Bibliothek in den Gültigkeitsbereich
jeder Testkiste bringen müssen.</p>
<p>Wir brauchen den Code in <em>tests/integration_test.rs</em> nicht mit <code>#[cfg(test)]</code>
zu annotieren. Cargo behandelt das Verzeichnis <code>tests</code> speziell und kompiliert
Dateien in diesem Verzeichnis nur dann, wenn wir <code>cargo test</code> ausführen. Führe
<code>cargo test</code> jetzt aus:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.73s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Die drei Abschnitte der Ausgabe umfassen die Modultests, den Integrationstest
und die Dokumentationstests. Der erste Abschnitt für die Modultests ist
derselbe, wie wir ihn gesehen haben: Eine Zeile für jeden Modultest (eine Zeile
mit der Bezeichnung <code>internal</code>, die wir in Codeblock 11-12 hinzugefügt haben)
und dann eine zusammenfassende Zeile für die Modultests.</p>
<p>Der Abschnitt zu den Integrationstests beginnt mit der Zeile <code>Running target/debug/deps/integration_test-82e7799c1bc62298</code> (der Hashwert am Ende
deiner Ausgabe ist anders). Als nächstes kommt eine Zeile für jede Testfunktion
in diesem Integrationstest und eine Zusammenfassung für die Ergebnisse des
Integrationstests, kurz bevor der Abschnitt <code>Doc-tests adder</code> beginnt.</p>
<p>Ähnlich wie das Hinzufügen weiterer Modultestfunktionen zu mehr Ergebniszeilen
im Modultest-Abschnitt führt, führt das Hinzufügen weiterer Testfunktionen in
der Integrationstestdatei zu mehr Ergebniszeilen im Abschnitt zu dieser
Integrationstestdatei. Jede Integrationstestdatei hat ihren eigenen Abschnitt,
wenn wir also weitere Dateien im Verzeichnis <em>tests</em> hinzufügen, wird es mehr
Integrationstest-Abschnitte geben.</p>
<p>Wir können immer noch eine bestimmte Integrationstestfunktion ausführen, indem
wir den Namen der Testfunktion als Argument bei <code>cargo test</code> angeben. Um alle
Tests in einer bestimmten Integrationstestdatei auszuführen, verwenden bei
<code>cargo test</code> das Argument <code>--test</code>, gefolgt vom Namen der Datei:</p>
<pre><code class="language-console">$ cargo test --test integration_test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.64s
     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Dieses Kommando führt nur die Tests in der Datei <em>tests/integration_test.rs</em>
aus.</p>
<h4><a class="header" href="#teilmodule-in-integrationstests" id="teilmodule-in-integrationstests">Teilmodule in Integrationstests</a></h4>
<p>Wenn du weitere Integrationstests hinzufügst, möchtest du vielleicht mehr als
eine Datei im Verzeichnis <em>tests</em> erstellen, um sie besser organisieren zu
können; beispielsweise kannst du die Testfunktionen nach der Funktionalität
gruppieren, die sie testen. Wie bereits erwähnt, wird jede Datei im Verzeichnis
<em>tests</em> als eine separate Kiste kompiliert.</p>
<p>Jede Integrationstestdatei wie eine eigene Kiste zu behandeln, ist nützlich, um
separate Bereiche zu erstellen, die eher der Art und Weise entsprechen, wie
Endbenutzer deine Kiste verwenden werden. Das bedeutet jedoch, dass Dateien im
Verzeichnis <em>tests</em> nicht das gleiche Verhalten wie Dateien in <em>src</em> haben, wie
du in Kapitel 7 über die Trennung von Code in Module und Dateien gelernt hast.</p>
<p>Das unterschiedliche Verhalten von Dateien im Verzeichnis <em>tests</em> ist am
deutlichsten, wenn du eine Reihe Hilfsfunktionen hast, die bei mehreren
Integrationstestdateien nützlich wären, und du versuchst, die Schritte im
Abschnitt <a href="ch07-05-separating-modules-into-different-files.html">„Module in verschiedene Dateien
aufteilen“</a> in Kapitel 7 zu befolgen, um sie in
ein gemeinsames Modul zu extrahieren. Wenn wir zum Beispiel <em>tests/common.rs</em>
erstellen und eine Funktion namens <code>setup</code> darin platzieren, können wir <code>setup</code>
etwas Code hinzufügen, den wir von mehreren Testfunktionen in mehreren
Testdateien aufrufen wollen:</p>
<p><span class="filename">Filename: tests/common.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>pub fn setup() {
    // Vorbereitungscode speziell für die Tests deiner Bibliothek
}
<span class="boring">}
</span></code></pre></pre>
<p>Wenn wir die Tests erneut ausführen, werden wir für die Datei <em>common.rs</em> einen
neuen Abschnitt in der Testausgabe sehen, obwohl diese Datei keine
Testfunktionen enthält und wir die Funktion <code>setup</code> nicht von irgendwo
aufgerufen haben:</p>
<pre><code class="language-console">$ cargo test
   Compiling adder v0.1.0 (file:///projects/adder)
    Finished test [unoptimized + debuginfo] target(s) in 0.89s
     Running target/debug/deps/adder-92948b65e88960b4

running 1 test
test tests::internal ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/common-7064e1b6d2e271be

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

     Running target/debug/deps/integration_test-82e7799c1bc62298

running 1 test
test it_adds_two ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

   Doc-tests adder

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>Dass in den Testergebnissen <code>common</code> erscheint und dabei <code>running 0 tests</code>
angezeigt wird, ist nicht das, was wir wollten. Wir wollten nur etwas Code mit
den anderen Integrationstestdateien teilen.</p>
<p>Um zu vermeiden, dass <code>common</code> in der Testausgabe erscheint, werden wir statt
<em>tests/common.rs</em> die Datei <em>tests/common/mod.rs</em> erstellen. Dies ist eine
alternative Namenskonvention, die auch Rust versteht. Durch diese Benennung der
Datei wird Rust angewiesen, das Modul <code>common</code> nicht als Integrationstestdatei
zu behandeln. Wenn wir den Funktionscode <code>setup</code> in <em>tests/common/mod.rs</em>
verschieben und die Datei <em>tests/common.rs</em> löschen, erscheint der Abschnitt in
der Testausgabe nicht mehr. Dateien in Unterverzeichnissen des Verzeichnisses
<em>tests</em> werden nicht als separate Kisten kompiliert und erzeugen keine
Abschnitte in der Testausgabe.</p>
<p>Nachdem wir <em>tests/common/mod.rs</em> erstellt haben, können wir es von jeder der
Integrationstestdateien als Modul verwenden. Hier ist ein Beispiel für den
Aufruf der Funktion <code>setup</code> aus dem Test <code>it_adds_two</code> in
<em>tests/integration_test.rs</em>:</p>
<p><span class="filename">Filename: tests/integration_test.rs</span></p>
<pre><code class="language-rust ignore">use adder;

mod common;

#[test]
fn it_adds_two() {
    common::setup();
    assert_eq!(4, adder::add_two(2));
}
</code></pre>
<p>Beachte, dass die Deklaration <code>mod common;</code> die gleiche ist wie die
Moduldeklaration, die wir in Codeblock 7-21 gezeigt haben. In der Testfunktion
können wir dann die Funktion <code>common::setup()</code> aufrufen.</p>
<h4><a class="header" href="#integrationstests-für-binäre-kisten" id="integrationstests-für-binäre-kisten">Integrationstests für binäre Kisten</a></h4>
<p>Wenn unser Projekt eine binäre Kiste ist, die nur eine Datei <em>src/main.rs</em>
enthält und keine Datei <em>src/lib.rs</em>, können wir keine Integrationstests im
<em>tests</em>-Verzeichnis erstellen und Funktionen, die in der <em>src/main.rs</em>-Datei
definiert sind, mit einer <code>use</code>-Anweisung in den Gültigkeitsbereich bringen.
Nur Bibliothekskisten stellen Funktionen zur Verfügung, die auch von anderen
Kisten verwendet werden können; binäre Kisten sind für den eigenständigen
Betrieb gedacht.</p>
<p>Dies ist einer der Gründe, warum Rust-Projekte, die eine Binärdatei
bereitstellen, eine einfache <em>src/main.rs</em>-Datei haben, die Logik aufruft, die
in der <em>src/lib.rs</em>-Datei lebt. Unter Verwendung dieser Struktur können
Integrationstests die Bibliothekskiste mit <code>use</code> testen, um wichtige
Funktionalität verfügbar zu machen. Wenn die Hauptfunktionalität korrekt ist,
funktionieren auch die kleinen Codestücke in der Datei <em>src/main.rs</em>, und diese
kleinen Codestücke müssen nicht getestet werden.</p>
<h2><a class="header" href="#zusammenfassung-7" id="zusammenfassung-7">Zusammenfassung</a></h2>
<p>Die Testfunktionalitäten von Rust bieten eine Möglichkeit, zu spezifizieren,
wie der Code funktionieren soll, um sicherzustellen, dass er weiterhin so
funktioniert, wie du es erwartest, auch wenn du Änderungen vornimmst. Modultests prüfen
verschiedene Teile einer Bibliothek separat und können private
Implementierungsdetails testen. Integrationstests prüfen, ob viele Teile der
Bibliothek korrekt zusammenarbeiten, und sie verwenden die öffentliche
Programmierschnittstelle (API) der Bibliothek, um den Code auf die gleiche
Weise zu testen, wie externer Code ihn verwenden wird. Auch wenn das Typsystem
und die Eigentümerschaftsregeln von Rust dazu beitragen, einige Fehlerarten zu
verhindern, sind Tests immer noch wichtig, um Logikfehler zu reduzieren, die
damit zu tun haben, wie sich dein Code voraussichtlich verhalten wird.</p>
<p>Lass uns das Wissen, das du in diesem und in den vorhergehenden Kapiteln
gelernt hast, für die Arbeit an einem Projekt einsetzen!</p>
<h1><a class="header" href="#anhang" id="anhang">Anhang</a></h1>
<p>Die folgenden Abschnitte enthalten Referenzmaterial, das dir auf deiner
Rust-Reise nützlich sein könnten.</p>
<h2><a class="header" href="#anhang-a-schlüsselwörter" id="anhang-a-schlüsselwörter">Anhang A: Schlüsselwörter</a></h2>
<p>Die folgende Liste enthält Schlüsselwörter, die für die gegenwärtige oder
zukünftige Verwendung durch die Sprache Rust reserviert sind. Als solche können
sie nicht als Bezeichner verwendet werden (außer als Roh-Bezeichner, die wir im
Abschnitt <a href="appendix-01-keywords.html#roh-bezeichner">„Roh-Bezeichner“</a> besprechen werden),
einschließlich Namen von Funktionen, Variablen, Parametern, Strukturfeldern
(struct fields), Modulen, Kisten (crates), Konstanten, Makros, statischen
Werten, Attributen, Typen, Merkmalen (traits) und Lebensdauern (lifetimes).</p>
<h3><a class="header" href="#derzeit-verwendete-schlüsselwörter" id="derzeit-verwendete-schlüsselwörter">Derzeit verwendete Schlüsselwörter</a></h3>
<p>Die folgenden Schlüsselwörter haben derzeit die beschriebene Funktionalität.</p>
<ul>
<li><code>as</code> – primitive Typen umwandeln; ein spezifisches Merkmal mit einem
Element eindeutig machen; Elemente in <code>use</code>- und <code>extern crate</code>-Anweisungen
umbenennen </li>
<li><code>async</code> – ein <code>Future</code> zurückgeben, anstatt den aktuellen Strang
(thread) zu blockieren</li>
<li><code>await</code> – Ausführung anhalten, bis das Ergebnis eines <code>Future</code> vorliegt</li>
<li><code>break</code> – Schleife sofort verlassen</li>
<li><code>const</code> – konstante Elemente oder konstante Roh-Referenzen definieren</li>
<li><code>continue</code> – weiter zur nächsten Schleifeniteration</li>
<li><code>crate</code> – externe Kiste (crate) oder Makrovariable, die die Kiste
repräsentiert, in der das Makro definiert ist, verlinken</li>
<li><code>dyn</code> – dynamischer Aufruf (dispatch) eines Merkmalsobjekts (trait
object)</li>
<li><code>else</code> – Ersatzkontrollflusszweig bei <code>if</code> und <code>if let</code></li>
<li><code>enum</code> – eine Aufzählung (enumeration) definieren</li>
<li><code>extern</code> – externe Kiste (crate), Funktion oder Variable verlinken</li>
<li><code>false</code> – Boolesches Literal für „falsch“</li>
<li><code>fn</code> – Funktion oder Funktionsreferenztyp definieren</li>
<li><code>for</code> – wiederhole über Elemente einer Iteration; ein Merkmal (trait)
implementieren; eine höherrangige Lebensdauer angeben</li>
<li><code>if</code> – Verzweigen abhängig vom Ergebnis eines Bedingungsausdrucks</li>
<li><code>impl</code> – Implementieren einer inhärenten oder Merkmalsfunktionalität
(trait functionality)</li>
<li><code>in</code> – Teil der <code>for</code>-Schleifensyntax</li>
<li><code>let</code> – eine Variable binden</li>
<li><code>loop</code> – wiederhole bedingungslos</li>
<li><code>match</code> – einen Wert mit Muster abgleichen</li>
<li><code>mod</code> – ein Modul definieren</li>
<li><code>move</code> – Funktionsabschluss (closure) übernimmt Eigentümerschaft
(ownership) all seiner Parameter</li>
<li><code>mut</code> – Referenzen, Roh-Referenzen und Variablenbindungen als
veränderlich kennzeichnen</li>
<li><code>pub</code> – Strukturfelder (struct fields), <code>impl</code>-Blöcke und Module als
öffentlich sichtbar kennzeichnen </li>
<li><code>ref</code> – als Referenz binden</li>
<li><code>return</code> – aus Funktion zurückkehren</li>
<li><code>Self</code> – Typ-Alias für den zu definierenden oder implementierenden Typ</li>
<li><code>self</code> – Methoden-Instanzobjekt; aktuelles Modul</li>
<li><code>static</code> – globale Variable oder Lebensdauer während der gesamten
Programmausführung</li>
<li><code>struct</code> – eine Struktur definieren</li>
<li><code>super</code> – Elternmodul des aktuellen Moduls</li>
<li><code>trait</code> – ein Merkmal (trait) definieren</li>
<li><code>true</code> – Boolesches Literal für „wahr“</li>
<li><code>type</code> – einen Typ-Alias oder assoziierten Typ definieren</li>
<li><code>union</code> – eine <a href="https://doc.rust-lang.org/reference/items/unions.html">Vereinigung (union)</a> definieren; ist nur ein
Schlüsselwort innerhalb einer Vereinigungdeklaration</li>
<li><code>unsafe</code> – Code, Funktionen, Merkmale (traits) und Implementierungen
als unsicher kennzeichnen</li>
<li><code>use</code> – Symbole in den Gültigkeitsbereich bringen</li>
<li><code>where</code> – Klauseln zur Typabgrenzung angeben</li>
<li><code>while</code> – wiederhole abhängig vom Ergebnis eines Bedingungsausdrucks</li>
</ul>
<h3><a class="header" href="#schlüsselwörter-reserviert-für-zukünftige-verwendung" id="schlüsselwörter-reserviert-für-zukünftige-verwendung">Schlüsselwörter reserviert für zukünftige Verwendung</a></h3>
<p>Die folgenden Schlüsselwörter haben keine Funktionalität, sondern sind von Rust
für eine mögliche zukünftige Verwendung reserviert.</p>
<ul>
<li><code>abstract</code></li>
<li><code>become</code></li>
<li><code>box</code></li>
<li><code>do</code></li>
<li><code>final</code></li>
<li><code>macro</code></li>
<li><code>override</code></li>
<li><code>priv</code></li>
<li><code>try</code></li>
<li><code>typeof</code></li>
<li><code>unsized</code></li>
<li><code>virtual</code></li>
<li><code>yield</code></li>
</ul>
<h3><a class="header" href="#roh-bezeichner" id="roh-bezeichner">Roh-Bezeichner</a></h3>
<p><em>Roh-Bezeichner</em> (raw identifiers) sind eine Syntax, die es dir ermöglicht,
Schlüsselwörter dort zu verwenden, wo sie normalerweise nicht erlaubt wären. Du
verwendest einen Roh-Bezeichner, indem du einem Schlüsselwort das Präfix <code>r#</code>
voranstellst.</p>
<p>Zum Beispiel ist <code>match</code> ein Schlüsselwort. Versuche, folgende Funktion zu
kompilieren, die <code>match</code> als Namen benutzt:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust does_not_compile">
<span class="boring">#![allow(unused_variables)]
</span><span class="boring">fn main() {
</span>fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}
<span class="boring">}
</span></code></pre></pre>
<p>Dann erhältst du diesen Fehler:</p>
<pre><code class="language-text">error: expected identifier, found keyword `match`
 --&gt; src/main.rs:4:4
  |
4 | fn match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
  |    ^^^^^ expected identifier, found keyword
</code></pre>
<p>Der Fehler zeigt, dass du das Schlüsselwort <code>match</code> nicht als
Funktionsbezeichner verwenden kannst. Um <code>match</code> als Funktionsnamen zu
verwenden, musst du die Syntax für Roh-Bezeichner wie folgt verwenden:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn r#match(needle: &amp;str, haystack: &amp;str) -&gt; bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match(&quot;foo&quot;, &quot;foobar&quot;));
}
</code></pre></pre>
<p>Dieser Code lässt sich fehlerfrei kompilieren. Beachte das <code>r#</code>-Präfix im
Funktionsnamen in seiner Definition sowie an der Stelle, an der die Funktion in
<code>main</code> aufgerufen wird.</p>
<p>Roh-Bezeichner erlauben es dir, jedes beliebige Wort als Bezeichner zu
verwenden, auch wenn dieses Wort ein reserviertes Schlüsselwort ist. Darüber
hinaus ermöglicht dir der Roh-Bezeichner das Verwenden von Bibliotheken, die in
einer anderen Rust-Ausgabe, als deine Kiste verwendet, geschrieben wurden. Zum
Beispiel ist <code>try</code> in Ausgabe 2015 kein Schlüsselwort, aber in Ausgabe 2018
schon. Wenn du auf eine Bibliothek angewiesen bist, die mit Ausgabe 2015
geschrieben wurde und eine Funktion <code>try</code> hat, musst du die
Roh-Bezeichner-Syntax verwenden, in diesem Fall <code>r#try</code>, um diese Funktion von
deinem Code der Ausgabe 2018 aus aufzurufen. Siehe <a href="appendix-05-editions.html">Anhang E</a> für
weitere Informationen zu Ausgaben.</p>
<h2><a class="header" href="#anhang-b-operatoren-und-symbole" id="anhang-b-operatoren-und-symbole">Anhang B: Operatoren und Symbole</a></h2>
<p>Dieser Anhang enthält ein Glossar der Rust-Syntax, einschließlich Operatoren
und anderer Symbole, die allein oder im Zusammenhang mit Pfaden, generischen
Datentypen (generics), Merkmalsabgrenzungen (trait bounds), Makros, Attributen,
Kommentaren, Tupeln und Klammern auftreten.</p>
<h3><a class="header" href="#operatoren" id="operatoren">Operatoren</a></h3>
<p>Tabelle B-1 enthält die Operatoren in Rust, ein Beispiel, wie der Operator im
Kontext erscheinen würde, eine kurze Erklärung und ob dieser Operator überladen
werden kann. Wenn ein Operator überladen werden kann, wird das relevante
Merkmal (trait) aufgeführt, mit dem dieser Operator überladen werden kann.</p>
<p><span class="caption">Tabelle B-1: Operatoren</span></p>
<table><thead><tr><th align="left">Operator</th><th align="left">Beispiel</th><th align="left">Erklärung</th><th align="left">Überladbar?</th></tr></thead><tbody>
<tr><td align="left"><code>!</code></td><td align="left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td align="left">Makro-Expansion</td><td align="left"></td></tr>
<tr><td align="left"><code>!</code></td><td align="left"><code>!expr</code></td><td align="left">Bitweises oder logisches Komplement</td><td align="left"><code>Not</code></td></tr>
<tr><td align="left"><code>!=</code></td><td align="left"><code>var != expr</code></td><td align="left">Vergleich auf Ungleichheit</td><td align="left"><code>PartialEq</code></td></tr>
<tr><td align="left"><code>%</code></td><td align="left"><code>expr % expr</code></td><td align="left">Arithmetischer Restbetrag</td><td align="left"><code>Rem</code></td></tr>
<tr><td align="left"><code>%=</code></td><td align="left"><code>var %= expr</code></td><td align="left">Arithmetischer Restbetrag und Zuweisung</td><td align="left"><code>RemAssign</code></td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left"><code>&amp;expr</code>,<br> <code>&amp;mut expr</code></td><td align="left">Ausleihe</td><td align="left"></td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left"><code>&amp;type</code>,<br> <code>&amp;mut type</code>,<br> <code>&amp;'a type</code>,<br> <code>&amp;'a mut type</code></td><td align="left">Ausleih-Referenz-Typ</td><td align="left"></td></tr>
<tr><td align="left"><code>&amp;</code></td><td align="left"><code>expr &amp; expr</code></td><td align="left">Bitweises UND</td><td align="left"><code>BitAnd</code></td></tr>
<tr><td align="left"><code>&amp;=</code></td><td align="left"><code>var &amp;= expr</code></td><td align="left">Bitweises UND und Zuweisung</td><td align="left"><code>BitAndAssign</code></td></tr>
<tr><td align="left"><code>&amp;&amp;</code></td><td align="left"><code>expr &amp;&amp; expr</code></td><td align="left">Logisches UND mit Kurzschlussauswertung</td><td align="left"></td></tr>
<tr><td align="left"><code>*</code></td><td align="left"><code>expr * expr</code></td><td align="left">Arithmetische Multiplikation</td><td align="left"><code>Mul</code></td></tr>
<tr><td align="left"><code>*=</code></td><td align="left"><code>var *= expr</code></td><td align="left">Arithmetische Multiplikation und Zuweisung</td><td align="left"><code>MulAssign</code></td></tr>
<tr><td align="left"><code>*</code></td><td align="left"><code>*expr</code></td><td align="left">Dereferenzierung</td><td align="left"></td></tr>
<tr><td align="left"><code>*</code></td><td align="left"><code>*const type</code>,<br> <code>*mut type</code></td><td align="left">Roh-Referenz</td><td align="left"></td></tr>
<tr><td align="left"><code>+</code></td><td align="left"><code>trait + trait</code>,<br> <code>'a + trait</code></td><td align="left">Verbundtypabgrenzung</td><td align="left"></td></tr>
<tr><td align="left"><code>+</code></td><td align="left"><code>expr + expr</code></td><td align="left">Arithmetische Addition</td><td align="left"><code>Add</code></td></tr>
<tr><td align="left"><code>+=</code></td><td align="left"><code>var += expr</code></td><td align="left">Arithmetische Addition und Zuweisung</td><td align="left"><code>AddAssign</code></td></tr>
<tr><td align="left"><code>,</code></td><td align="left"><code>expr, expr</code></td><td align="left">Argument- und Elementseparator</td><td align="left"></td></tr>
<tr><td align="left"><code>-</code></td><td align="left"><code>- expr</code></td><td align="left">Arithmetische Negation</td><td align="left"><code>Neg</code></td></tr>
<tr><td align="left"><code>-</code></td><td align="left"><code>expr - expr</code></td><td align="left">Arithmetische Subtraktion</td><td align="left"><code>Sub</code></td></tr>
<tr><td align="left"><code>-=</code></td><td align="left"><code>var -= expr</code></td><td align="left">Arithmetische Subtraktion und Zuweisung</td><td align="left"><code>SubAssign</code></td></tr>
<tr><td align="left"><code>-&gt;</code></td><td align="left"><code>fn(...) -&gt; type</code>,<br> <code>|...| -&gt; type</code></td><td align="left">Funktion und Funktionsabschlussrückgabetyp</td><td align="left"></td></tr>
<tr><td align="left"><code>.</code></td><td align="left"><code>expr.ident</code></td><td align="left">Elementzugriff</td><td align="left"></td></tr>
<tr><td align="left"><code>..</code></td><td align="left"><code>..</code>,<br> <code>expr..</code>,<br> <code>..expr</code>,<br> <code>expr..expr</code></td><td align="left">Rechts-ausschließendes Bereichsliteral</td><td align="left"></td></tr>
<tr><td align="left"><code>..=</code></td><td align="left"><code>..=expr</code>,<br> <code>expr..=expr</code></td><td align="left">Rechts-einschließendes Bereichsliteral</td><td align="left"></td></tr>
<tr><td align="left"><code>..</code></td><td align="left"><code>..expr</code></td><td align="left">Aktualisierungssyntax für Strukturliterale</td><td align="left"></td></tr>
<tr><td align="left"><code>..</code></td><td align="left"><code>variant(x, ..)</code>,<br> <code>struct_type { x, .. }</code></td><td align="left">„Und der Rest“-Musterbindung</td><td align="left"></td></tr>
<tr><td align="left"><code>...</code></td><td align="left"><code>expr...expr</code></td><td align="left">In einem Muster: inklusives Bereichsmuster</td><td align="left"></td></tr>
<tr><td align="left"><code>/</code></td><td align="left"><code>expr / expr</code></td><td align="left">Arithmetische Division</td><td align="left"><code>Div</code></td></tr>
<tr><td align="left"><code>/=</code></td><td align="left"><code>var /= expr</code></td><td align="left">Arithmetische Division und Zuweisung</td><td align="left"><code>DivAssign</code></td></tr>
<tr><td align="left"><code>:</code></td><td align="left"><code>pat: type</code>,<br> <code>ident: type</code></td><td align="left">Typabgrenzung</td><td align="left"></td></tr>
<tr><td align="left"><code>:</code></td><td align="left"><code>ident: expr</code></td><td align="left">Struktur-Feld-Initialisierer</td><td align="left"></td></tr>
<tr><td align="left"><code>:</code></td><td align="left"><code>'a: loop {...}</code></td><td align="left">Schleifen-Label</td><td align="left"></td></tr>
<tr><td align="left"><code>;</code></td><td align="left"><code>expr;</code></td><td align="left">Anweisungs- und Element-Endezeichen</td><td align="left"></td></tr>
<tr><td align="left"><code>;</code></td><td align="left"><code>[...; len]</code></td><td align="left">Syntaxteil für Array fester Größe</td><td align="left"></td></tr>
<tr><td align="left"><code>&lt;&lt;</code></td><td align="left"><code>expr &lt;&lt; expr</code></td><td align="left">Bitweise Links-Schiebung</td><td align="left"><code>Shl</code></td></tr>
<tr><td align="left"><code>&lt;&lt;=</code></td><td align="left"><code>var &lt;&lt;= expr</code></td><td align="left">Bitweise Links-Schiebung und Zuweisung</td><td align="left"><code>ShlAssign</code></td></tr>
<tr><td align="left"><code>&lt;</code></td><td align="left"><code>expr &lt; expr</code></td><td align="left">Kleiner-als-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>&lt;=</code></td><td align="left"><code>expr &lt;= expr</code></td><td align="left">Kleiner-gleich-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>=</code></td><td align="left"><code>var = expr</code>,<br> <code>ident = type</code></td><td align="left">Zuweisung/Äquivalenz</td><td align="left"></td></tr>
<tr><td align="left"><code>==</code></td><td align="left"><code>expr == expr</code></td><td align="left">Gleichheitsvergleich</td><td align="left"><code>PartialEq</code></td></tr>
<tr><td align="left"><code>=&gt;</code></td><td align="left"><code>pat =&gt; expr</code></td><td align="left">Teilsyntax im Abgleichs-Zweig (match arm)</td><td align="left"></td></tr>
<tr><td align="left"><code>&gt;</code></td><td align="left"><code>expr &gt; expr</code></td><td align="left">Größer-als-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>&gt;=</code></td><td align="left"><code>expr &gt;= expr</code></td><td align="left">Größer-gleich-Vergleich</td><td align="left"><code>PartialOrd</code></td></tr>
<tr><td align="left"><code>&gt;&gt;</code></td><td align="left"><code>expr &gt;&gt; expr</code></td><td align="left">Bitweise Rechts-Schiebung</td><td align="left"><code>Shr</code></td></tr>
<tr><td align="left"><code>&gt;&gt;=</code></td><td align="left"><code>var &gt;&gt;= expr</code></td><td align="left">Bitweise Rechts-Schiebung und Zuweisung</td><td align="left"><code>ShrAssign</code></td></tr>
<tr><td align="left"><code>@</code></td><td align="left"><code>ident @ pat</code></td><td align="left">Muster-Bindung</td><td align="left"></td></tr>
<tr><td align="left"><code>^</code></td><td align="left"><code>expr ^ expr</code></td><td align="left">Bitweises exklusives ODER</td><td align="left"><code>BitXor</code></td></tr>
<tr><td align="left"><code>^=</code></td><td align="left"><code>var ^= expr</code></td><td align="left">Bitweises exklusives ODER und Zuweisung</td><td align="left"><code>BitXorAssign</code></td></tr>
<tr><td align="left"><code>|</code></td><td align="left"><code>pat | pat</code></td><td align="left">Muster-Alternativen</td><td align="left"></td></tr>
<tr><td align="left"><code>|</code></td><td align="left"><code>expr | expr</code></td><td align="left">Bitweises ODER</td><td align="left"><code>BitOr</code></td></tr>
<tr><td align="left"><code>|=</code></td><td align="left"><code>var |= expr</code></td><td align="left">Bitweises ODER und Zuweisung</td><td align="left"><code>BitOrAssign</code></td></tr>
<tr><td align="left"><code>||</code></td><td align="left"><code>expr || expr</code></td><td align="left">Logisches ODER mit Kurzschlussauswertung</td><td align="left"></td></tr>
<tr><td align="left"><code>?</code></td><td align="left"><code>expr?</code></td><td align="left">Fehler-Weitergabe</td><td align="left"></td></tr>
</tbody></table>
<h3><a class="header" href="#nicht-operator-symbole" id="nicht-operator-symbole">Nicht-Operator-Symbole</a></h3>
<p>Die folgende Liste enthält alle nicht-Buchstaben, die nicht als Operatoren
fungieren, d.h. sich nicht wie ein Funktions- oder Methodenaufruf verhalten.</p>
<p>Tabelle B-2 zeigt Symbole, die für sich allein stehen und an verschiedenen
Stellen gültig sind.</p>
<p><span class="caption">Tabelle B-2: Eigenständige Syntax</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>'ident</code></td><td align="left">Benannte Lebensdauer oder Schleifenbeschriftung</td></tr>
<tr><td align="left"><code>...u8</code>,<br> <code>...i32</code>,<br> <code>...f64</code>,<br> <code>...usize</code><br> usw.</td><td align="left">Numerisches Literal eines bestimmten Typs</td></tr>
<tr><td align="left"><code>&quot;...&quot;</code></td><td align="left">Zeichenketten-Literal</td></tr>
<tr><td align="left"><code>r&quot;...&quot;</code>,<br> <code>r#&quot;...&quot;#</code>,<br> <code>r##&quot;...&quot;##</code><br> usw.</td><td align="left">Roh-Zeichenketten-Literal, Escape-Zeichen werden nicht verarbeitet</td></tr>
<tr><td align="left"><code>b&quot;...&quot;</code></td><td align="left">Byte-Zeichenkettenliteral, konstruiert ein <code>[u8]</code> anstelle einer Zeichenkette</td></tr>
<tr><td align="left"><code>br&quot;...&quot;</code>,<br> <code>br#&quot;...&quot;#</code>,<br> <code>br##&quot;...&quot;##</code><br> usw.</td><td align="left">Roh-Byte-Zeichenkettenliteral, Kombination aus Roh- und Byte-Zeichenkettenliteral</td></tr>
<tr><td align="left"><code>'...'</code></td><td align="left">Zeichen-Literal</td></tr>
<tr><td align="left"><code>b'...'</code></td><td align="left">ASCII-Byte-Literal</td></tr>
<tr><td align="left"><code>|...| expr</code></td><td align="left">Funktionsabschluss (closure)</td></tr>
<tr><td align="left"><code>!</code></td><td align="left">Leerer Typ (bottom type) für nicht-endende Funktionen</td></tr>
<tr><td align="left"><code>_</code></td><td align="left">Musterbindung für „sonstige“; wird auch verwendet, um Ganzzahl-Literale lesbar zu machen</td></tr>
</tbody></table>
<p>Tabelle B-3 zeigt Symbole, die im Zusammenhang mit Pfaden für die
Modulhierarchie eines Elements vorkommen.</p>
<p><span class="caption">Tabelle B-3: Pfad-bezogene Syntax</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>ident::ident</code></td><td align="left">Namensraum-Pfad</td></tr>
<tr><td align="left"><code>::path</code></td><td align="left">Pfad relativ zur Kistenwurzel<br> (d.h. ein explizit absoluter Pfad)</td></tr>
<tr><td align="left"><code>self::path</code></td><td align="left">Pfad relativ zum aktuellen Modul<br> (d.h. ein explizit relativer Pfad)</td></tr>
<tr><td align="left"><code>super::path</code></td><td align="left">Pfad relativ zum Elternmodul</td></tr>
<tr><td align="left"><code>type::ident</code>,<br> <code>&lt;type as trait&gt;::ident</code></td><td align="left">Zugehörige Konstanten, Funktionen<br> und Typen</td></tr>
<tr><td align="left"><code>&lt;type&gt;::...</code></td><td align="left">Zugehöriges Element für einen Typ,<br> der nicht direkt benannt werden kann<br> (z.B. <code>&lt;&amp;T&gt;::...</code>, <code>&lt;[T]&gt;:::...</code> usw.)</td></tr>
<tr><td align="left"><code>trait::method(...)</code></td><td align="left">Methodenaufruf durch Angeben des<br> Merkmals eindeutig machen</td></tr>
<tr><td align="left"><code>type::method(...)</code></td><td align="left">Methodenaufruf durch Angeben des<br> Typs eindeutig machen</td></tr>
<tr><td align="left"><code>&lt;type as trait&gt;::method(...)</code></td><td align="left">Methodenaufruf durch Angeben des<br> Merkmals und Typs eindeutig machen</td></tr>
</tbody></table>
<p>Tabelle B-4 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
auftreten.</p>
<p><span class="caption">Tabelle B-4: Generische Datentypen</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>path&lt;...&gt;</code></td><td align="left">Spezifiziert Parameter zum generischen Typ in einem Typ<br> (z.B. <code>Vec&lt;u8&gt;</code>)</td></tr>
<tr><td align="left"><code>path::&lt;...&gt;</code>,<br> <code>method::&lt;...&gt;</code></td><td align="left">Spezifiziert Parameter zu einem generischen Typ,<br> einer Funktion oder Methode in einem Ausdruck;<br> oft als „turbofish“ bezeichnet (z.B. <code>&quot;42&quot;.parse::&lt;i32&gt;()</code>)</td></tr>
<tr><td align="left"><code>fn ident&lt;...&gt; ...</code></td><td align="left">Generische Funktion definieren</td></tr>
<tr><td align="left"><code>struct ident&lt;...&gt; ...</code></td><td align="left">Generische Struktur definieren</td></tr>
<tr><td align="left"><code>enum ident&lt;...&gt; ...</code></td><td align="left">Generische Aufzählung definieren</td></tr>
<tr><td align="left"><code>impl&lt;...&gt; ...</code></td><td align="left">Generische Implementierung definieren</td></tr>
<tr><td align="left"><code>for&lt;...&gt; type</code></td><td align="left">Höherstufige Lebensdauerbegrenzungen</td></tr>
<tr><td align="left"><code>type&lt;ident=type&gt;</code></td><td align="left">Generischer Typ, bei dem ein oder mehrere assoziierte<br> Typen bestimmte Zuordnungen haben<br> (z.B. <code>Iterator&lt;Item=T&gt;</code>)</td></tr>
</tbody></table>
<p>Tabelle B-5 zeigt Symbole, die im Zusammenhang mit generischen Typparametern
mit Merkmalsabgrenzung (trait bounds) auftreten.</p>
<p><span class="caption">Tabelle B-5: Merkmalsabgrenzungen</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>T: U</code></td><td align="left">Generischer Parameter <code>T</code>, beschränkt auf Typen,<br> die <code>U</code> implementieren</td></tr>
<tr><td align="left"><code>T: 'a</code></td><td align="left">Generischer Typ <code>T</code>, der die Lebensdauer <code>'a</code> überdauert<br> (d.h. der Typ darf transitiv keine Referenzen mit einer<br> kürzeren Lebensdauer als <code>'a</code> enthalten)</td></tr>
<tr><td align="left"><code>T : 'static</code></td><td align="left">Generischer Typ <code>T</code> mit Lebensdauer <code>'static</code></td></tr>
<tr><td align="left"><code>'b: 'a</code></td><td align="left">Generische Lebensdauer <code>'b</code>, muss Lebensdauer <code>'a</code> überdauern</td></tr>
<tr><td align="left"><code>T: ?Sized</code></td><td align="left">Erlaube einen generischen Typparameter, der ein<br> dynamisch dimensionierter Typ ist</td></tr>
<tr><td align="left"><code>'a + trait</code>,<br> <code>trait + trait</code></td><td align="left">Zusammengesetzte Typabgrenzung</td></tr>
</tbody></table>
<p>Tabelle B-6 zeigt Symbole, die im Zusammenhang mit dem Aufruf oder der
Definition von Makros und der Angabe von Attributen an einem Element
vorkommen.</p>
<p><span class="caption">Tabelle B-6: Makros und Attribute</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>#[meta]</code></td><td align="left">Äußeres Attribut</td></tr>
<tr><td align="left"><code>#![meta]</code></td><td align="left">Inneres Attribut</td></tr>
<tr><td align="left"><code>$ident</code></td><td align="left">Makro-Ersetzung</td></tr>
<tr><td align="left"><code>$ident:kind</code></td><td align="left">Makro-Erfassung</td></tr>
<tr><td align="left"><code>$(…)…</code></td><td align="left">Makro-Wiederholung</td></tr>
<tr><td align="left"><code>ident!(...)</code>,<br> <code>ident!{...}</code>,<br> <code>ident![...]</code></td><td align="left">Makro-Aufruf</td></tr>
</tbody></table>
<p>Tabelle B-7 zeigt Symbole, die Kommentare erzeugen.</p>
<p><span class="caption">Tabelle B-7: Kommentare</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>//</code></td><td align="left">Einzeiliger Kommentar</td></tr>
<tr><td align="left"><code>//!</code></td><td align="left">Einzeiliger Dokumentationskommentar innen</td></tr>
<tr><td align="left"><code>///</code></td><td align="left">Einzeiliger Dokumentationskommentar außen</td></tr>
<tr><td align="left"><code>/*...*/</code></td><td align="left">Block-Kommentar</td></tr>
<tr><td align="left"><code>/*!...*/</code></td><td align="left">Mehrzeiliger Dokumentationskommentar innen</td></tr>
<tr><td align="left"><code>/**...*/</code></td><td align="left">Mehrzeiliger Dokumentationskommentar außen</td></tr>
</tbody></table>
<p>Tabelle B-8 zeigt Symbole, die im Zusammenhang mit der Verwendung von Tupeln
auftreten.</p>
<p><span class="caption">Tabelle B-8: Tupel</span></p>
<table><thead><tr><th align="left">Symbol</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>()</code></td><td align="left">Leeres Tupel (auch Einheit (unit) genannt), Literal und Typ</td></tr>
<tr><td align="left"><code>(expr)</code></td><td align="left">Eingeklammerter Ausdruck</td></tr>
<tr><td align="left"><code>(expr,)</code></td><td align="left">Ein-Element-Tupel-Ausdruck</td></tr>
<tr><td align="left"><code>(type,)</code></td><td align="left">Ein-Element-Tupel-Typ</td></tr>
<tr><td align="left"><code>(expr, ...)</code></td><td align="left">Tupel-Ausdruck</td></tr>
<tr><td align="left"><code>(type, ...)</code></td><td align="left">Tupel-Typ</td></tr>
<tr><td align="left"><code>expr(expr, ...)</code></td><td align="left">Funktionsaufruf-Ausdruck; wird auch zur Initialisierung von<br> Tupel-Strukturen und Tupel-Aufzählungs-Varianten verwendet</td></tr>
<tr><td align="left"><code>expr.0</code>,<br> <code>expr.1</code> usw.</td><td align="left">Tupel-Indexierung</td></tr>
</tbody></table>
<p>Tabelle B-9 zeigt die Kontexte, in denen geschweifte Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-9: Geschweifte Klammern</span></p>
<table><thead><tr><th align="left">Context</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>{...}</code></td><td align="left">Block-Ausdruck</td></tr>
<tr><td align="left"><code>Type {...}</code></td><td align="left"><code>struct</code>-Literal</td></tr>
</tbody></table>
<p>Tabelle B-10 zeigt die Kontexte, in denen eckige Klammern verwendet werden.</p>
<p><span class="caption">Tabelle B-10: Eckige Klammern</span></p>
<table><thead><tr><th align="left">Context</th><th align="left">Erklärung</th></tr></thead><tbody>
<tr><td align="left"><code>[...]</code></td><td align="left">Array-Literal</td></tr>
<tr><td align="left"><code>[expr; len]</code></td><td align="left">Array-Literal mit <code>len</code> Kopien von <code>expr</code></td></tr>
<tr><td align="left"><code>[type; len]</code></td><td align="left">Array-Typ mit <code>len</code> Instanzen von <code>type</code></td></tr>
<tr><td align="left"><code>expr[expr]</code></td><td align="left">Sammlungs-Indexierung, ist überladbar (<code>Index</code>, <code>IndexMut</code>)</td></tr>
<tr><td align="left"><code>expr[..]</code>,<br> <code>expr[a..]</code>,<br> <code>expr[..b]</code>,<br> <code>expr[a..b]</code></td><td align="left">Sammlungs-Indexierung, die wie ein Sammlungsanteil aussieht,<br> unter Verwendung von <code>Range</code>, <code>RangeFrom</code>, <code>RangeTo</code> oder<br> <code>RangeFull</code> als „Index“</td></tr>
</tbody></table>
<h2><a class="header" href="#anhang-c-ableitbare-merkmale-traits" id="anhang-c-ableitbare-merkmale-traits">Anhang C: Ableitbare Merkmale (traits)</a></h2>
<p>An verschiedenen Stellen im Buch haben wir das Attribut <code>derive</code> besprochen,
das du auf eine Struktur- oder Aufzählungsdefinition anwenden kannst. Das
Attribut <code>derive</code> generiert Code, der ein Merkmal (trait) mit seiner eigenen
Standard-Implementierung auf dem Typ implementiert, den du mit der
<code>derive</code>-Syntax annotiert hast.</p>
<p>In diesem Anhang findest du eine Referenz aller Merkmale in der
Standardbibliothek, die du mit <code>derive</code> verwenden kannst. Jeder Abschnitt
umfasst:</p>
<ul>
<li>Welche Operatoren und Methoden nach Ableiten dieses Merkmals ermöglicht
werden</li>
<li>Was die Implementierung des durch <code>derive</code> bereitgestellten Merkmals bewirkt</li>
<li>Was die Implementierung des Merkmals über den Typ aussagt</li>
<li>Die Bedingungen, unter denen du das Merkmal implementieren darfst oder nicht</li>
<li>Beispiele für Operationen, die dieses Merkmal erfordern</li>
</ul>
<p>Wenn du ein anderes Verhalten wünschst als das, das durch das Attribut <code>derive</code>
bereitgestellt wird, schaue in die <a href="https://doc.rust-lang.org/std/index.html">Standard-Bibliotheksdokumentation</a>
zu den Merkmalen, um zu erfahren, wie sie manuell implementiert werden können.</p>
<p>Der Rest der in der Standardbibliothek definierten Merkmale kann bei deinen
Typen nicht mit <code>derive</code> implementiert werden. Diese Merkmale haben kein
wahrnehmbares Standardverhalten, es liegt also an dir, sie so zu
implementieren, dass sie für das, was du erreichen willst, sinnvoll sind.</p>
<p>Ein Beispiel für ein Merkmal, das nicht abgeleitet werden kann, ist <code>Display</code>,
das die Formatierung für Endbenutzer übernimmt. Du solltest immer eine
geeignete Art und Weise in Betracht ziehen, einen Typ für einen Endbenutzer
anzuzeigen. Welche Teile des Typs sollte ein Endbenutzer sehen dürfen? Welche
Teile würden sie für relevant halten? Welches Datenformat wäre für sie am
relevantesten? Der Rust-Kompilierer verfügt nicht über dieses Wissen, sodass er
kein angemessenes Standardverhalten für dich bereitstellen kann.</p>
<p>Die Liste der ableitbaren Merkmale in diesem Anhang ist nicht vollständig:
Bibliotheken können <code>derive</code> für ihre eigenen Merkmale implementieren, sodass
die Liste der Merkmale, die du mit <code>derive</code> verwenden kannst, wahrlich
unbegrenzt ist. Das Implementieren von <code>derive</code> verwendet ein prozedurales
Makro, das im Abschnitt <a href="ch19-06-macros.html">„Makros“</a> in Kapitel 19 behandelt wird.</p>
<h3><a class="header" href="#debug-für-die-programmierer-ausgabe" id="debug-für-die-programmierer-ausgabe"><code>Debug</code> für die Programmierer-Ausgabe</a></h3>
<p>Das Merkmal <code>Debug</code> ermöglicht das Debuggen von Formatierungen in
Formatierungszeichenketten, die du durch Angeben von <code>:?</code> innerhalb Platzhalter
<code>{}</code> angibst.</p>
<p>Das Merkmal <code>Debug</code> erlaubt es dir, Instanzen eines Typs zu Debugging-Zwecken
auszugeben, sodass du und andere Programmierer, die deinen Typ verwenden, eine
Instanz zu einem bestimmten Zeitpunkt der Programmausführung untersuchen
können.</p>
<p>Das Merkmal <code>Debug</code> ist beispielsweise beim Verwenden des Makros <code>assert_eq!</code>
erforderlich. Dieses Makro gibt die Werte der Instanzen, die als Argumente
angegeben wurden, aus, wenn die Gleichheitszusicherung fehlschlägt, damit
Programmierer sehen können, warum die beiden Instanzen nicht gleich waren.</p>
<h3><a class="header" href="#partialeq-und-eq-für-gleichheitsvergleiche" id="partialeq-und-eq-für-gleichheitsvergleiche"><code>PartialEq</code> und <code>Eq</code> für Gleichheitsvergleiche</a></h3>
<p>Das Merkmal <code>PartialEq</code> erlaubt dir, Instanzen eines Typs auf Gleichheit zu
prüfen und ermöglicht das Verwenden der Operatoren <code>==</code> und <code>!=</code>.</p>
<p>Das Ableiten von <code>PartialEq</code> implementiert die Methode <code>eq</code>. Wenn <code>PartialEq</code>
für Strukturen abgeleitet wird, sind zwei Instanzen nur dann gleich, wenn
<em>alle</em> Felder gleich sind, und die Instanzen sind nicht gleich, wenn wenigstens
ein Feld nicht gleich ist. Beim Ableiten für Aufzählungen ist jede Variante
gleich sich selbst und nicht gleich den anderen Varianten.</p>
<p>Das Merkmal <code>PartialEq</code> ist beispielsweise beim Verwenden des Makros
<code>assert_eq!</code> erforderlich, das in der Lage sein muss, zwei Instanzen eines Typs
auf Gleichheit zu prüfen.</p>
<p>Das Merkmal <code>Eq</code> hat keine Methoden. Sein Zweck ist es, zu signalisieren, dass
für jeden Wert des annotierten Typs der Wert gleich sich selbst ist. Das
Merkmal <code>Eq</code> kann nur auf Typen angewandt werden, die auch <code>PartialEq</code>
implementieren, obwohl nicht alle Typen, die <code>PartialEq</code> implementieren, <code>Eq</code>
implementieren können. Ein Beispiel dafür sind Fließkomma-Zahlentypen: Die
Implementierung von Fließkomma-Zahlen besagt, dass zwei Instanzen des
Keine-Zahl-Wertes (<code>NaN</code>) nicht gleichwertig sind.</p>
<p>Ein Beispiel dafür, wann <code>Eq</code> erforderlich ist, ist für Schlüssel in einer
<code>HashMap&lt;K, V&gt;</code>, damit <code>HashMap&lt;K, V&gt;</code> erkennen kann, ob zwei Schlüssel gleich
sind.</p>
<h3><a class="header" href="#partialord-und-ord-für-sortiervergleiche" id="partialord-und-ord-für-sortiervergleiche"><code>PartialOrd</code> und <code>Ord</code> für Sortiervergleiche</a></h3>
<p>Das Merkmal <code>PartialOrd</code> erlaubt dir, Instanzen eines Typs zum Sortieren zu
vergleichen. Ein Typ, der <code>PartialOrd</code> implementiert, kann mit den Operatoren
<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code> und <code>&gt;=</code> verwendet werden. Du kannst das Merkmal <code>PartialOrd</code>
nur auf Typen anwenden, die auch <code>PartialEq</code> implementieren.</p>
<p>Das Ableiten von <code>PartialOrd</code> implementiert die Methode <code>partial_cmp</code>, die eine
<code>Option&lt;Ordering&gt;</code> zurückgibt, die <code>None</code> ist, wenn die angegebenen Werte nicht
vergleichbar sind. Ein Beispiel für einen Wert, der nicht vergleichbar ist,
obwohl die meisten Werte dieses Typs verglichen werden können, ist die
Fließkommazahl <code>NaN</code>. Der Aufruf von <code>partial_cmp</code> mit einer beliebigen
Fließkommazahl und dem Fließkommawert <code>NaN</code> ergibt <code>None</code>.</p>
<p>Beim Ableiten auf Strukturen vergleicht <code>PartialOrd</code> zwei Instanzen, indem es
den Wert in jedem Feld in der Reihenfolge vergleicht, in der die Felder in der
Strukturdefinition erscheinen. Beim Ableiten auf Aufzählungen werden Varianten,
die in der Aufzählungsdefinition früher deklariert sind, als kleiner als die
später aufgeführten Varianten betrachtet.</p>
<p>Das Merkmal <code>PartialOrd</code> ist z.B. für die Methode <code>gen_range</code> aus der Kiste
<code>rand</code> erforderlich, die einen Zufallswert aus einem Wertebereich erzeugt, der
durch einen niedrigen und einen hohen Wert festgelegt wird.</p>
<p>Das Merkmal <code>Ord</code> erlaubt dir zu wissen, dass für zwei beliebige Werte des
annotierten Typs eine gültige Reihenfolge existiert. Das Merkmal <code>Ord</code>
implementiert die Methode <code>cmp</code>, die <code>Ordering</code> statt <code>Option&lt;Ordering&gt;</code>
zurückgibt, weil eine gültige Reihenfolge immer möglich sein wird. Du kannst
das Merkmal <code>Ord</code> nur auf Typen anwenden, die auch <code>PartialOrd</code> und <code>Eq</code>
implementieren (und <code>Eq</code> erfordert <code>PartialEq</code>). Beim Ableiten auf Strukturen
und Aufzählungen verhält sich <code>cmp</code> genauso wie die abgeleitete Implementierung
für <code>partial_cmp</code> mit <code>PartialOrd</code>.</p>
<p>Ein Beispiel dafür, wann <code>Ord</code> erforderlich ist, ist das Speichern von Werten
in einem <code>BTreeSet&lt;T&gt;</code>, einer Datenstruktur, die Daten auf Grundlage der
Sortierreihenfolge der Werte speichert.</p>
<h3><a class="header" href="#clone-und-copy-zum-duplizieren-von-werten" id="clone-und-copy-zum-duplizieren-von-werten"><code>Clone</code> und <code>Copy</code> zum Duplizieren von Werten</a></h3>
<p>Das Merkmal <code>Clone</code> erlaubt es dir, explizit eine tiefe Kopie eines Wertes zu
erstellen, und der Vervielfältigungsprozess könnte die Ausführung von
beliebigem Code und das Kopieren von Daten im dynamischen Speicher beinhalten.
Siehe den Abschnitt <a href="ch04-01-what-is-ownership.html#wege-wie-variablen-und-daten-interagieren-klonen-clone">„Wege, wie Variablen und Daten interagieren: Klonen
(clone)“</a> in Kapitel 4 für weitere
Informationen zu <code>Clone</code>.</p>
<p>Das Ableiten von <code>Clone</code> implementiert die Methode <code>clone</code>, die, wenn sie für
den gesamten Typ implementiert ist, <code>clone</code> auf jedem der Teile des Typs
aufruft. Das bedeutet, dass alle Felder oder Werte des Typs auch <code>Clone</code>
implementieren müssen, um <code>Clone</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Clone</code> erforderlich ist, ist der Aufruf der Methode
<code>to_vec</code> auf einem Anteilstyp. Der Anteilstyp besitzt die Typ-Instanzen nicht,
die er enthält, aber der von <code>to_vec</code> zurückgegebene Vektor muss seine
Instanzen besitzen, also ruft <code>to_vec</code> bei jedem Element <code>clone</code> auf. Daher
muss der im Anteilstyp gespeicherte Typ <code>Clone</code> implementieren.</p>
<p>Das Merkmal <code>Copy</code> erlaubt es dir, einen Wert zu duplizieren, indem nur die auf
dem Stapelspeicher gespeicherten Bits kopiert werden; es ist kein spezieller
Code notwendig. Weitere Informationen zu <code>Copy</code> findest du im Abschnitt <a href="ch04-01-what-is-ownership.html#nur-stapelspeicher-daten-kopieren-copy">„Nur
Stapelspeicher-Daten: Kopieren (copy)“</a> in Kapitel 4.</p>
<p>Das Merkmal <code>Copy</code> definiert keine Methoden, um Programmierer daran zu hindern,
diese Methoden zu überladen und die Annahme zu verletzen, dass kein spezieller
Code ausgeführt wird. Auf diese Weise können alle Programmierer davon ausgehen,
dass das Kopieren eines Wertes sehr schnell gehen wird.</p>
<p>Du kannst <code>Copy</code> auf jeden Typ ableiten, dessen Teile alle <code>Copy</code>
implementieren. Du kannst das Merkmal <code>Copy</code> nur auf Typen anwenden, die auch
<code>Clone</code> implementieren, weil ein Typ, der <code>Copy</code> implementiert, eine triviale
Implementierung von <code>Clone</code> hat, das die gleiche Aufgabe wie <code>Copy</code> erfüllt.</p>
<p>Das Merkmal <code>Copy</code> ist selten erforderlich; Typen, die <code>Copy</code> implementieren,
verfügen über Optimierungen, d.h. du mussst nicht <code>clone</code> aufrufen, was den
Code prägnanter macht.</p>
<p>Alles, was mit <code>Copy</code> möglich ist, kannst du auch mit <code>Clone</code> erreichen, aber
der Code könnte langsamer sein oder an manchen Stellen <code>clone</code> erforderlich
machen.</p>
<h3><a class="header" href="#hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe" id="hash-für-die-abbildung-eines-wertes-auf-einen-wert-fester-größe"><code>Hash</code> für die Abbildung eines Wertes auf einen Wert fester Größe</a></h3>
<p>Das Merkmal <code>Hash</code> erlaubt es dir, eine Instanz eines Typs beliebiger Größe zu
nehmen und diese Instanz mithilfe einer Hash-Funktion auf einen Wert fester
Größe abzubilden. Das Ableiten von <code>Hash</code> implementiert die Methode <code>hash</code>. Die
abgeleitete Implementierung der Methode <code>hash</code> kombiniert das Ergebnis des
Aufrufs von <code>hash</code> für alle Teile des Typs, d.h. alle Felder oder Werte müssen
ebenfalls <code>Hash</code> implementieren, um <code>Hash</code> abzuleiten.</p>
<p>Ein Beispiel dafür, wann <code>Hash</code> erforderlich ist, ist das Speichern von
Schlüsseln in einer <code>HashMap&lt;K, V&gt;</code>, um Daten effizient zu speichern.</p>
<h3><a class="header" href="#default-für-standardwerte" id="default-für-standardwerte"><code>Default</code> für Standardwerte</a></h3>
<p>Das Merkmal <code>Default</code> erlaubt es dir, einen Standardwert für einen Typ zu
definieren. Das Ableiten von <code>Default</code> implementiert die Funktion <code>default</code>.
Die abgeleitete Implementierung der Funktion <code>default</code> ruft die Funktion
<code>default</code> für jeden Teil des Typs auf, d.h. alle Felder oder Werte in dem Typ
müssen auch <code>Default</code> implementieren, um <code>Default</code> abzuleiten.</p>
<p>Die Funktion <code>Default::default</code> wird häufig in Kombination mit der Syntax zur
Aktualisierung von Strukturen verwendet, die im Abschnitt <a href="ch05-01-defining-structs.html#instanzen-aus-anderen-instanzen-erzeugen-mit-der-strukturaktualisierungssyntax">„Instanzen aus
anderen Instanzen erzeugen mit der
Strukturaktualisierungssyntax“</a>
in Kapitel 5 besprochen wird. Du kannst einige Felder einer Struktur anpassen
und dann einen Standardwert für den Rest der Felder festlegen und verwenden,
indem du <code>...Default::default()</code> schreibst.</p>
<p>Das Merkmal <code>Default</code> ist erforderlich, wenn du die Methode <code>unwrap_or_default</code>
z.B. auf Instanzen von <code>Option&lt;T&gt;</code> verwendest. Wenn die <code>Option&lt;T&gt;</code> den Wert
<code>None</code> hat, gibt die Methode <code>unwrap_or_default</code> das Ergebnis von
<code>Default::default</code> für den Typ <code>T</code> zurück, der in <code>Option&lt;T&gt;</code> gespeichert ist.</p>
<h2><a class="header" href="#anhang-d---nützliche-entwicklungswerkzeuge" id="anhang-d---nützliche-entwicklungswerkzeuge">Anhang D - Nützliche Entwicklungswerkzeuge</a></h2>
<p>In diesem Anhang sprechen wir über einige nützliche Entwicklungswerkzeuge, die
das Rust-Projekt bietet. Wir werden uns mit automatischer Formatierung,
schnellen Möglichkeiten zum Beheben von Warnhinweisen, einem Tool zur
statischen Code-Analyse (linter) und der Integration in integrierte
Entwicklungsumgebungen (IDEs) befassen.</p>
<h3><a class="header" href="#automatische-formatierung-mit-rustfmt" id="automatische-formatierung-mit-rustfmt">Automatische Formatierung mit <code>rustfmt</code></a></h3>
<p>Das Tool <code>rustfmt</code> formatiert deinen Code entsprechend des Community-Codestils.
Viele kollaborative Projekte verwenden <code>rustfmt</code>, um Diskussionen zum Stil beim
Schreiben von Rust zu vermeiden: Jeder formatiert seinen Code mithilfe des
Tools.</p>
<p>Um <code>rustfmt</code> zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add rustfmt
</code></pre>
<p>Dieser Befehl stellt dir <code>rustfmt</code> und <code>cargo-fmt</code> zur Verfügung, ähnlich wie
Rust sowohl <code>rustc</code> als auch <code>cargo</code> bereitstellt. Um ein beliebiges
Cargo-Projekt zu formatieren, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo fmt
</code></pre>
<p>Durch Ausführen dieses Befehls wird der gesamte Rust-Code in der aktuellen
Kiste (crate) neu formatiert. Dies sollte nur den Codestil, nicht aber die
Codesemantik ändern. Weitere Informationen zu <code>rustfmt</code> findest du in <a href="https://github.com/rust-lang/rustfmt">seiner
Dokumentation</a>.</p>
<h3><a class="header" href="#korrigiere-deinen-code-mit-rustfix" id="korrigiere-deinen-code-mit-rustfix">Korrigiere deinen Code mit <code>rustfix</code></a></h3>
<p>Das Werkzeug rustfix ist in Rust-Installationen enthalten und kann automatisch
einige Kompilierer-Warnungen beheben. Wenn du Code in Rust geschrieben hast,
hast du wahrscheinlich Kompilierer-Warnungen gesehen. Betrachte zum Beispiel
diesen Code:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn do_something() {}

fn main() {
    for i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Hier rufen wir die Funktion <code>do_something</code> 100 Mal auf, aber wir verwenden die
Variable <code>i</code> im Rumpf der <code>for</code>-Schleife nicht. Rust warnt uns davor:</p>
<pre><code class="language-console">$ cargo build
   Compiling myprogram v0.1.0 (file:///projects/myprogram)
warning: unused variable: `i`
 --&gt; src/main.rs:4:9
  |
4 |     for i in 1..100 {
  |         ^ help: consider using `_i` instead
  |
  = note: #[warn(unused_variables)] on by default

    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
</code></pre>
<p>Die Warnung empfiehlt, stattdessen <code>_i</code> als Namen zu verwenden: Der Unterstrich
zeigt an, dass wir diese Variable nicht verwenden wollen. Wir können diesen
Vorschlag mit dem Werkzeug <code>rustfix</code> automatisch übernehmen, indem wir das
Kommando <code>cargo fix</code> ausführen:</p>
<pre><code class="language-console">$ cargo fix
    Checking myprogram v0.1.0 (file:///projects/myprogram)
      Fixing src/main.rs (1 fix)
    Finished dev [unoptimized + debuginfo] target(s) in 0.59s
</code></pre>
<p>Wenn wir uns <em>src/main.rs</em> noch einmal ansehen, werden wir sehen, dass
<code>cargo fix</code> den Code geändert hat:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn do_something() {}

fn main() {
    for _i in 0..100 {
        do_something();
    }
}
</code></pre></pre>
<p>Die <code>for</code>-Schleifenvariable heißt jetzt <code>_i</code> und die Warnung erscheint nicht
mehr.</p>
<p>Du kannst den Befehl <code>cargo fix</code> auch dazu verwenden, deinen Code zwischen
verschiedenen Rust-Ausgaben zu konvertieren. Die Ausgaben sind in <a href="appendix-05-editions.html">Anhang
E</a> aufgeführt.</p>
<h3><a class="header" href="#mehr-statische-codeanalyse-mit-clippy" id="mehr-statische-codeanalyse-mit-clippy">Mehr statische Codeanalyse mit Clippy</a></h3>
<p>Das Tool Clippy ist eine Sammlung von Tools zur statischen Codeanalyse, mit dem
du häufige Fehler aufspüren und deinen Rust-Code verbessern kannst.</p>
<p>Um Clippy zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add clippy
</code></pre>
<p>Um Clippy bei einem Cargo-Projekt auszuführen, gib folgendes ein:</p>
<pre><code class="language-console">$ cargo clippy
</code></pre>
<p>Angenommen, du schreibst ein Programm, das eine Annäherung an eine
mathematische Konstante wie Pi verwendet, wie dieses Programm es tut:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = 3.1415;
    let r = 8.0;
    println!(&quot;Die Kreisfläche ist {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Das Ausführen von <code>cargo clippy</code> in diesem Projekt führt zu diesem Fehler:</p>
<pre><code class="language-text">error: approximate value of `f{32, 64}::consts::PI` found. Consider using it directly
 --&gt; src/main.rs:2:13
  |
2 |     let x = 3.1415;
  |             ^^^^^^
  |
  = note: #[deny(clippy::approx_constant)] on by default
  = help: for further information visit https://rust-lang-nursery.github.io/rust-clippy/master/index.html#approx_constant
</code></pre>
<p>Dieser Fehler lässt dich wissen, dass Rust diese Konstante genauer definiert
hat und dass dein Programm korrekter wäre, wenn du stattdessen die Konstante
verwenden würdest. Du würdest dann deinen Code ändern, um die Konstante <code>PI</code> zu
verwenden. Der folgende Code führt zu keinen Fehlern oder Warnungen von Clippy:</p>
<p><span class="filename">Dateiname: src/main.rs</span></p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    let x = std::f64::consts::PI;
    let r = 8.0;
    println!(&quot;Die Kreisfläche ist {}&quot;, x * r * r);
}
</code></pre></pre>
<p>Für weitere Informationen über Clippy siehe <a href="https://github.com/rust-lang/rust-clippy">seine Dokumentation</a>.</p>
<h3><a class="header" href="#ide-integration-mittels-rust-sprach-server" id="ide-integration-mittels-rust-sprach-server">IDE-Integration mittels Rust-Sprach-Server</a></h3>
<p>Um die IDE-Integration zu erleichtern, verteilt das Rust-Projekt den
<em>Rust-Sprach-Server</em> (Rust Language Server, <code>rls</code>).</p>
<p>Dieses Werkzeug spricht das <a href="http://langserver.org/">Sprach-Server-Protokoll (Language Server
Protocol)</a>, das eine Spezifikation für IDEs und Programmiersprachen zur
Kommunikation untereinander ist. Verschiedene Clients können den <code>rls</code>
verwenden, z.B. <a href="https://marketplace.visualstudio.com/items?itemName=rust-lang.rust">das Rust-Plugin für Visual Studio Code</a>.</p>
<p>Um den <code>rls</code> zu installieren, gib folgendes ein:</p>
<pre><code class="language-console">$ rustup component add rls
</code></pre>
<p>Installiere dann die Sprachserver-Unterstützung in deiner speziellen IDE; du
bekommst Fähigkeiten wie Autovervollständigung, Sprung zur Definition und im
Code eingeblendete Fehlermeldungen.</p>
<p>Für weitere Informationen über den <code>rls</code> siehe <a href="https://github.com/rust-lang/rls">seine Dokumentation</a>.</p>
<h2><a class="header" href="#anhang-e---ausgaben" id="anhang-e---ausgaben">Anhang E - Ausgaben</a></h2>
<p>In Kapitel 1 hast du gesehen, dass <code>cargo new</code> Metadaten zur Ausgabe (edition)
in deiner Datei <em>Cargo.toml</em> hinzufügt. Dieser Anhang erläutert, was das
bedeutet!</p>
<p>Die Sprache Rust und der Kompilierer haben einen sechswöchigen
Veröffentlichungs-Zyklus, was bedeutet, dass die Nutzer einen konstanten Strom
neuer Funktionen erhalten. Andere Programmiersprachen geben weniger oft größere
Änderungen heraus; Rust gibt häufiger kleinere Aktualisierungen heraus. Nach
einer Weile summieren sich all diese kleinen Änderungen. Aber von
Veröffentlichung zu Veröffentlichung kann es schwierig sein, zurückzublicken
und zu sagen: &quot;Wow, zwischen Rust 1.10 und Rust 1.31 hat sich Rust sehr
verändert!</p>
<p>Alle zwei oder drei Jahre gibt das Rust-Team eine neue <em>Rust-Ausgabe</em> (edition)
heraus. Jede Ausgabe fasst die neuen Funktionalitäten in einem übersichtlichen
Paket mit vollständig aktualisierter Dokumentation und Werkzeugausstattung
zusammen. Neue Ausgaben werden im Rahmen des üblichen sechswöchigen
Freigabeprozesses ausgeliefert.</p>
<p>Ausgaben dienen unterschiedlichen Zwecken für verschiedene Menschen:</p>
<ul>
<li>Für aktive Rust-Nutzer fasst eine neue Ausgabe inkrementelle Änderungen in
einem leicht verständlichen Paket zusammen.</li>
<li>Für Nicht-Nutzer signalisiert eine neue Ausgabe, dass einige wichtige
Fortschritte hinzugekommen sind, sodass sich ein erneuter Blick auf Rust
lohnen könnte.</li>
<li>Für diejenigen, die Rust entwickeln, stellt eine neue Ausgabe einen
Treffpunkt für das gesamte Projekt dar.</li>
</ul>
<p>Zum Verfassungszeitpunkt dieses Artikels sind zwei Rust-Ausgaben verfügbar:
Rust 2015 und Rust 2018. Dieses Buch wurde unter Verwendung der Rust-Ausgabe
2018 geschrieben.</p>
<p>Der Schlüssel <code>edition</code> in <em>Cargo.toml</em> gibt an, welche Ausgabe der Kompilierer
für deinen Code verwenden soll. Wenn der Schlüssel nicht existiert, verwendet
Rust aus Gründen der Abwärtskompatibilität die Edition <code>2015</code>.</p>
<p>Jedes Projekt kann sich für eine Ausgabe abweichend von der Standardausgabe
2015 entscheiden. Ausgaben können inkompatible Änderungen enthalten, z.B. die
Aufnahme eines neuen Schlüsselworts, das mit Bezeichnern im Code in Konflikt
steht. Selbst wenn du dich nicht für diese Änderungen entscheidest, wird dein
Code weiterhin kompilieren, auch wenn du die verwendete
Rust-Kompilierer-Version aktualisierst.</p>
<p>Alle Rust-Kompilierer-Versionen unterstützen jede Ausgabe, die vor der
Veröffentlichung dieses Kompilierers existierte, und es können Kisten (crates)
aller unterstützten Ausgaben miteinander verknüpft werden. Ausgabenänderungen
wirken sich nur auf die Art und Weise aus, wie der Kompilierer anfangs den Code
analysiert. Wenn du also Rust 2015 verwendest und eine deiner Abhängigkeiten
Rust 2018 verwendet, wird dein Projekt diese Abhängigkeit kompilieren und
nutzen können. Die umgekehrte Situation, in der dein Projekt Rust 2018
und eine Abhängigkeit Rust 2015 verwendet, funktioniert ebenfalls.</p>
<p>Um es klar zu sagen: Die meisten Funktionen werden in allen Ausgaben verfügbar
sein. Entwickler, die eine beliebige Rust-Ausgabe verwenden, werden auch
weiterhin Verbesserungen sehen, wenn neue stabile Versionen erstellt werden. In
einigen Fällen, vor allem wenn neue Schlüsselwörter hinzugefügt werden, sind
einige neue Funktionalitäten jedoch möglicherweise erst in späteren Ausgaben
verfügbar. Du wirst die Ausgabe wechseln müssen, wenn du die Vorteile solcher
Funktionalitäten nutzen möchtest.</p>
<p>Für weitere Einzelheiten schaue in den <a href="https://doc.rust-lang.org/stable/edition-guide/"><em>Ausgabe-Leitfaden</em> (Edition
Guide)</a>, einem vollständigen Buch über Ausgaben, das die
Unterschiede zwischen den Ausgaben aufzählt und erklärt, wie du deinen Code
automatisch per <code>cargo fix</code> auf eine neue Ausgabe aktualisieren kannst.</p>
<h2><a class="header" href="#anhang-f-Übersetzungen-des-buchs" id="anhang-f-Übersetzungen-des-buchs">Anhang F: Übersetzungen des Buchs</a></h2>
<p>Für Ressourcen in anderen Sprachen als Englisch. Die meisten sind noch in
Arbeit; siehe das <a href="https://github.com/rust-lang/book/issues?q=is%3Aopen+is%3Aissue+label%3ATranslations">Label <code>Translations</code></a>, um zu helfen oder uns über
eine neue Übersetzung zu informieren!</p>
<ul>
<li><a href="https://github.com/rust-br/rust-book-pt-br">Português (BR)</a>
– <a href="https://rust-br.github.io/rust-book-pt-br/">HTML-Version</a></li>
<li><a href="https://github.com/nunojesus/rust-book-pt-pt">Português (PT)</a></li>
<li><a href="https://github.com/KaiserY/trpl-zh-cn">简体中文</a>
– <a href="https://kaisery.github.io/trpl-zh-cn/">HTML-Version</a></li>
<li><a href="https://github.com/pavloslav/rust-book-uk-ua">Українська</a></li>
<li><a href="https://github.com/thecodix/book">Español</a> </li>
<li><a href="https://github.com/ManRR/rust-book-es">Español</a>
– <a href="https://doc.rust-lang.ru/book/">HTML-Version</a></li>
<li><a href="https://github.com/ruRust/rust_book_2ed">Русский</a>
– <a href="https://doc.rust-lang.ru/book/">HTML-Version</a></li>
<li><a href="https://github.com/rinthel/rust-lang-book-ko">한국어</a>
– <a href="https://rinthel.github.io/rust-lang-book-ko/">HTML-Version</a></li>
<li><a href="https://github.com/rust-lang-ja/book-ja">日本語</a>
– <a href="https://doc.rust-jp.rs/book/second-edition/">HTML-Version</a></li>
<li><a href="https://github.com/Jimskapt/rust-book-fr">Français</a>
– <a href="https://jimskapt.github.io/rust-book-fr/">HTML-Version</a></li>
<li><a href="https://github.com/paytchoo/book-pl">Polski</a></li>
<li><a href="https://github.com/agentzero1/book">Cebuano</a></li>
<li><a href="https://github.com/josephace135/book">Tagalog</a></li>
<li><a href="https://github.com/psychoslave/Rust-libro">Esperanto</a></li>
<li><a href="https://github.com/TChatzigiannakis/rust-book-greek">ελληνική</a></li>
<li><a href="https://github.com/sebras/book">Svenska</a></li>
<li><a href="https://github.com/pomokhtari/rust-book-fa">Farsi</a>
– <a href="https://pouriamokhtari.ir/rust-book-fa/">HTML-Version</a></li>
<li><a href="https://github.com/rust-lang-de/rustbook-de">Deutsch</a>
– <a href="https://rust-lang-de.github.io/rustbook-de/">HTML-Version</a></li>
</ul>
<h2><a class="header" href="#anhang-g---wie-rust-erstellt-wird-und-nächtliches-rust" id="anhang-g---wie-rust-erstellt-wird-und-nächtliches-rust">Anhang G - Wie Rust erstellt wird und „nächtliches Rust“</a></h2>
<p>In diesem Anhang geht es darum, wie Rust erstellt wird und wie sich das auf
dich als Rust-Entwickler auswirkt.</p>
<h3><a class="header" href="#stabilität-ohne-stillstand" id="stabilität-ohne-stillstand">Stabilität ohne Stillstand</a></h3>
<p>Als Sprache kümmert sich Rust <em>viel</em> um die Stabilität deines Codes. Wir
wollen, dass Rust ein felsenfestes Fundament ist, auf dem du aufbauen kannst,
und wenn sich die Dinge ständig ändern würden, wäre das unmöglich. Gleichzeitig
werden wir, wenn wir nicht mit neuen Funktionen experimentieren können,
wichtige Mängel vielleicht erst nach ihrer Veröffentlichung entdecken, wenn wir
die Dinge nicht mehr ändern können.</p>
<p>Unsere Lösung für dieses Problem ist das, was wir „Stabilität ohne Stillstand“
nennen, und unser Leitsatz lautet: Du solltest niemals Angst vor einem Upgrade
auf eine neue Version des stabilen Rust haben müssen. Jedes Upgrade sollte
schmerzlos sein, aber auch neue Funktionalitäten, weniger Fehler und schnellere
Kompilierzeiten mit sich bringen.</p>
<h3><a class="header" href="#tüff-tüff-veröffentlichungs-kanäle-und-zugfahren" id="tüff-tüff-veröffentlichungs-kanäle-und-zugfahren">Tüff, tüff! Veröffentlichungs-Kanäle und Zugfahren</a></h3>
<p>Die Rust-Entwicklung erfolgt nach einem <em>Zugfahrplan</em> (train schedule). Das
bedeutet, dass die gesamte Entwicklung auf dem <code>master</code>-Zweig der
Rust-Versionsverwaltung durchgeführt wird. Die Veröffentlichungen folgen einem
Software-Veröffentlichungs-Zugmodell, das von Cisco IOS und anderen
Softwareprojekten verwendet wurde. Es gibt drei <em>Veröffentlichungskanäle</em>
(release channels) für Rust:</p>
<ul>
<li>Nächtlich (nightly)</li>
<li>Beta</li>
<li>Stabil (stable)</li>
</ul>
<p>Die meisten Rust-Entwickler verwenden in erster Linie den stabilen Kanal, aber
diejenigen, die experimentelle neue Funktionen ausprobieren wollen, können
nächtlich oder beta verwenden.</p>
<p>Hier ist ein Beispiel dafür, wie der Entwicklungs- und Veröffentlichungsprozess
funktioniert: Nehmen wir an, das Rust-Team arbeitet an der Veröffentlichung von
Rust 1.5. Diese Veröffentlichung erfolgte im Dezember 2015, aber sie wird uns
realistische Versionsnummern liefern. Eine neue Funktionalität wird zu Rust
hinzugefügt: Eine neue Änderung (commit) kommt in den <code>master</code>-Zweig. Jede
Nacht wird eine neue nächtliche Version von Rust produziert. Jeder Tag ist ein
Veröffentlichungs-Tag und diese Veröffentlichungen werden automatisch von
unserer Veröffentlichungs-Infrastruktur erstellt. Mit der Zeit sehen unsere
Veröffentlichungen also so aus, einmal pro Nacht:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
</code></pre>
<p>Alle sechs Wochen ist es an der Zeit, eine neue Version vorzubereiten! Der
<code>beta</code>-Zweig der Rust-Versionsverwaltung verzweigt vom <code>master</code>-Zweig, der von
„nächtlich“ benutzt wird. Jetzt gibt es zwei Versionen:</p>
<pre><code class="language-text">nächtlich: * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Die meisten Rust-Nutzer verwenden Beta-Versionen nicht aktiv, sondern testen
gegen die Beta-Version in ihrem CI-System, um Rust bei der Entdeckung möglicher
Regressionen zu unterstützen. In der Zwischenzeit gibt es immer noch jede Nacht
eine nächtliche Veröffentlichung:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - *
                       |
beta:                  *
</code></pre>
<p>Sagen wir, es wird eine Regression gefunden. Gut, dass wir etwas Zeit hatten,
die Beta-Version zu testen, bevor sich die Regression in eine stabile Version
eingeschlichen hat! Die Fehlerkorrektur wird auf <code>master</code> angewendet, sodass
„nächtlich“ korrigiert wird, und dann wird die Fehlerkorrektur in den
<code>beta</code>-Zweig zurückportiert und eine neue Version der Beta erzeugt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - *
                       |
beta:                  * - - - - - - - - *
</code></pre>
<p>Sechs Wochen nachdem die erste Beta-Version erstellt wurde, ist es Zeit für
eine stabile Veröffentlichung! Der <code>stable</code>-Zweig wird aus dem <code>beta</code>-Zweig
erstellt:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |
beta:                  * - - - - - - - - *
                                         |
stabil:                                  *
</code></pre>
<p>Hurra! Rust 1.5 ist geschafft! Eines haben wir jedoch vergessen: Da die sechs
Wochen vergangen sind, brauchen wir auch eine neue Beta der <em>nächsten</em> Version,
Rust 1.6. Nachdem also <code>stable</code> von <code>beta</code> abzweigt, zweigt die nächste Version
von <code>beta</code> wieder von <code>nightly</code> ab:</p>
<pre><code class="language-text">nächtlich: * - - * - - * - - * - - * - - * - * - *
                       |                         |
beta:                  * - - - - - - - - *       *
                                         |
stabil:                                  *
</code></pre>
<p>Dies wird als „Zugmodell“ (train model) bezeichnet, weil alle sechs Wochen eine
Veröffentlichung „den Bahnhof verlässt“, aber immer noch eine Reise durch den
Betakanal machen muss, bevor sie als stabile Version ankommt.</p>
<p>Alle sechs Wochen veröffentlicht Rust eine Version, wie ein Uhrwerk. Wenn du
das Datum einer Rust-Veröffentlichung kennst, kennst du auch das Datum der
nächsten: Sie ist sechs Wochen später. Ein schöner Aspekt der alle sechs Wochen
geplanten Veröffentlichungen ist, dass der nächste Zug bald kommt. Wenn eine
Funktionalität eine bestimmte Veröffentlichung verpasst, brauchst du dir keine
Sorgen zu machen: In kurzer Zeit kommt die nächste! Dies trägt dazu bei, den
Druck zu verringern, bevor sich möglicherweise unausgefeilte Funktionalitäten
kurz vor Ablauf der Veröffentlichungsfrist einschleichen.</p>
<p>Dank dieses Prozesses kannst du jederzeit die nächste Rust-Version ausprobieren
und dich selbst davon überzeugen, dass ein Upgrade leicht möglich ist: Wenn
eine Beta-Version nicht wie erwartet funktioniert, kannst du dies dem Team
melden und sie vor der nächsten stabilen Version korrigieren lassen! Ein Bruch
in einer Beta-Version ist relativ selten, aber <code>rustc</code> ist immer noch ein Stück
Software und es gibt Fehler.</p>
<h3><a class="header" href="#instabile-funktionalitäten" id="instabile-funktionalitäten">Instabile Funktionalitäten</a></h3>
<p>Bei diesem Veröffentlichungsmodell gibt es noch einen weiteren Haken: Instabile
Funktionalitäten. Rust verwendet eine Technik namens „Funktionalitäts-Schalter“
(feature flags), um festzulegen, welche Funktionalitäten in einer bestimmten
Version aktiviert sind. Wenn eine neue Funktionalität aktiv entwickelt wird,
landet sie auf dem <code>master</code> und damit in „nächtlich“, aber hinter einem
<em>Funktionalitäts-Schalter</em>. Wenn du als Nutzer eine in Entwicklung befindliche
Funktionalität ausprobieren möchtest, kannst du dies tun, aber du musst eine
nächtliche Version von Rust verwenden und deinen Quellcode mit dem
entsprechenden Schalter versehen, um sie nutzen zu können.</p>
<p>Wenn du eine Beta- oder stabile Version von Rust verwendest, kannst du keine
Funktionalitäts-Schalter verwenden. Dies ist der Schlüssel, der es uns
ermöglicht, neue Funktionen praktisch zu nutzen, bevor wir sie für immer für
stabil erklären. Diejenigen, die sich für das Allerneueste entscheiden wollen,
können dies tun, und diejenigen, die eine felsenfeste Erfahrung machen wollen,
können bei der stabilen Version bleiben und wissen, dass ihr Code nicht brechen
wird. Stabilität ohne Stillstand. Dieses Buch enthält nur Informationen über
stabile Funktionalitäten, da sich in Entwicklung befindliche Funktionalitäten
noch ändern, und sicherlich werden sie sich zwischen dem Zeitpunkt, an dem
dieses Buch geschrieben wurde, und dem Zeitpunkt, an dem sie in stabilen
Versionen aktiviert werden, unterscheiden. Die Dokumentation für die nur
nächtlich verfügbaren Funktionalitäten findest du online.</p>
<h3><a class="header" href="#rustup-und-die-rolle-des-nächtlichen-rust" id="rustup-und-die-rolle-des-nächtlichen-rust">Rustup und die Rolle des nächtlichen Rust</a></h3>
<p>Rustup macht es einfach, zwischen verschiedenen Veröffentlichungskanälen von
Rust zu wechseln, auf globaler oder projektbezogener Basis. Standardmäßig hast
du stabiles Rust installiert. Um die nächtliche Version zu installieren, mache
folgenden Aufruf:</p>
<pre><code class="language-console">$ rustup toolchain install nightly
</code></pre>
<p>Du kannst auch alle <em>Werkzeugketten</em> (toolchains) (Versionen von Rust und
zugehörigen Komponenten) sehen, die du mit <code>rustup</code> installiert hast. Hier ist
ein Beispiel auf dem Windows-Rechner einer deiner Autoren:</p>
<pre><code class="language-powershell">&gt; rustup toolchain list
stable-x86_64-pc-windows-msvc (default)
beta-x86_64-pc-windows-msvc
nightly-x86_64-pc-windows-msvc
</code></pre>
<p>Wie du sehen kannst, ist die stabile Werkzeugkette die Standardeinstellung. Die
meisten Rust-Nutzer verwenden meistens die stabile Version. Vielleicht möchtest
du die meiste Zeit die stabile Version verwenden, aber für ein bestimmtes
Projekt mit der nächtlichen Version arbeiten, weil dir eine innovative
Funktionalität wichtig ist. Um dies zu tun, kannst du <code>rustup override</code> im
Verzeichnis dieses Projekts benutzen, um die nächtliche Werkzeugkette als
diejenige zu setzen, die <code>rustup</code> benutzen soll, wenn du dich in diesem
Verzeichnis befindest:</p>
<pre><code class="language-console">$ cd ~/projects/needs-nightly
$ rustup override set nightly
</code></pre>
<p>Jedes Mal, wenn du nun <code>rustc</code> oder <code>cargo</code> innerhalb von
<em>~/projects/needs-nightly</em> aufrufst, stellt <code>rustup</code> sicher, dass du das
nächtliche Rust verwendest und nicht dein standardmäßiges, stabiles Rust. Das
ist praktisch, wenn du viele Rust-Projekte hast!</p>
<h3><a class="header" href="#der-rfc-prozess-und-die-teams" id="der-rfc-prozess-und-die-teams">Der RFC-Prozess und die Teams</a></h3>
<p>Wie erfährst du also von diesen neuen Funktionalitäten? Das Entwicklungsmodell
von Rust folgt einem <em>Bitte-um-Kommentare-Prozess</em> (Request For Comments, RFC). 
Wenn du eine Verbesserung von Rust wünschst, kannst du einen Vorschlag
schreiben, einen sogenannten RFC.</p>
<p>Jeder kann RFCs zur Verbesserung von Rust schreiben und die Vorschläge werden
vom Rust-Team, das aus vielen thematischen Unterteams besteht, geprüft und
diskutiert. Es gibt eine vollständige Liste der Teams auf der
<a href="https://www.rust-lang.org/governance">Rust-Website</a>, in der die Teams für jeden Projektbereich
aufgeführt sind: Sprachdesign, Kompilierer-Implementierung, Infrastruktur,
Dokumentation und weitere. Das zuständige Team liest den Vorschlag und die
Kommentare, schreibt einige eigene Kommentare und schließlich gibt es einen
Konsens, die Funktionalität anzunehmen oder abzulehnen.</p>
<p>Wenn die Funktionalität angenommen wird, wird ein Ticket (issue) in der
Rust-Versionsverwaltung eröffnet, und jemand kann es implementieren. Die
Person, die es sehr gut umsetzt, ist möglicherweise nicht die Person, die die
Funktionalität ursprünglich vorgeschlagen hat! Wenn die Implementierung fertig
ist, landet sie auf dem <code>master</code>-Zweig hinter einem Funktionalitäts-Schalter,
wie wir im Abschnitt <a href="appendix-07-nightly-rust.html#instabile-funktionalit%C3%A4ten">„Instabile
Funktionalitäten“</a> besprochen haben.</p>
<p>Nach einiger Zeit, in der Rust-Entwickler die neue Funktionalität in den
nächtlichen Veröffentlichungen ausprobieren konnten, werden die Teammitglieder
die Ausarbeitung der Funktionalität im nächtlichen Zweig diskutieren und
entscheiden, ob sie ins stabile Rust kommen soll oder nicht. Wenn die
Entscheidung positiv ist, wird das Funktionalitätstor (feature gate) entfernt
und die Funktionalität gilt jetzt als stabil! Sie fährt mit den Zügen in eine
neue stabile Version von Rust.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="theme/ferris.js"></script>
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
